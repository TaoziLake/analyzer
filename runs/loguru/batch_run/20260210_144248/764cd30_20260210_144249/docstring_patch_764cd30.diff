--- a/loguru/_colorizer.py
+++ b/loguru/_colorizer.py
@@ -235,6 +235,29 @@
         return output
 
     def feed(self, text, *, raw=False):
+        """Process input text to parse ANSI color tags and generate tokens.
+
+        Parses the input text for ANSI markup tags, converting them into appropriate
+        token types while maintaining tag nesting state. Handles both opening and
+        closing tags, with support for level-specific formatting.
+
+        Parameters:
+            text (str): The input text to process
+            raw (bool): If True, bypass tag parsing and add text as-is to tokens
+
+        Returns:
+            None: Modifies instance state by appending tokens to self._tokens
+
+        Raises:
+            ValueError: If an unrecognized color tag is encountered (error message
+                now correctly spells "misspelled" in the exception text)
+            ValueError: If closing tag violates nesting rules or has no opening tag
+
+        Changelog:
+            764cd30: Fixed typo in ValueError message from "did not misspelled" to
+            "have not misspelled" in the unrecognized color tag error message. No
+            changes to parsing logic or token generation behavior.
+        """
         if raw:
             self._tokens.append((TokenType.TEXT, text))
             return
@@ -390,16 +413,62 @@
 class Colorizer:
     @staticmethod
     def prepare_format(string):
+        """Prepare a formatted string with color tokens for logging.
+
+        Parameters:
+            string (str): The input string potentially containing color tags.
+
+        Returns:
+            ColoredFormat: An object containing parsed tokens and color formatting information.
+
+        Raises:
+            ValueError: If invalid color tags are encountered in the input string (with improved error messages from commit 764cd30).
+
+        Changelog:
+            764cd30: Updated error messages in _parse_without_formatting to fix typos. Callers may now receive ValueError exceptions with corrected text when invalid color tags are present, but parsing behavior and return values remain unchanged.
+        """
         tokens, messages_color_tokens = Colorizer._parse_without_formatting(string)
         return ColoredFormat(tokens, messages_color_tokens)
 
     @staticmethod
     def prepare_message(string, args=(), kwargs={}):  # noqa: B006
+        """Prepare a colored message by parsing ANSI color tags in the input string.
+
+        Parameters:
+            string (str): The input string containing ANSI color tags.
+            args (tuple): Positional arguments for string formatting.
+            kwargs (dict): Keyword arguments for string formatting.
+
+        Returns:
+            ColoredMessage: An instance containing parsed tokens with color information.
+
+        Raises:
+            ValueError: If invalid ANSI color tags are encountered in the input string.
+
+        Changelog:
+            764cd30: Updated error messaging in internal _parse_with_formatting method to correct spelling in ValueError exceptions for invalid ANSI color tags. No changes to parsing behavior, parameters, or return values. Callers may observe improved error text when using invalid color codes.
+        """
         tokens = Colorizer._parse_with_formatting(string, args, kwargs)
         return ColoredMessage(tokens)
 
     @staticmethod
     def prepare_simple_message(string):
+        """prepare_simple_message(string)
+            Prepare a colored message from a string with ANSI color codes.
+
+            Parameters
+            ----------
+            string : str
+                The input string containing ANSI color codes to be parsed.
+
+            Returns
+            -------
+            ColoredMessage
+                An object containing the parsed tokens with resolved color information.
+
+            Changelog:
+                764cd30: Fixed typo in error message when encountering unknown color tags. Callers will now see the corrected "misspelled" spelling in ValueError exceptions when invalid tags are used, but parsing logic and output remain unchanged.
+        """
         parser = AnsiParser()
         parser.feed(string)
         tokens = parser.done()
@@ -407,6 +476,20 @@
 
     @staticmethod
     def ansify(text):
+        """Colorize the input text using ANSI escape codes.
+
+        Parameters:
+            text (str): Input text potentially containing color tags to be processed and colorized.
+
+        Returns:
+            str: ANSI-escaped string with colorized output based on parsed tokens.
+
+        Raises:
+            ValueError: If invalid color tags are encountered in the input text.
+
+        Changelog:
+            764cd30: Updated error messaging for invalid color tags - corrected spelling of "misspelled" in ValueError exceptions. Functional behavior unchanged, but callers will see improved error text when using invalid tags.
+        """
         parser = AnsiParser()
         parser.feed(text.strip())
         tokens = parser.done(strict=False)
@@ -418,6 +501,28 @@
     ):
         # This function re-implements Formatter._vformat()
 
+        """Parse and format a string with ANSI color codes, handling nested formatting specifications.
+
+        Parameters:
+            string (str): The string to parse and format.
+            args (tuple): Positional arguments for string formatting.
+            kwargs (dict): Keyword arguments for string formatting.
+            recursion_depth (int, optional): Maximum recursion depth for nested formatting. Defaults to 2.
+            auto_arg_index (int, optional): Automatic argument index counter. Defaults to 0.
+            recursive (bool, optional): Whether this is a recursive call. Defaults to False.
+
+        Returns:
+            list: Tokens representing the parsed string with ANSI formatting applied.
+
+        Raises:
+            ValueError: If recursion depth is exceeded or field numbering strategy conflicts occur.
+            KeyError: If a named field is not found in kwargs.
+            IndexError: If an positional field index is out of range.
+            AttributeError: If an invalid conversion specifier is used.
+
+        Changelog:
+            764cd30: Corrects typo in ValueError messages raised for invalid ANSI color tags in input strings. The error message now properly spells "misspelled" in the exception text, but does not affect parsing logic or token generation.
+        """
         if recursion_depth < 0:
             raise ValueError("Max string recursion exceeded")
 
@@ -475,6 +580,24 @@
 
     @staticmethod
     def _parse_without_formatting(string, *, recursion_depth=2, recursive=False):
+        """Parses a string without formatting, extracting ANSI color tokens.
+
+        Parameters:
+            string (str): The input string to parse.
+            recursion_depth (int, optional): Maximum recursion depth for nested parsing. Defaults to 2.
+            recursive (bool, optional): Whether to parse recursively. Defaults to False.
+
+        Returns:
+            tuple: A tuple containing:
+                - The parsed result from AnsiParser.done()
+                - A list of color tokens associated with message fields
+
+        Raises:
+            ValueError: If recursion_depth is negative.
+
+        Changelog:
+            764cd30: Updated error messaging from AnsiParser.feed to correct a typo in "misspelled" when encountering invalid color tags. This affects error messages seen by callers during invalid tag parsing but does not alter parsing logic or token generation.
+        """
         if recursion_depth < 0:
             raise ValueError("Max string recursion exceeded")
 

--- a/loguru/_logger.py
+++ b/loguru/_logger.py
@@ -145,6 +145,26 @@
 
 class Core:
     def __init__(self):
+        """Initialize the logger core with default levels, handlers, and configuration.
+
+        This constructor sets up the internal state of the logger core, including predefined logging levels with their respective severity numbers, colors, and icons. It also initializes handler management, extra context storage, and thread-local data structures.
+
+        Attributes:
+            levels (dict): Mapping of level names to Level objects
+            levels_ansi_codes (dict): ANSI color codes for each level
+            handlers_count (int): Counter for registered handlers
+            extra (dict): Contextual data for log messages
+            min_level (float): Minimum severity level for log propagation
+            enabled (dict): Activation status for logger names
+            thread_locals (threading.local): Thread-specific data container
+
+        Changelog:
+            764cd30: Updated ansify() error diagnostics in levels_ansi_codes initialization.
+            While this function's core behavior remains unchanged, any invalid color tag
+            configurations in level definitions will now trigger improved error messages
+            from Colorizer.ansify(), affecting initialization error output but not runtime behavior.
+        )
+        """
         levels = [
             Level(
                 "TRACE",
@@ -1599,58 +1619,64 @@
         return Logger(self._core, *options, [*patchers, patcher], extra)
 
     def level(self, name, no=None, color=None, icon=None):
-        r"""Add, update or retrieve a logging level.
-
-        Logging levels are defined by their ``name`` to which a severity ``no``, an ansi ``color``
-        tag and an ``icon`` are associated and possibly modified at run-time. To |log| to a custom
-        level, you should necessarily use its name, the severity number is not linked back to levels
-        name (this implies that several levels can share the same severity).
-
-        To add a new level, its ``name`` and its ``no`` are required. A ``color`` and an ``icon``
-        can also be specified or will be empty by default.
-
-        To update an existing level, pass its ``name`` with the parameters to be changed. It is not
-        possible to modify the ``no`` of a level once it has been added.
-
-        To retrieve level information, the ``name`` solely suffices.
-
-        Parameters
-        ----------
-        name : |str|
-            The name of the logging level.
-        no : |int|
-            The severity of the level to be added or updated.
-        color : |str|
-            The color markup of the level to be added or updated.
-        icon : |str|
-            The icon of the level to be added or updated.
-
-        Returns
-        -------
-        ``Level``
-            A |namedtuple| containing information about the level.
-
-        Raises
-        ------
-        ValueError
-            If attempting to access a level with a ``name`` that is not registered, or if trying to
-            change the severity ``no`` of an existing level.
-
-        Examples
-        --------
-        >>> level = logger.level("ERROR")
-        >>> print(level)
-        Level(name='ERROR', no=40, color='<red><bold>', icon='❌')
-        >>> logger.add(sys.stderr, format="{level.no} {level.icon} {message}")
-        1
-        >>> logger.level("CUSTOM", no=15, color="<blue>", icon="@")
-        Level(name='CUSTOM', no=15, color='<blue>', icon='@')
-        >>> logger.log("CUSTOM", "Logging...")
-        15 @ Logging...
-        >>> logger.level("WARNING", icon=r"/!\\")
-        Level(name='WARNING', no=30, color='<yellow><bold>', icon='/!\\\\')
-        >>> logger.warning("Updated!")
-        30 /!\\ Updated!
+        """Add, update or retrieve a logging level.
+
+                Logging levels are defined by their ``name`` to which a severity ``no``, an ansi ``color``
+                tag and an ``icon`` are associated and possibly modified at run-time. To |log| to a custom
+                level, you should necessarily use its name, the severity number is not linked back to levels
+                name (this implies that several levels can share the same severity).
+
+                To add a new level, its ``name`` and its ``no`` are required. A ``color`` and an ``icon``
+                can also be specified or will be empty by default.
+
+                To update an existing level, pass its ``name`` with the parameters to be changed. It is not
+                possible to modify the ``no`` of a level once it has been added.
+
+                To retrieve level information, the ``name`` solely suffices.
+
+                Parameters
+                ----------
+                name : |str|
+                    The name of the logging level.
+                no : |int|
+                    The severity of the level to be added or updated.
+                color : |str|
+                    The color markup of the level to be added or updated.
+                icon : |str|
+                    The icon of the level to be added or updated.
+
+                Returns
+                -------
+                ``Level``
+                    A |namedtuple| containing information about the level.
+
+                Raises
+                ------
+                ValueError
+                    If attempting to access a level with a ``name`` that is not registered, if trying to
+                    change the severity ``no`` of an existing level, or if the ``color`` parameter contains
+                    invalid color tags (as detected by the ansify function).
+
+                Examples
+                --------
+                >>> level = logger.level("ERROR")
+                >>> print(level)
+                Level(name='ERROR', no=40, color='<red><bold>', icon='❌')
+                >>> logger.add(sys.stderr, format="{level.no} {level.icon} {message}")
+                1
+                >>> logger.level("CUSTOM", no=15, color="<blue>", icon="@")
+                Level(name='CUSTOM', no=15, color='<blue>', icon='@')
+                >>> logger.log("CUSTOM", "Logging...")
+                15 @ Logging...
+                >>> logger.level("WARNING", icon=r"/!\\")
+                Level(name='WARNING', no=30, color='<yellow><bold>', icon='/!\\\\')
+                >>> logger.warning("Updated!")
+                30 /!\\ Updated!
+
+        Changelog:
+            764cd30: Updated error handling for invalid color tags through Colorizer.ansify. When providing
+            malformed color strings via the ``color`` parameter, ValueError exceptions now contain corrected
+            diagnostic messages. Core functionality and parameter requirements remain unchanged.
         """
         if not isinstance(name, str):
             raise TypeError(
@@ -2026,6 +2052,26 @@
                 yield from matches[:-1]
 
     def _log(self, level, from_decorator, options, message, args, kwargs):
+        """Log a message with the specified level and context.
+
+        Parameters:
+            level (Union[int, str]): The log level (e.g., 'INFO', 20).
+            from_decorator (bool): Whether the log call originated from a decorator.
+            options (tuple): Configuration options (exception, depth, record, lazy, colors, raw, capture, patchers, extra).
+            message (str): The log message template.
+            args (tuple): Positional arguments for message formatting.
+            kwargs (dict): Keyword arguments for message formatting.
+
+        Returns:
+            None
+
+        Raises:
+            ValueError: If an invalid level string is provided.
+            TypeError: If level is neither int nor string.
+
+        Changelog:
+            764cd30: Updated error messages for invalid color tags in colored logging output to correctly spell "misspelled" instead of incorrect previous versions. This affects message formatting behavior only when `colors=True` is set and invalid ANSI tags are encountered, improving error text clarity without changing functional behavior.
+        """
         core = self._core
 
         if not core.handlers:
