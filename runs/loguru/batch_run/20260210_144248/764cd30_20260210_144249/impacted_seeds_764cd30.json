{
  "commit": "764cd30",
  "parent": "48fff58c6b5dc26953da95f564815e66fbddd309",
  "repo": "D:\\locbench\\loguru",
  "num_files_in_diff": 4,
  "num_py_files_in_diff": 4,
  "num_seeds": 7,
  "seeds": [
    {
      "path": "loguru/_colorizer.py",
      "version": "new",
      "line": 283,
      "kind": "function",
      "qualname": "loguru._colorizer.AnsiParser.feed",
      "span": [
        237,
        293
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def feed(self, text, *, raw=False):\n        if raw:\n            self._tokens.append((TokenType.TEXT, text))\n            return\n\n        position = 0\n\n        for match in self._regex_tag.finditer(text):\n            escaping, markup = match.group(1), match.group(2)\n\n            self._tokens.append((TokenType.TEXT, text[position : match.start()]))\n\n            position = match.end()\n\n            escaping_count = len(escaping)\n            backslashes = \"\\\\\" * (escaping_count // 2)\n\n            if escaping_count % 2 == 1:\n                self._tokens.append((TokenType.TEXT, backslashes + markup))\n                continue\n\n            if escaping_count > 0:\n                self._tokens.append((TokenType.TEXT, backslashes))\n\n            is_closing = markup[1] == \"/\"\n            tag = markup[2:-1] if is_closing else markup[1:-1]\n\n            if is_closing:\n                if self._tags and (tag == \"\" or tag == self._tags[-1]):\n                    self._tags.pop()\n                    self._color_tokens.pop()\n                    self._tokens.append((TokenType.CLOSING, \"\\033[0m\"))\n                    self._tokens.extend(self._color_tokens)\n                    continue\n                if tag in self._tags:\n                    raise ValueError('Closing tag \"%s\" violates nesting rules' % markup)\n                raise ValueError('Closing tag \"%s\" has no corresponding opening tag' % markup)\n\n            if tag in {\"lvl\", \"level\"}:\n                token = (TokenType.LEVEL, None)\n            else:\n                ansi = self._get_ansicode(tag)\n\n                if ansi is None:\n                    raise ValueError(\n                        'Tag \"%s\" does not correspond to any known color directive, '\n                        \"make sure you have not misspelled it (or prepend '\\\\' to escape it)\"\n                        % markup\n                    )\n\n                token = (TokenType.ANSI, ansi)\n\n            self._tags.append(tag)\n            self._color_tokens.append(token)\n            self._tokens.append(token)\n\n        self._tokens.append((TokenType.TEXT, text[position:]))",
      "old_code": "    def feed(self, text, *, raw=False):\n        if raw:\n            self._tokens.append((TokenType.TEXT, text))\n            return\n\n        position = 0\n\n        for match in self._regex_tag.finditer(text):\n            escaping, markup = match.group(1), match.group(2)\n\n            self._tokens.append((TokenType.TEXT, text[position : match.start()]))\n\n            position = match.end()\n\n            escaping_count = len(escaping)\n            backslashes = \"\\\\\" * (escaping_count // 2)\n\n            if escaping_count % 2 == 1:\n                self._tokens.append((TokenType.TEXT, backslashes + markup))\n                continue\n\n            if escaping_count > 0:\n                self._tokens.append((TokenType.TEXT, backslashes))\n\n            is_closing = markup[1] == \"/\"\n            tag = markup[2:-1] if is_closing else markup[1:-1]\n\n            if is_closing:\n                if self._tags and (tag == \"\" or tag == self._tags[-1]):\n                    self._tags.pop()\n                    self._color_tokens.pop()\n                    self._tokens.append((TokenType.CLOSING, \"\\033[0m\"))\n                    self._tokens.extend(self._color_tokens)\n                    continue\n                if tag in self._tags:\n                    raise ValueError('Closing tag \"%s\" violates nesting rules' % markup)\n                raise ValueError('Closing tag \"%s\" has no corresponding opening tag' % markup)\n\n            if tag in {\"lvl\", \"level\"}:\n                token = (TokenType.LEVEL, None)\n            else:\n                ansi = self._get_ansicode(tag)\n\n                if ansi is None:\n                    raise ValueError(\n                        'Tag \"%s\" does not correspond to any known color directive, '\n                        \"make sure you did not misspelled it (or prepend '\\\\' to escape it)\"\n                        % markup\n                    )\n\n                token = (TokenType.ANSI, ansi)\n\n            self._tags.append(tag)\n            self._color_tokens.append(token)\n            self._tokens.append(token)\n\n        self._tokens.append((TokenType.TEXT, text[position:]))"
    },
    {
      "path": "tests/test_ansimarkup_basic.py",
      "version": "new",
      "line": 222,
      "kind": "function",
      "qualname": "tests.test_ansimarkup_basic.test_invalid_color",
      "span": [
        217,
        225
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_invalid_color(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)",
      "old_code": "def test_invalid_color(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)"
    },
    {
      "path": "tests/test_ansimarkup_extended.py",
      "version": "new",
      "line": 160,
      "kind": "function",
      "qualname": "tests.test_ansimarkup_extended.test_invalid_color",
      "span": [
        155,
        163
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_invalid_color(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)",
      "old_code": "def test_invalid_color(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)"
    },
    {
      "path": "tests/test_ansimarkup_extended.py",
      "version": "new",
      "line": 182,
      "kind": "function",
      "qualname": "tests.test_ansimarkup_extended.test_invalid_hex",
      "span": [
        177,
        185
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_invalid_hex(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)",
      "old_code": "def test_invalid_hex(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)"
    },
    {
      "path": "tests/test_ansimarkup_extended.py",
      "version": "new",
      "line": 195,
      "kind": "function",
      "qualname": "tests.test_ansimarkup_extended.test_invalid_8bit",
      "span": [
        190,
        198
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_invalid_8bit(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)",
      "old_code": "def test_invalid_8bit(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)"
    },
    {
      "path": "tests/test_ansimarkup_extended.py",
      "version": "new",
      "line": 217,
      "kind": "function",
      "qualname": "tests.test_ansimarkup_extended.test_invalid_rgb",
      "span": [
        212,
        220
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_invalid_rgb(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)",
      "old_code": "def test_invalid_rgb(text, strip):\n    with pytest.raises(\n        ValueError,\n        match=(\n            '^Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)$\"\n        ),\n    ):\n        parse(text, strip=strip)"
    },
    {
      "path": "tests/test_levels.py",
      "version": "new",
      "line": 275,
      "kind": "function",
      "qualname": "tests.test_levels.test_add_level_unknown_color",
      "span": [
        270,
        278
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_add_level_unknown_color(color):\n    with pytest.raises(\n        ValueError,\n        match=(\n            'Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you have not misspelled it \\(or prepend '\\\\' to escape it\\)\"\n        ),\n    ):\n        logger.level(\"foobar\", no=20, icon=\"\", color=color)",
      "old_code": "def test_add_level_unknown_color(color):\n    with pytest.raises(\n        ValueError,\n        match=(\n            'Tag \"<[^>]*>\" does not correspond to any known color directive, '\n            r\"make sure you did not misspelled it \\(or prepend '\\\\' to escape it\\)\"\n        ),\n    ):\n        logger.level(\"foobar\", no=20, icon=\"\", color=color)"
    }
  ],
  "generated_at": "2026-02-10T14:42:50"
}