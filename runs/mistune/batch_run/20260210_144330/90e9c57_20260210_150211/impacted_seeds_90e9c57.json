{
  "commit": "90e9c57",
  "parent": "ff8312943e0509b74662a1c4be12514d70a1845a",
  "repo": "D:\\locbench\\mistune",
  "num_files_in_diff": 45,
  "num_py_files_in_diff": 45,
  "num_seeds": 312,
  "seeds": [
    {
      "path": "benchmark/bench.py",
      "version": "new",
      "line": 6,
      "kind": "module",
      "qualname": "benchmark.bench",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "benchmark/bench.py",
      "version": "new",
      "line": 13,
      "kind": "function",
      "qualname": "benchmark.bench.load_case",
      "span": [
        12,
        22
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def load_case(filename):\n    if filename == \"readme.txt\":\n        filepath = os.path.join(ROOT_DIR, \"../README.md\")\n    else:\n        filepath = os.path.join(ROOT_DIR, \"cases\", filename)\n    with open(filepath, \"r\") as f:\n        content = f.read()\n\n    name = filename.replace(\".txt\", \"\")\n    CASES[name] = content\n    return content",
      "old_code": "def load_case(filename):\n    if filename == 'readme.txt':\n        filepath = os.path.join(ROOT_DIR, '../README.md')\n    else:\n        filepath = os.path.join(ROOT_DIR, 'cases', filename)\n    with open(filepath, 'r') as f:\n        content = f.read()\n\n    name = filename.replace('.txt', '')\n    CASES[name] = content\n    return content"
    },
    {
      "path": "benchmark/bench.py",
      "version": "new",
      "line": 44,
      "kind": "function",
      "qualname": "benchmark.bench.get_markdown_parsers",
      "span": [
        39,
        117
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def get_markdown_parsers():\n    parsers = {}\n\n    import mistune\n    from mistune.directives import (\n        RSTDirective,\n        Admonition,\n        TableOfContents,\n        Include,\n    )\n\n    parsers[f\"mistune ({mistune.__version__})\"] = mistune.html\n    parsers[f\"mistune (slow)\"] = mistune.create_markdown(escape=False)\n    parsers[f\"mistune (fast)\"] = mistune.create_markdown(escape=False, plugins=[\"speedup\"])\n    parsers[\"mistune (full)\"] = mistune.create_markdown(\n        escape=False,\n        plugins=[\n            \"url\",\n            \"abbr\",\n            \"ruby\",\n            \"strikethrough\",\n            \"mark\",\n            \"insert\",\n            \"subscript\",\n            \"superscript\",\n            \"footnotes\",\n            \"def_list\",\n            \"math\",\n            \"table\",\n            \"task_lists\",\n            RSTDirective(\n                [\n                    Admonition(),\n                    TableOfContents(),\n                    Include(),\n                ]\n            ),\n            \"speedup\",\n        ],\n    )\n\n    try:\n        import mistune_v1\n\n        parsers[f\"mistune ({mistune_v1.__version__})\"] = mistune_v1.markdown\n    except ImportError:\n        pass\n\n    try:\n        import markdown\n\n        parsers[f\"markdown ({markdown.__version__})\"] = markdown.markdown\n    except ImportError:\n        pass\n\n    try:\n        from markdown2 import Markdown, __version__ as m2v\n\n        markdowner = Markdown()\n        parsers[f\"markdown2 ({m2v})\"] = markdowner.convert\n    except ImportError:\n        pass\n\n    try:\n        import mistletoe\n\n        parsers[f\"mistletoe ({mistletoe.__version__})\"] = mistletoe.markdown\n    except ImportError:\n        pass\n\n    try:\n        from markdown_it import MarkdownIt, __version__ as mitv\n\n        md = MarkdownIt()\n        parsers[f\"markdown_it ({mitv})\"] = md.render\n    except ImportError:\n        pass\n\n    return parsers",
      "old_code": "def get_markdown_parsers():\n    parsers = {}\n\n    import mistune\n    from mistune.directives import (\n        RSTDirective, Admonition, TableOfContents, Include,\n    )\n\n    parsers[f'mistune ({mistune.__version__})'] = mistune.html\n    parsers[f'mistune (slow)'] = mistune.create_markdown(escape=False)\n    parsers[f'mistune (fast)'] = mistune.create_markdown(\n        escape=False, plugins=['speedup'])\n    parsers['mistune (full)'] = mistune.create_markdown(\n        escape=False,\n        plugins=[\n            'url', 'abbr', 'ruby',\n            'strikethrough', 'mark', 'insert', 'subscript', 'superscript',\n            'footnotes', 'def_list', 'math', 'table', 'task_lists',\n            RSTDirective([\n                Admonition(),\n                TableOfContents(),\n                Include(),\n            ]),\n            'speedup',\n        ],\n    )\n\n    try:\n        import mistune_v1\n        parsers[f'mistune ({mistune_v1.__version__})'] = mistune_v1.markdown\n    except ImportError:\n        pass\n\n    try:\n        import markdown\n        parsers[f'markdown ({markdown.__version__})'] = markdown.markdown\n    except ImportError:\n        pass\n\n    try:\n        from markdown2 import Markdown, __version__ as m2v\n        markdowner = Markdown()\n        parsers[f'markdown2 ({m2v})'] = markdowner.convert\n    except ImportError:\n        pass\n\n    try:\n        import mistletoe\n        parsers[f'mistletoe ({mistletoe.__version__})'] = mistletoe.markdown\n    except ImportError:\n        pass\n\n    try:\n        from markdown_it import MarkdownIt, __version__ as mitv\n        md = MarkdownIt()\n        parsers[f'markdown_it ({mitv})'] = md.render\n    except ImportError:\n        pass\n\n    return parsers"
    },
    {
      "path": "benchmark/bench.py",
      "version": "new",
      "line": 123,
      "kind": "function",
      "qualname": "benchmark.bench.benchmarks",
      "span": [
        120,
        128
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def benchmarks(cases, count=100):\n    methods = get_markdown_parsers()\n    for name in cases:\n        content = load_case(name + \".txt\")\n\n        for md_name in methods:\n            func = methods[md_name]\n            duration = run_case(func, content, count)\n            print(f\"{md_name} - {name}: {duration}ms\")",
      "old_code": "def benchmarks(cases, count=100):\n    methods = get_markdown_parsers()\n    for name in cases:\n        content = load_case(name + '.txt')\n\n        for md_name in methods:\n            func = methods[md_name]\n            duration = run_case(func, content, count)\n            print(f'{md_name} - {name}: {duration}ms')"
    },
    {
      "path": "docs/conf.py",
      "version": "new",
      "line": 3,
      "kind": "module",
      "qualname": "docs.conf",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/__init__.py",
      "version": "new",
      "line": 2,
      "kind": "module",
      "qualname": "src.mistune.__init__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/__init__.py",
      "version": "new",
      "line": 45,
      "kind": "function",
      "qualname": "src.mistune.__init__.create_markdown",
      "span": [
        23,
        55
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def create_markdown(\n    escape: bool = True,\n    hard_wrap: bool = False,\n    renderer: Optional[RendererRef] = \"html\",\n    plugins: Optional[Iterable[PluginRef]] = None,\n) -> Markdown:\n    \"\"\"Create a Markdown instance based on the given condition.\n\n    :param escape: Boolean. If using html renderer, escape html.\n    :param hard_wrap: Boolean. Break every new line into ``<br>``.\n    :param renderer: renderer instance, default is HTMLRenderer.\n    :param plugins: List of plugins.\n\n    This method is used when you want to re-use a Markdown instance::\n\n        markdown = create_markdown(\n            escape=False,\n            hard_wrap=True,\n        )\n        # re-use markdown function\n        markdown('.... your text ...')\n    \"\"\"\n    if renderer == \"ast\":\n        # explicit and more similar to 2.x's API\n        renderer = None\n    elif renderer == \"html\":\n        renderer = HTMLRenderer(escape=escape)\n\n    inline = InlineParser(hard_wrap=hard_wrap)\n    real_plugins: Optional[Iterable[Plugin]] = None\n    if plugins is not None:\n        real_plugins = [import_plugin(n) for n in plugins]\n    return Markdown(renderer=renderer, inline=inline, plugins=real_plugins)",
      "old_code": "def create_markdown(\n    escape: bool = True,\n    hard_wrap: bool = False,\n    renderer: Optional[RendererRef] = \"html\",\n    plugins: Optional[Iterable[PluginRef]] = None,\n) -> Markdown:\n    \"\"\"Create a Markdown instance based on the given condition.\n\n    :param escape: Boolean. If using html renderer, escape html.\n    :param hard_wrap: Boolean. Break every new line into ``<br>``.\n    :param renderer: renderer instance, default is HTMLRenderer.\n    :param plugins: List of plugins.\n\n    This method is used when you want to re-use a Markdown instance::\n\n        markdown = create_markdown(\n            escape=False,\n            hard_wrap=True,\n        )\n        # re-use markdown function\n        markdown('.... your text ...')\n    \"\"\"\n    if renderer == 'ast':\n        # explicit and more similar to 2.x's API\n        renderer = None\n    elif renderer == 'html':\n        renderer = HTMLRenderer(escape=escape)\n\n    inline = InlineParser(hard_wrap=hard_wrap)\n    real_plugins: Optional[Iterable[Plugin]] = None\n    if plugins is not None:\n        real_plugins = [import_plugin(n) for n in plugins]\n    return Markdown(renderer=renderer, inline=inline, plugins=real_plugins)"
    },
    {
      "path": "src/mistune/__main__.py",
      "version": "new",
      "line": 20,
      "kind": "function",
      "qualname": "src.mistune.__main__._md",
      "span": [
        15,
        33
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _md(args: argparse.Namespace) -> \"Markdown\":\n    if args.plugin:\n        plugins = args.plugin\n    else:\n        # default plugins\n        plugins = [\"strikethrough\", \"footnotes\", \"table\", \"speedup\"]\n\n    if args.renderer == \"rst\":\n        renderer: \"BaseRenderer\" = RSTRenderer()\n    elif args.renderer == \"markdown\":\n        renderer = MarkdownRenderer()\n    else:\n        renderer = args.renderer\n    return create_markdown(\n        escape=args.escape,\n        hard_wrap=args.hardwrap,\n        renderer=renderer,\n        plugins=plugins,\n    )",
      "old_code": "def _md(args: argparse.Namespace) -> \"Markdown\":\n    if args.plugin:\n        plugins = args.plugin\n    else:\n        # default plugins\n        plugins = ['strikethrough', 'footnotes', 'table', 'speedup']\n\n    if args.renderer == \"rst\":\n        renderer: \"BaseRenderer\" = RSTRenderer()\n    elif args.renderer == \"markdown\":\n        renderer = MarkdownRenderer()\n    else:\n        renderer = args.renderer\n    return create_markdown(\n        escape=args.escape,\n        hard_wrap=args.hardwrap,\n        renderer=renderer,\n        plugins=plugins,\n    )"
    },
    {
      "path": "src/mistune/__main__.py",
      "version": "new",
      "line": 38,
      "kind": "function",
      "qualname": "src.mistune.__main__._output",
      "span": [
        36,
        41
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _output(text: str, args: argparse.Namespace) -> None:\n    if args.output:\n        with open(args.output, \"w\") as f:\n            f.write(text)\n    else:\n        print(text)",
      "old_code": "def _output(text: str, args: argparse.Namespace) -> None:\n    if args.output:\n        with open(args.output, 'w') as f:\n            f.write(text)\n    else:\n        print(text)"
    },
    {
      "path": "src/mistune/__main__.py",
      "version": "new",
      "line": 44,
      "kind": "module",
      "qualname": "src.mistune.__main__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/__main__.py",
      "version": "new",
      "line": 61,
      "kind": "function",
      "qualname": "src.mistune.__main__.cli",
      "span": [
        59,
        123
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def cli() -> None:\n    parser = argparse.ArgumentParser(\n        prog=\"python -m mistune\",\n        description=CMD_HELP,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--message\",\n        help=\"the markdown message to convert\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--file\",\n        help=\"the markdown file to convert\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--plugin\",\n        metavar=\"NAME\",\n        action=\"extend\",\n        nargs=\"+\",\n        help=\"specifiy a plugin to use\",\n    )\n    parser.add_argument(\n        \"--escape\",\n        action=\"store_true\",\n        help=\"turn on escape option\",\n    )\n    parser.add_argument(\n        \"--hardwrap\",\n        action=\"store_true\",\n        help=\"turn on hardwrap option\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        help=\"write the rendered result into file\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--renderer\",\n        default=\"html\",\n        help=\"specify the output renderer\",\n    )\n    parser.add_argument(\"--version\", action=\"version\", version=\"mistune \" + version)\n    args = parser.parse_args()\n\n    message = args.message\n    if not message and not args.file:\n        message = read_stdin()\n\n    if message:\n        md = _md(args)\n        text = md(message)\n        assert isinstance(text, str)\n        _output(text, args)\n    elif args.file:\n        md = _md(args)\n        text = md.read(args.file)[0]\n        assert isinstance(text, str)\n        _output(text, args)\n    else:\n        print(\"You MUST specify a message or file\")\n        sys.exit(1)",
      "old_code": "def cli() -> None:\n    parser = argparse.ArgumentParser(\n        prog='python -m mistune',\n        description=CMD_HELP,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-m', '--message',\n        help='the markdown message to convert',\n    )\n    parser.add_argument(\n        '-f', '--file',\n        help='the markdown file to convert',\n    )\n    parser.add_argument(\n        '-p', '--plugin',\n        metavar='NAME',\n        action='extend',\n        nargs='+',\n        help='specifiy a plugin to use',\n    )\n    parser.add_argument(\n        '--escape',\n        action='store_true',\n        help='turn on escape option',\n    )\n    parser.add_argument(\n        '--hardwrap',\n        action='store_true',\n        help='turn on hardwrap option',\n    )\n    parser.add_argument(\n        '-o', '--output',\n        help='write the rendered result into file',\n    )\n    parser.add_argument(\n        '-r', '--renderer',\n        default='html',\n        help='specify the output renderer',\n    )\n    parser.add_argument('--version', action='version', version='mistune ' + version)\n    args = parser.parse_args()\n\n    message = args.message\n    if not message and not args.file:\n        message = read_stdin()\n\n    if message:\n        md = _md(args)\n        text = md(message)\n        assert isinstance(text, str)\n        _output(text, args)\n    elif args.file:\n        md = _md(args)\n        text = md.read(args.file)[0]\n        assert isinstance(text, str)\n        _output(text, args)\n    else:\n        print('You MUST specify a message or file')\n        sys.exit(1)"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 22,
      "kind": "module",
      "qualname": "src.mistune.block_parser",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 39,
      "kind": "class",
      "qualname": "src.mistune.block_parser.BlockParser",
      "span": [
        36,
        469
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class BlockParser(Parser[BlockState]):\n    state_cls = BlockState\n\n    BLANK_LINE = re.compile(r\"(^[ \\t\\v\\f]*\\n)+\", re.M)\n\n    RAW_HTML = (\n        r\"^ {0,3}(\"\n        r\"</?\" + HTML_TAGNAME + r\"|\"\n        r\"<!--|\"  # comment\n        r\"<\\?|\"  # script\n        r\"<![A-Z]|\"\n        r\"<!\\[CDATA\\[)\"\n    )\n\n    BLOCK_HTML = (\n        r\"^ {0,3}(?:\"\n        r\"(?:</?\" + _BLOCK_TAGS_PATTERN + r\"(?:[ \\t]+|\\n|$))\"\n        r\"|<!--\"  # comment\n        r\"|<\\?\"  # script\n        r\"|<![A-Z]\"\n        r\"|<!\\[CDATA\\[)\"\n    )\n\n    SPECIFICATION = {\n        \"blank_line\": r\"(^[ \\t\\v\\f]*\\n)+\",\n        \"atx_heading\": r\"^ {0,3}(?P<atx_1>#{1,6})(?!#+)(?P<atx_2>[ \\t]*|[ \\t]+.*?)$\",\n        \"setex_heading\": r\"^ {0,3}(?P<setext_1>=|-){1,}[ \\t]*$\",\n        \"fenced_code\": (\n            r\"^(?P<fenced_1> {0,3})(?P<fenced_2>`{3,}|~{3,})\"\n            r\"[ \\t]*(?P<fenced_3>.*?)$\"\n        ),\n        \"indent_code\": (\n            r\"^(?: {4}| *\\t)[^\\n]+(?:\\n+|$)\"\n            r\"((?:(?: {4}| *\\t)[^\\n]+(?:\\n+|$))|\\s)*\"\n        ),\n        \"thematic_break\": r\"^ {0,3}((?:-[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})$\",\n        \"ref_link\": r\"^ {0,3}\\[(?P<reflink_1>\" + LINK_LABEL + r\")\\]:\",\n        \"block_quote\": r\"^ {0,3}>(?P<quote_1>.*?)$\",\n        \"list\": LIST_PATTERN,\n        \"block_html\": BLOCK_HTML,\n        \"raw_html\": RAW_HTML,\n    }\n\n    DEFAULT_RULES = (\n        \"fenced_code\",\n        \"indent_code\",\n        \"atx_heading\",\n        \"setex_heading\",\n        \"thematic_break\",\n        \"block_quote\",\n        \"list\",\n        \"ref_link\",\n        \"raw_html\",\n        \"blank_line\",\n    )\n\n    def __init__(\n        self,\n        block_quote_rules: Optional[List[str]] = None,\n        list_rules: Optional[List[str]] = None,\n        max_nested_level: int = 6,\n    ):\n        super(BlockParser, self).__init__()\n\n        if block_quote_rules is None:\n            block_quote_rules = list(self.DEFAULT_RULES)\n\n        if list_rules is None:\n            list_rules = list(self.DEFAULT_RULES)\n\n        self.block_quote_rules = block_quote_rules\n        self.list_rules = list_rules\n        self.max_nested_level = max_nested_level\n        # register default parse methods\n        self._methods = {name: getattr(self, \"parse_\" + name) for name in self.SPECIFICATION}\n\n    def parse_blank_line(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for blank lines.\"\"\"\n        state.append_token({\"type\": \"blank_line\"})\n        return m.end()\n\n    def parse_thematic_break(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for thematic break, e.g. ``<hr>`` tag in HTML.\"\"\"\n        state.append_token({\"type\": \"thematic_break\"})\n        # $ does not count '\\n'\n        return m.end() + 1\n\n    def parse_indent_code(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for code block which is indented by 4 spaces.\"\"\"\n        # it is a part of the paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        code = m.group(0)\n        code = expand_leading_tab(code)\n        code = _INDENT_CODE_TRIM.sub(\"\", code)\n        code = code.strip(\"\\n\")\n        state.append_token({\"type\": \"block_code\", \"raw\": code, \"style\": \"indent\"})\n        return m.end()\n\n    def parse_fenced_code(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for fenced code block. A fenced code block is started with\n        3 or more backtick(`) or tilde(~).\n\n        An example of a fenced code block:\n\n        .. code-block:: markdown\n\n            ```python\n            def markdown(text):\n                return mistune.html(text)\n            ```\n        \"\"\"\n        spaces = m.group(\"fenced_1\")\n        marker = m.group(\"fenced_2\")\n        info = m.group(\"fenced_3\")\n\n        c = marker[0]\n        if info and c == \"`\":\n            # CommonMark Example 145\n            # Info strings for backtick code blocks cannot contain backticks\n            if info.find(c) != -1:\n                return None\n\n        _end = re.compile(r\"^ {0,3}\" + c + \"{\" + str(len(marker)) + r\",}[ \\t]*(?:\\n|$)\", re.M)\n        cursor_start = m.end() + 1\n\n        m2 = _end.search(state.src, cursor_start)\n        if m2:\n            code = state.src[cursor_start : m2.start()]\n            end_pos = m2.end()\n        else:\n            code = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        if spaces and code:\n            _trim_pattern = re.compile(\"^ {0,\" + str(len(spaces)) + \"}\", re.M)\n            code = _trim_pattern.sub(\"\", code)\n\n        token = {\"type\": \"block_code\", \"raw\": code, \"style\": \"fenced\", \"marker\": marker}\n        if info:\n            info = unescape_char(info)\n            token[\"attrs\"] = {\"info\": info.strip()}\n\n        state.append_token(token)\n        return end_pos\n\n    def parse_atx_heading(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for ATX heading. An ATX heading is started with 1 to 6\n        symbol of ``#``.\"\"\"\n        level = len(m.group(\"atx_1\"))\n        text = m.group(\"atx_2\").strip()\n        # remove last #\n        if text:\n            text = _ATX_HEADING_TRIM.sub(\"\", text)\n\n        token = {\"type\": \"heading\", \"text\": text, \"attrs\": {\"level\": level}, \"style\": \"atx\"}\n        state.append_token(token)\n        return m.end() + 1\n\n    def parse_setex_heading(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for setex style heading. A setex heading syntax looks like:\n\n        .. code-block:: markdown\n\n            H1 title\n            ========\n        \"\"\"\n        last_token = state.last_token()\n        if last_token and last_token[\"type\"] == \"paragraph\":\n            level = 1 if m.group(\"setext_1\") == \"=\" else 2\n            last_token[\"type\"] = \"heading\"\n            last_token[\"style\"] = \"setext\"\n            last_token[\"attrs\"] = {\"level\": level}\n            return m.end() + 1\n\n        sc = self.compile_sc([\"thematic_break\", \"list\"])\n        m2 = sc.match(state.src, state.cursor)\n        if m2:\n            return self.parse_method(m2, state)\n        return None\n\n    def parse_ref_link(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse link references and save the link information into ``state.env``.\n\n        Here is an example of a link reference:\n\n        .. code-block:: markdown\n\n            a [link][example]\n\n            [example]: https://example.com \"Optional title\"\n\n        This method will save the link reference into ``state.env`` as::\n\n            state.env['ref_links']['example'] = {\n                'url': 'https://example.com',\n                'title': \"Optional title\",\n            }\n        \"\"\"\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        label = m.group(\"reflink_1\")\n        key = unikey(label)\n        if not key:\n            return None\n\n        href, href_pos = parse_link_href(state.src, m.end(), block=True)\n        if href is None:\n            return None\n\n        assert href_pos is not None\n\n        _blank = self.BLANK_LINE.search(state.src, href_pos)\n        if _blank:\n            max_pos = _blank.start()\n        else:\n            max_pos = state.cursor_max\n\n        title, title_pos = parse_link_title(state.src, href_pos, max_pos)\n        if title_pos:\n            m2 = _BLANK_TO_LINE.match(state.src, title_pos)\n            if m2:\n                title_pos = m2.end()\n            else:\n                title_pos = None\n                title = None\n\n        if title_pos is None:\n            m3 = _BLANK_TO_LINE.match(state.src, href_pos)\n            if m3:\n                href_pos = m3.end()\n            else:\n                href_pos = None\n                href = None\n\n        end_pos = title_pos or href_pos\n        if not end_pos:\n            return None\n\n        if key not in state.env[\"ref_links\"]:\n            assert href is not None\n            href = unescape_char(href)\n            data = {\"url\": escape_url(href), \"label\": label}\n            if title:\n                data[\"title\"] = title\n            state.env[\"ref_links\"][key] = data\n        return end_pos\n\n    def extract_block_quote(self, m: Match[str], state: BlockState) -> Tuple[str, Optional[int]]:\n        \"\"\"Extract text and cursor end position of a block quote.\"\"\"\n\n        # cleanup at first to detect if it is code block\n        text = m.group(\"quote_1\") + \"\\n\"\n        text = expand_leading_tab(text, 3)\n        text = _BLOCK_QUOTE_TRIM.sub(\"\", text)\n\n        sc = self.compile_sc([\"blank_line\", \"indent_code\", \"fenced_code\"])\n        require_marker = bool(sc.match(text))\n\n        state.cursor = m.end() + 1\n\n        end_pos: Optional[int] = None\n        if require_marker:\n            m2 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n            if m2:\n                quote = m2.group(0)\n                quote = _BLOCK_QUOTE_LEADING.sub(\"\", quote)\n                quote = expand_leading_tab(quote, 3)\n                quote = _BLOCK_QUOTE_TRIM.sub(\"\", quote)\n                text += quote\n                state.cursor = m2.end()\n        else:\n            prev_blank_line = False\n            break_sc = self.compile_sc(\n                [\n                    \"blank_line\",\n                    \"thematic_break\",\n                    \"fenced_code\",\n                    \"list\",\n                    \"block_html\",\n                ]\n            )\n            while state.cursor < state.cursor_max:\n                m3 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n                if m3:\n                    quote = m3.group(0)\n                    quote = _BLOCK_QUOTE_LEADING.sub(\"\", quote)\n                    quote = expand_leading_tab(quote, 3)\n                    quote = _BLOCK_QUOTE_TRIM.sub(\"\", quote)\n                    text += quote\n                    state.cursor = m3.end()\n                    if not quote.strip():\n                        prev_blank_line = True\n                    else:\n                        prev_blank_line = bool(_LINE_BLANK_END.search(quote))\n                    continue\n\n                if prev_blank_line:\n                    # CommonMark Example 249\n                    # because of laziness, a blank line is needed between\n                    # a block quote and a following paragraph\n                    break\n\n                m4 = break_sc.match(state.src, state.cursor)\n                if m4:\n                    end_pos = self.parse_method(m4, state)\n                    if end_pos:\n                        break\n\n                # lazy continuation line\n                pos = state.find_line_end()\n                line = state.get_text(pos)\n                line = expand_leading_tab(line, 3)\n                text += line\n                state.cursor = pos\n\n        # according to CommonMark Example 6, the second tab should be\n        # treated as 4 spaces\n        return expand_tab(text), end_pos\n\n    def parse_block_quote(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for block quote. Here is an example of the syntax:\n\n        .. code-block:: markdown\n\n            > a block quote starts\n            > with right arrows\n        \"\"\"\n        text, end_pos = self.extract_block_quote(m, state)\n        # scan children state\n        child = state.child_state(text)\n        if state.depth() >= self.max_nested_level - 1:\n            rules = list(self.block_quote_rules)\n            rules.remove(\"block_quote\")\n        else:\n            rules = self.block_quote_rules\n\n        self.parse(child, rules)\n        token = {\"type\": \"block_quote\", \"children\": child.tokens}\n        if end_pos:\n            state.prepend_token(token)\n            return end_pos\n        state.append_token(token)\n        return state.cursor\n\n    def parse_list(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n        return parse_list(self, m, state)\n\n    def parse_block_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        return self.parse_raw_html(m, state)\n\n    def parse_raw_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        marker = m.group(0).strip()\n\n        # rule 2\n        if marker == \"<!--\":\n            return _parse_html_to_end(state, \"-->\", m.end())\n\n        # rule 3\n        if marker == \"<?\":\n            return _parse_html_to_end(state, \"?>\", m.end())\n\n        # rule 5\n        if marker == \"<![CDATA[\":\n            return _parse_html_to_end(state, \"]]>\", m.end())\n\n        # rule 4\n        if marker.startswith(\"<!\"):\n            return _parse_html_to_end(state, \">\", m.end())\n\n        close_tag = None\n        open_tag = None\n        if marker.startswith(\"</\"):\n            close_tag = marker[2:].lower()\n            # rule 6\n            if close_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n        else:\n            open_tag = marker[1:].lower()\n            # rule 1\n            if open_tag in PRE_TAGS:\n                end_tag = \"</\" + open_tag + \">\"\n                return _parse_html_to_end(state, end_tag, m.end())\n            # rule 6\n            if open_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        # Blocks of type 7 may not interrupt a paragraph.\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        # rule 7\n        start_pos = m.end()\n        end_pos = state.find_line_end()\n        if (open_tag and _OPEN_TAG_END.match(state.src, start_pos, end_pos)) or (\n            close_tag and _CLOSE_TAG_END.match(state.src, start_pos, end_pos)\n        ):\n            return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        return None\n\n    def parse(self, state: BlockState, rules: Optional[List[str]] = None) -> None:\n        sc = self.compile_sc(rules)\n\n        while state.cursor < state.cursor_max:\n            m = sc.search(state.src, state.cursor)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > state.cursor:\n                text = state.get_text(end_pos)\n                state.add_paragraph(text)\n                state.cursor = end_pos\n\n            end_pos2 = self.parse_method(m, state)\n            if end_pos2:\n                state.cursor = end_pos2\n            else:\n                end_pos3 = state.find_line_end()\n                text = state.get_text(end_pos3)\n                state.add_paragraph(text)\n                state.cursor = end_pos3\n\n        if state.cursor < state.cursor_max:\n            text = state.src[state.cursor :]\n            state.add_paragraph(text)\n            state.cursor = state.cursor_max",
      "old_code": "class BlockParser(Parser[BlockState]):\n    state_cls = BlockState\n\n    BLANK_LINE = re.compile(r'(^[ \\t\\v\\f]*\\n)+', re.M)\n\n    RAW_HTML = (\n        r'^ {0,3}('\n        r'</?' + HTML_TAGNAME + r'|'\n        r'<!--|' # comment\n        r'<\\?|'  # script\n        r'<![A-Z]|'\n        r'<!\\[CDATA\\[)'\n    )\n\n    BLOCK_HTML = (\n        r'^ {0,3}(?:'\n        r'(?:</?' + _BLOCK_TAGS_PATTERN + r'(?:[ \\t]+|\\n|$))'\n        r'|<!--' # comment\n        r'|<\\?'  # script\n        r'|<![A-Z]'\n        r'|<!\\[CDATA\\[)'\n    )\n\n    SPECIFICATION = {\n        'blank_line': r'(^[ \\t\\v\\f]*\\n)+',\n        'atx_heading': r'^ {0,3}(?P<atx_1>#{1,6})(?!#+)(?P<atx_2>[ \\t]*|[ \\t]+.*?)$',\n        'setex_heading': r'^ {0,3}(?P<setext_1>=|-){1,}[ \\t]*$',\n        'fenced_code': (\n            r'^(?P<fenced_1> {0,3})(?P<fenced_2>`{3,}|~{3,})'\n            r'[ \\t]*(?P<fenced_3>.*?)$'\n        ),\n        'indent_code': (\n            r'^(?: {4}| *\\t)[^\\n]+(?:\\n+|$)'\n            r'((?:(?: {4}| *\\t)[^\\n]+(?:\\n+|$))|\\s)*'\n        ),\n        'thematic_break': r'^ {0,3}((?:-[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})$',\n        'ref_link': r'^ {0,3}\\[(?P<reflink_1>' + LINK_LABEL + r')\\]:',\n        'block_quote': r'^ {0,3}>(?P<quote_1>.*?)$',\n        'list': LIST_PATTERN,\n        'block_html': BLOCK_HTML,\n        'raw_html': RAW_HTML,\n    }\n\n    DEFAULT_RULES = (\n        'fenced_code',\n        'indent_code',\n        'atx_heading',\n        'setex_heading',\n        'thematic_break',\n        'block_quote',\n        'list',\n        'ref_link',\n        'raw_html',\n        'blank_line',\n    )\n\n    def __init__(\n            self,\n            block_quote_rules: Optional[List[str]]=None,\n            list_rules: Optional[List[str]]=None,\n            max_nested_level: int=6\n    ):\n        super(BlockParser, self).__init__()\n\n        if block_quote_rules is None:\n            block_quote_rules = list(self.DEFAULT_RULES)\n\n        if list_rules is None:\n            list_rules = list(self.DEFAULT_RULES)\n\n        self.block_quote_rules = block_quote_rules\n        self.list_rules = list_rules\n        self.max_nested_level = max_nested_level\n        # register default parse methods\n        self._methods = {\n            name: getattr(self, 'parse_' + name) for name in self.SPECIFICATION\n        }\n\n    def parse_blank_line(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for blank lines.\"\"\"\n        state.append_token({'type': 'blank_line'})\n        return m.end()\n\n    def parse_thematic_break(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for thematic break, e.g. ``<hr>`` tag in HTML.\"\"\"\n        state.append_token({'type': 'thematic_break'})\n        # $ does not count '\\n'\n        return m.end() + 1\n\n    def parse_indent_code(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for code block which is indented by 4 spaces.\"\"\"\n        # it is a part of the paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        code = m.group(0)\n        code = expand_leading_tab(code)\n        code = _INDENT_CODE_TRIM.sub('', code)\n        code = code.strip('\\n')\n        state.append_token({'type': 'block_code', 'raw': code, 'style': 'indent'})\n        return m.end()\n\n    def parse_fenced_code(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for fenced code block. A fenced code block is started with\n        3 or more backtick(`) or tilde(~).\n\n        An example of a fenced code block:\n\n        .. code-block:: markdown\n\n            ```python\n            def markdown(text):\n                return mistune.html(text)\n            ```\n        \"\"\"\n        spaces = m.group('fenced_1')\n        marker = m.group('fenced_2')\n        info = m.group('fenced_3')\n\n        c = marker[0]\n        if info and c == '`':\n            # CommonMark Example 145\n            # Info strings for backtick code blocks cannot contain backticks\n            if info.find(c) != -1:\n                return None\n\n        _end = re.compile(\n            r'^ {0,3}' + c + '{' + str(len(marker)) + r',}[ \\t]*(?:\\n|$)', re.M)\n        cursor_start = m.end() + 1\n\n        m2 = _end.search(state.src, cursor_start)\n        if m2:\n            code = state.src[cursor_start:m2.start()]\n            end_pos = m2.end()\n        else:\n            code = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        if spaces and code:\n            _trim_pattern = re.compile('^ {0,' + str(len(spaces)) + '}', re.M)\n            code = _trim_pattern.sub('', code)\n\n        token = {'type': 'block_code', 'raw': code, 'style': 'fenced', 'marker': marker}\n        if info:\n            info = unescape_char(info)\n            token['attrs'] = {'info': info.strip()}\n\n        state.append_token(token)\n        return end_pos\n\n    def parse_atx_heading(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for ATX heading. An ATX heading is started with 1 to 6\n        symbol of ``#``.\"\"\"\n        level = len(m.group('atx_1'))\n        text = m.group('atx_2').strip()\n        # remove last #\n        if text:\n            text = _ATX_HEADING_TRIM.sub('', text)\n\n        token = {'type': 'heading', 'text': text, 'attrs': {'level': level}, 'style': 'atx'}\n        state.append_token(token)\n        return m.end() + 1\n\n    def parse_setex_heading(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for setex style heading. A setex heading syntax looks like:\n\n        .. code-block:: markdown\n\n            H1 title\n            ========\n        \"\"\"\n        last_token = state.last_token()\n        if last_token and last_token['type'] == 'paragraph':\n            level = 1 if m.group('setext_1') == '=' else 2\n            last_token['type'] = 'heading'\n            last_token['style'] = 'setext'\n            last_token['attrs'] = {'level': level}\n            return m.end() + 1\n\n        sc = self.compile_sc(['thematic_break', 'list'])\n        m2 = sc.match(state.src, state.cursor)\n        if m2:\n            return self.parse_method(m2, state)\n        return None\n\n    def parse_ref_link(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse link references and save the link information into ``state.env``.\n\n        Here is an example of a link reference:\n\n        .. code-block:: markdown\n\n            a [link][example]\n\n            [example]: https://example.com \"Optional title\"\n\n        This method will save the link reference into ``state.env`` as::\n\n            state.env['ref_links']['example'] = {\n                'url': 'https://example.com',\n                'title': \"Optional title\",\n            }\n        \"\"\"\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        label = m.group('reflink_1')\n        key = unikey(label)\n        if not key:\n            return None\n\n        href, href_pos = parse_link_href(state.src, m.end(), block=True)\n        if href is None:\n            return None\n\n        assert href_pos is not None\n\n        _blank = self.BLANK_LINE.search(state.src, href_pos)\n        if _blank:\n            max_pos = _blank.start()\n        else:\n            max_pos = state.cursor_max\n\n        title, title_pos = parse_link_title(state.src, href_pos, max_pos)\n        if title_pos:\n            m2 = _BLANK_TO_LINE.match(state.src, title_pos)\n            if m2:\n                title_pos = m2.end()\n            else:\n                title_pos = None\n                title = None\n\n        if title_pos is None:\n            m3 = _BLANK_TO_LINE.match(state.src, href_pos)\n            if m3:\n                href_pos = m3.end()\n            else:\n                href_pos = None\n                href = None\n\n        end_pos = title_pos or href_pos\n        if not end_pos:\n            return None\n\n        if key not in state.env['ref_links']:\n            assert href is not None\n            href = unescape_char(href)\n            data = {'url': escape_url(href), 'label': label}\n            if title:\n                data['title'] = title\n            state.env['ref_links'][key] = data\n        return end_pos\n\n    def extract_block_quote(\n        self, m: Match[str], state: BlockState\n    ) -> Tuple[str, Optional[int]]:\n        \"\"\"Extract text and cursor end position of a block quote.\"\"\"\n\n        # cleanup at first to detect if it is code block\n        text = m.group('quote_1') + '\\n'\n        text = expand_leading_tab(text, 3)\n        text = _BLOCK_QUOTE_TRIM.sub('', text)\n\n        sc = self.compile_sc(['blank_line', 'indent_code', 'fenced_code'])\n        require_marker = bool(sc.match(text))\n\n        state.cursor = m.end() + 1\n\n        end_pos: Optional[int] = None\n        if require_marker:\n            m2 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n            if m2:\n                quote = m2.group(0)\n                quote = _BLOCK_QUOTE_LEADING.sub('', quote)\n                quote = expand_leading_tab(quote, 3)\n                quote = _BLOCK_QUOTE_TRIM.sub('', quote)\n                text += quote\n                state.cursor = m2.end()\n        else:\n            prev_blank_line = False\n            break_sc = self.compile_sc([\n                'blank_line', 'thematic_break', 'fenced_code',\n                'list', 'block_html',\n            ])\n            while state.cursor < state.cursor_max:\n                m3 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n                if m3:\n                    quote = m3.group(0)\n                    quote = _BLOCK_QUOTE_LEADING.sub('', quote)\n                    quote = expand_leading_tab(quote, 3)\n                    quote = _BLOCK_QUOTE_TRIM.sub('', quote)\n                    text += quote\n                    state.cursor = m3.end()\n                    if not quote.strip():\n                        prev_blank_line = True\n                    else:\n                        prev_blank_line = bool(_LINE_BLANK_END.search(quote))\n                    continue\n\n                if prev_blank_line:\n                    # CommonMark Example 249\n                    # because of laziness, a blank line is needed between\n                    # a block quote and a following paragraph\n                    break\n\n                m4 = break_sc.match(state.src, state.cursor)\n                if m4:\n                    end_pos = self.parse_method(m4, state)\n                    if end_pos:\n                        break\n\n                # lazy continuation line\n                pos = state.find_line_end()\n                line = state.get_text(pos)\n                line = expand_leading_tab(line, 3)\n                text += line\n                state.cursor = pos\n\n        # according to CommonMark Example 6, the second tab should be\n        # treated as 4 spaces\n        return expand_tab(text), end_pos\n\n    def parse_block_quote(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for block quote. Here is an example of the syntax:\n\n        .. code-block:: markdown\n\n            > a block quote starts\n            > with right arrows\n        \"\"\"\n        text, end_pos = self.extract_block_quote(m, state)\n        # scan children state\n        child = state.child_state(text)\n        if state.depth() >= self.max_nested_level - 1:\n            rules = list(self.block_quote_rules)\n            rules.remove('block_quote')\n        else:\n            rules = self.block_quote_rules\n\n        self.parse(child, rules)\n        token = {'type': 'block_quote', 'children': child.tokens}\n        if end_pos:\n            state.prepend_token(token)\n            return end_pos\n        state.append_token(token)\n        return state.cursor\n\n    def parse_list(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n        return parse_list(self, m, state)\n\n    def parse_block_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        return self.parse_raw_html(m, state)\n\n    def parse_raw_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        marker = m.group(0).strip()\n\n        # rule 2\n        if marker == '<!--':\n            return _parse_html_to_end(state, '-->', m.end())\n\n        # rule 3\n        if marker == '<?':\n            return _parse_html_to_end(state, '?>', m.end())\n\n        # rule 5\n        if marker == '<![CDATA[':\n            return _parse_html_to_end(state, ']]>', m.end())\n\n        # rule 4\n        if marker.startswith('<!'):\n            return _parse_html_to_end(state, '>', m.end())\n\n        close_tag = None\n        open_tag = None\n        if marker.startswith('</'):\n            close_tag = marker[2:].lower()\n            # rule 6\n            if close_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n        else:\n            open_tag = marker[1:].lower()\n            # rule 1\n            if open_tag in PRE_TAGS:\n                end_tag = '</' + open_tag + '>'\n                return _parse_html_to_end(state, end_tag, m.end())\n            # rule 6\n            if open_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        # Blocks of type 7 may not interrupt a paragraph.\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        # rule 7\n        start_pos = m.end()\n        end_pos = state.find_line_end()\n        if (open_tag and _OPEN_TAG_END.match(state.src, start_pos, end_pos)) or \\\n           (close_tag and _CLOSE_TAG_END.match(state.src, start_pos, end_pos)):\n            return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        return None\n\n    def parse(self, state: BlockState, rules: Optional[List[str]]=None) -> None:\n        sc = self.compile_sc(rules)\n\n        while state.cursor < state.cursor_max:\n            m = sc.search(state.src, state.cursor)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > state.cursor:\n                text = state.get_text(end_pos)\n                state.add_paragraph(text)\n                state.cursor = end_pos\n\n            end_pos2 = self.parse_method(m, state)\n            if end_pos2:\n                state.cursor = end_pos2\n            else:\n                end_pos3 = state.find_line_end()\n                text = state.get_text(end_pos3)\n                state.add_paragraph(text)\n                state.cursor = end_pos3\n\n        if state.cursor < state.cursor_max:\n            text = state.src[state.cursor:]\n            state.add_paragraph(text)\n            state.cursor = state.cursor_max"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 93,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.__init__",
      "span": [
        92,
        110
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(\n        self,\n        block_quote_rules: Optional[List[str]] = None,\n        list_rules: Optional[List[str]] = None,\n        max_nested_level: int = 6,\n    ):\n        super(BlockParser, self).__init__()\n\n        if block_quote_rules is None:\n            block_quote_rules = list(self.DEFAULT_RULES)\n\n        if list_rules is None:\n            list_rules = list(self.DEFAULT_RULES)\n\n        self.block_quote_rules = block_quote_rules\n        self.list_rules = list_rules\n        self.max_nested_level = max_nested_level\n        # register default parse methods\n        self._methods = {name: getattr(self, \"parse_\" + name) for name in self.SPECIFICATION}",
      "old_code": "    def __init__(\n            self,\n            block_quote_rules: Optional[List[str]]=None,\n            list_rules: Optional[List[str]]=None,\n            max_nested_level: int=6\n    ):\n        super(BlockParser, self).__init__()\n\n        if block_quote_rules is None:\n            block_quote_rules = list(self.DEFAULT_RULES)\n\n        if list_rules is None:\n            list_rules = list(self.DEFAULT_RULES)\n\n        self.block_quote_rules = block_quote_rules\n        self.list_rules = list_rules\n        self.max_nested_level = max_nested_level\n        # register default parse methods\n        self._methods = {\n            name: getattr(self, 'parse_' + name) for name in self.SPECIFICATION\n        }"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 114,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_blank_line",
      "span": [
        112,
        115
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_blank_line(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for blank lines.\"\"\"\n        state.append_token({\"type\": \"blank_line\"})\n        return m.end()",
      "old_code": "    def parse_blank_line(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for blank lines.\"\"\"\n        state.append_token({'type': 'blank_line'})\n        return m.end()"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 119,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_thematic_break",
      "span": [
        117,
        121
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_thematic_break(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for thematic break, e.g. ``<hr>`` tag in HTML.\"\"\"\n        state.append_token({\"type\": \"thematic_break\"})\n        # $ does not count '\\n'\n        return m.end() + 1",
      "old_code": "    def parse_thematic_break(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for thematic break, e.g. ``<hr>`` tag in HTML.\"\"\"\n        state.append_token({'type': 'thematic_break'})\n        # $ does not count '\\n'\n        return m.end() + 1"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 132,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_indent_code",
      "span": [
        123,
        135
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_indent_code(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for code block which is indented by 4 spaces.\"\"\"\n        # it is a part of the paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        code = m.group(0)\n        code = expand_leading_tab(code)\n        code = _INDENT_CODE_TRIM.sub(\"\", code)\n        code = code.strip(\"\\n\")\n        state.append_token({\"type\": \"block_code\", \"raw\": code, \"style\": \"indent\"})\n        return m.end()",
      "old_code": "    def parse_indent_code(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for code block which is indented by 4 spaces.\"\"\"\n        # it is a part of the paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        code = m.group(0)\n        code = expand_leading_tab(code)\n        code = _INDENT_CODE_TRIM.sub('', code)\n        code = code.strip('\\n')\n        state.append_token({'type': 'block_code', 'raw': code, 'style': 'indent'})\n        return m.end()"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 150,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_fenced_code",
      "span": [
        137,
        182
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_fenced_code(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for fenced code block. A fenced code block is started with\n        3 or more backtick(`) or tilde(~).\n\n        An example of a fenced code block:\n\n        .. code-block:: markdown\n\n            ```python\n            def markdown(text):\n                return mistune.html(text)\n            ```\n        \"\"\"\n        spaces = m.group(\"fenced_1\")\n        marker = m.group(\"fenced_2\")\n        info = m.group(\"fenced_3\")\n\n        c = marker[0]\n        if info and c == \"`\":\n            # CommonMark Example 145\n            # Info strings for backtick code blocks cannot contain backticks\n            if info.find(c) != -1:\n                return None\n\n        _end = re.compile(r\"^ {0,3}\" + c + \"{\" + str(len(marker)) + r\",}[ \\t]*(?:\\n|$)\", re.M)\n        cursor_start = m.end() + 1\n\n        m2 = _end.search(state.src, cursor_start)\n        if m2:\n            code = state.src[cursor_start : m2.start()]\n            end_pos = m2.end()\n        else:\n            code = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        if spaces and code:\n            _trim_pattern = re.compile(\"^ {0,\" + str(len(spaces)) + \"}\", re.M)\n            code = _trim_pattern.sub(\"\", code)\n\n        token = {\"type\": \"block_code\", \"raw\": code, \"style\": \"fenced\", \"marker\": marker}\n        if info:\n            info = unescape_char(info)\n            token[\"attrs\"] = {\"info\": info.strip()}\n\n        state.append_token(token)\n        return end_pos",
      "old_code": "    def parse_fenced_code(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for fenced code block. A fenced code block is started with\n        3 or more backtick(`) or tilde(~).\n\n        An example of a fenced code block:\n\n        .. code-block:: markdown\n\n            ```python\n            def markdown(text):\n                return mistune.html(text)\n            ```\n        \"\"\"\n        spaces = m.group('fenced_1')\n        marker = m.group('fenced_2')\n        info = m.group('fenced_3')\n\n        c = marker[0]\n        if info and c == '`':\n            # CommonMark Example 145\n            # Info strings for backtick code blocks cannot contain backticks\n            if info.find(c) != -1:\n                return None\n\n        _end = re.compile(\n            r'^ {0,3}' + c + '{' + str(len(marker)) + r',}[ \\t]*(?:\\n|$)', re.M)\n        cursor_start = m.end() + 1\n\n        m2 = _end.search(state.src, cursor_start)\n        if m2:\n            code = state.src[cursor_start:m2.start()]\n            end_pos = m2.end()\n        else:\n            code = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        if spaces and code:\n            _trim_pattern = re.compile('^ {0,' + str(len(spaces)) + '}', re.M)\n            code = _trim_pattern.sub('', code)\n\n        token = {'type': 'block_code', 'raw': code, 'style': 'fenced', 'marker': marker}\n        if info:\n            info = unescape_char(info)\n            token['attrs'] = {'info': info.strip()}\n\n        state.append_token(token)\n        return end_pos"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 187,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_atx_heading",
      "span": [
        184,
        195
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_atx_heading(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for ATX heading. An ATX heading is started with 1 to 6\n        symbol of ``#``.\"\"\"\n        level = len(m.group(\"atx_1\"))\n        text = m.group(\"atx_2\").strip()\n        # remove last #\n        if text:\n            text = _ATX_HEADING_TRIM.sub(\"\", text)\n\n        token = {\"type\": \"heading\", \"text\": text, \"attrs\": {\"level\": level}, \"style\": \"atx\"}\n        state.append_token(token)\n        return m.end() + 1",
      "old_code": "    def parse_atx_heading(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for ATX heading. An ATX heading is started with 1 to 6\n        symbol of ``#``.\"\"\"\n        level = len(m.group('atx_1'))\n        text = m.group('atx_2').strip()\n        # remove last #\n        if text:\n            text = _ATX_HEADING_TRIM.sub('', text)\n\n        token = {'type': 'heading', 'text': text, 'attrs': {'level': level}, 'style': 'atx'}\n        state.append_token(token)\n        return m.end() + 1"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 206,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_setex_heading",
      "span": [
        197,
        217
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_setex_heading(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for setex style heading. A setex heading syntax looks like:\n\n        .. code-block:: markdown\n\n            H1 title\n            ========\n        \"\"\"\n        last_token = state.last_token()\n        if last_token and last_token[\"type\"] == \"paragraph\":\n            level = 1 if m.group(\"setext_1\") == \"=\" else 2\n            last_token[\"type\"] = \"heading\"\n            last_token[\"style\"] = \"setext\"\n            last_token[\"attrs\"] = {\"level\": level}\n            return m.end() + 1\n\n        sc = self.compile_sc([\"thematic_break\", \"list\"])\n        m2 = sc.match(state.src, state.cursor)\n        if m2:\n            return self.parse_method(m2, state)\n        return None",
      "old_code": "    def parse_setex_heading(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse token for setex style heading. A setex heading syntax looks like:\n\n        .. code-block:: markdown\n\n            H1 title\n            ========\n        \"\"\"\n        last_token = state.last_token()\n        if last_token and last_token['type'] == 'paragraph':\n            level = 1 if m.group('setext_1') == '=' else 2\n            last_token['type'] = 'heading'\n            last_token['style'] = 'setext'\n            last_token['attrs'] = {'level': level}\n            return m.end() + 1\n\n        sc = self.compile_sc(['thematic_break', 'list'])\n        m2 = sc.match(state.src, state.cursor)\n        if m2:\n            return self.parse_method(m2, state)\n        return None"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 241,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_ref_link",
      "span": [
        219,
        286
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_ref_link(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse link references and save the link information into ``state.env``.\n\n        Here is an example of a link reference:\n\n        .. code-block:: markdown\n\n            a [link][example]\n\n            [example]: https://example.com \"Optional title\"\n\n        This method will save the link reference into ``state.env`` as::\n\n            state.env['ref_links']['example'] = {\n                'url': 'https://example.com',\n                'title': \"Optional title\",\n            }\n        \"\"\"\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        label = m.group(\"reflink_1\")\n        key = unikey(label)\n        if not key:\n            return None\n\n        href, href_pos = parse_link_href(state.src, m.end(), block=True)\n        if href is None:\n            return None\n\n        assert href_pos is not None\n\n        _blank = self.BLANK_LINE.search(state.src, href_pos)\n        if _blank:\n            max_pos = _blank.start()\n        else:\n            max_pos = state.cursor_max\n\n        title, title_pos = parse_link_title(state.src, href_pos, max_pos)\n        if title_pos:\n            m2 = _BLANK_TO_LINE.match(state.src, title_pos)\n            if m2:\n                title_pos = m2.end()\n            else:\n                title_pos = None\n                title = None\n\n        if title_pos is None:\n            m3 = _BLANK_TO_LINE.match(state.src, href_pos)\n            if m3:\n                href_pos = m3.end()\n            else:\n                href_pos = None\n                href = None\n\n        end_pos = title_pos or href_pos\n        if not end_pos:\n            return None\n\n        if key not in state.env[\"ref_links\"]:\n            assert href is not None\n            href = unescape_char(href)\n            data = {\"url\": escape_url(href), \"label\": label}\n            if title:\n                data[\"title\"] = title\n            state.env[\"ref_links\"][key] = data\n        return end_pos",
      "old_code": "    def parse_ref_link(self, m: Match[str], state: BlockState) -> Optional[int]:\n        \"\"\"Parse link references and save the link information into ``state.env``.\n\n        Here is an example of a link reference:\n\n        .. code-block:: markdown\n\n            a [link][example]\n\n            [example]: https://example.com \"Optional title\"\n\n        This method will save the link reference into ``state.env`` as::\n\n            state.env['ref_links']['example'] = {\n                'url': 'https://example.com',\n                'title': \"Optional title\",\n            }\n        \"\"\"\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        label = m.group('reflink_1')\n        key = unikey(label)\n        if not key:\n            return None\n\n        href, href_pos = parse_link_href(state.src, m.end(), block=True)\n        if href is None:\n            return None\n\n        assert href_pos is not None\n\n        _blank = self.BLANK_LINE.search(state.src, href_pos)\n        if _blank:\n            max_pos = _blank.start()\n        else:\n            max_pos = state.cursor_max\n\n        title, title_pos = parse_link_title(state.src, href_pos, max_pos)\n        if title_pos:\n            m2 = _BLANK_TO_LINE.match(state.src, title_pos)\n            if m2:\n                title_pos = m2.end()\n            else:\n                title_pos = None\n                title = None\n\n        if title_pos is None:\n            m3 = _BLANK_TO_LINE.match(state.src, href_pos)\n            if m3:\n                href_pos = m3.end()\n            else:\n                href_pos = None\n                href = None\n\n        end_pos = title_pos or href_pos\n        if not end_pos:\n            return None\n\n        if key not in state.env['ref_links']:\n            assert href is not None\n            href = unescape_char(href)\n            data = {'url': escape_url(href), 'label': label}\n            if title:\n                data['title'] = title\n            state.env['ref_links'][key] = data\n        return end_pos"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 288,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.extract_block_quote",
      "span": [
        288,
        358
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def extract_block_quote(self, m: Match[str], state: BlockState) -> Tuple[str, Optional[int]]:\n        \"\"\"Extract text and cursor end position of a block quote.\"\"\"\n\n        # cleanup at first to detect if it is code block\n        text = m.group(\"quote_1\") + \"\\n\"\n        text = expand_leading_tab(text, 3)\n        text = _BLOCK_QUOTE_TRIM.sub(\"\", text)\n\n        sc = self.compile_sc([\"blank_line\", \"indent_code\", \"fenced_code\"])\n        require_marker = bool(sc.match(text))\n\n        state.cursor = m.end() + 1\n\n        end_pos: Optional[int] = None\n        if require_marker:\n            m2 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n            if m2:\n                quote = m2.group(0)\n                quote = _BLOCK_QUOTE_LEADING.sub(\"\", quote)\n                quote = expand_leading_tab(quote, 3)\n                quote = _BLOCK_QUOTE_TRIM.sub(\"\", quote)\n                text += quote\n                state.cursor = m2.end()\n        else:\n            prev_blank_line = False\n            break_sc = self.compile_sc(\n                [\n                    \"blank_line\",\n                    \"thematic_break\",\n                    \"fenced_code\",\n                    \"list\",\n                    \"block_html\",\n                ]\n            )\n            while state.cursor < state.cursor_max:\n                m3 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n                if m3:\n                    quote = m3.group(0)\n                    quote = _BLOCK_QUOTE_LEADING.sub(\"\", quote)\n                    quote = expand_leading_tab(quote, 3)\n                    quote = _BLOCK_QUOTE_TRIM.sub(\"\", quote)\n                    text += quote\n                    state.cursor = m3.end()\n                    if not quote.strip():\n                        prev_blank_line = True\n                    else:\n                        prev_blank_line = bool(_LINE_BLANK_END.search(quote))\n                    continue\n\n                if prev_blank_line:\n                    # CommonMark Example 249\n                    # because of laziness, a blank line is needed between\n                    # a block quote and a following paragraph\n                    break\n\n                m4 = break_sc.match(state.src, state.cursor)\n                if m4:\n                    end_pos = self.parse_method(m4, state)\n                    if end_pos:\n                        break\n\n                # lazy continuation line\n                pos = state.find_line_end()\n                line = state.get_text(pos)\n                line = expand_leading_tab(line, 3)\n                text += line\n                state.cursor = pos\n\n        # according to CommonMark Example 6, the second tab should be\n        # treated as 4 spaces\n        return expand_tab(text), end_pos",
      "old_code": "    def extract_block_quote(\n        self, m: Match[str], state: BlockState\n    ) -> Tuple[str, Optional[int]]:\n        \"\"\"Extract text and cursor end position of a block quote.\"\"\"\n\n        # cleanup at first to detect if it is code block\n        text = m.group('quote_1') + '\\n'\n        text = expand_leading_tab(text, 3)\n        text = _BLOCK_QUOTE_TRIM.sub('', text)\n\n        sc = self.compile_sc(['blank_line', 'indent_code', 'fenced_code'])\n        require_marker = bool(sc.match(text))\n\n        state.cursor = m.end() + 1\n\n        end_pos: Optional[int] = None\n        if require_marker:\n            m2 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n            if m2:\n                quote = m2.group(0)\n                quote = _BLOCK_QUOTE_LEADING.sub('', quote)\n                quote = expand_leading_tab(quote, 3)\n                quote = _BLOCK_QUOTE_TRIM.sub('', quote)\n                text += quote\n                state.cursor = m2.end()\n        else:\n            prev_blank_line = False\n            break_sc = self.compile_sc([\n                'blank_line', 'thematic_break', 'fenced_code',\n                'list', 'block_html',\n            ])\n            while state.cursor < state.cursor_max:\n                m3 = _STRICT_BLOCK_QUOTE.match(state.src, state.cursor)\n                if m3:\n                    quote = m3.group(0)\n                    quote = _BLOCK_QUOTE_LEADING.sub('', quote)\n                    quote = expand_leading_tab(quote, 3)\n                    quote = _BLOCK_QUOTE_TRIM.sub('', quote)\n                    text += quote\n                    state.cursor = m3.end()\n                    if not quote.strip():\n                        prev_blank_line = True\n                    else:\n                        prev_blank_line = bool(_LINE_BLANK_END.search(quote))\n                    continue\n\n                if prev_blank_line:\n                    # CommonMark Example 249\n                    # because of laziness, a blank line is needed between\n                    # a block quote and a following paragraph\n                    break\n\n                m4 = break_sc.match(state.src, state.cursor)\n                if m4:\n                    end_pos = self.parse_method(m4, state)\n                    if end_pos:\n                        break\n\n                # lazy continuation line\n                pos = state.find_line_end()\n                line = state.get_text(pos)\n                line = expand_leading_tab(line, 3)\n                text += line\n                state.cursor = pos\n\n        # according to CommonMark Example 6, the second tab should be\n        # treated as 4 spaces\n        return expand_tab(text), end_pos"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 373,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_block_quote",
      "span": [
        360,
        383
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_block_quote(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for block quote. Here is an example of the syntax:\n\n        .. code-block:: markdown\n\n            > a block quote starts\n            > with right arrows\n        \"\"\"\n        text, end_pos = self.extract_block_quote(m, state)\n        # scan children state\n        child = state.child_state(text)\n        if state.depth() >= self.max_nested_level - 1:\n            rules = list(self.block_quote_rules)\n            rules.remove(\"block_quote\")\n        else:\n            rules = self.block_quote_rules\n\n        self.parse(child, rules)\n        token = {\"type\": \"block_quote\", \"children\": child.tokens}\n        if end_pos:\n            state.prepend_token(token)\n            return end_pos\n        state.append_token(token)\n        return state.cursor",
      "old_code": "    def parse_block_quote(self, m: Match[str], state: BlockState) -> int:\n        \"\"\"Parse token for block quote. Here is an example of the syntax:\n\n        .. code-block:: markdown\n\n            > a block quote starts\n            > with right arrows\n        \"\"\"\n        text, end_pos = self.extract_block_quote(m, state)\n        # scan children state\n        child = state.child_state(text)\n        if state.depth() >= self.max_nested_level - 1:\n            rules = list(self.block_quote_rules)\n            rules.remove('block_quote')\n        else:\n            rules = self.block_quote_rules\n\n        self.parse(child, rules)\n        token = {'type': 'block_quote', 'children': child.tokens}\n        if end_pos:\n            state.prepend_token(token)\n            return end_pos\n        state.append_token(token)\n        return state.cursor"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 396,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse_raw_html",
      "span": [
        392,
        441
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_raw_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        marker = m.group(0).strip()\n\n        # rule 2\n        if marker == \"<!--\":\n            return _parse_html_to_end(state, \"-->\", m.end())\n\n        # rule 3\n        if marker == \"<?\":\n            return _parse_html_to_end(state, \"?>\", m.end())\n\n        # rule 5\n        if marker == \"<![CDATA[\":\n            return _parse_html_to_end(state, \"]]>\", m.end())\n\n        # rule 4\n        if marker.startswith(\"<!\"):\n            return _parse_html_to_end(state, \">\", m.end())\n\n        close_tag = None\n        open_tag = None\n        if marker.startswith(\"</\"):\n            close_tag = marker[2:].lower()\n            # rule 6\n            if close_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n        else:\n            open_tag = marker[1:].lower()\n            # rule 1\n            if open_tag in PRE_TAGS:\n                end_tag = \"</\" + open_tag + \">\"\n                return _parse_html_to_end(state, end_tag, m.end())\n            # rule 6\n            if open_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        # Blocks of type 7 may not interrupt a paragraph.\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        # rule 7\n        start_pos = m.end()\n        end_pos = state.find_line_end()\n        if (open_tag and _OPEN_TAG_END.match(state.src, start_pos, end_pos)) or (\n            close_tag and _CLOSE_TAG_END.match(state.src, start_pos, end_pos)\n        ):\n            return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        return None",
      "old_code": "    def parse_raw_html(self, m: Match[str], state: BlockState) -> Optional[int]:\n        marker = m.group(0).strip()\n\n        # rule 2\n        if marker == '<!--':\n            return _parse_html_to_end(state, '-->', m.end())\n\n        # rule 3\n        if marker == '<?':\n            return _parse_html_to_end(state, '?>', m.end())\n\n        # rule 5\n        if marker == '<![CDATA[':\n            return _parse_html_to_end(state, ']]>', m.end())\n\n        # rule 4\n        if marker.startswith('<!'):\n            return _parse_html_to_end(state, '>', m.end())\n\n        close_tag = None\n        open_tag = None\n        if marker.startswith('</'):\n            close_tag = marker[2:].lower()\n            # rule 6\n            if close_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n        else:\n            open_tag = marker[1:].lower()\n            # rule 1\n            if open_tag in PRE_TAGS:\n                end_tag = '</' + open_tag + '>'\n                return _parse_html_to_end(state, end_tag, m.end())\n            # rule 6\n            if open_tag in BLOCK_TAGS:\n                return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        # Blocks of type 7 may not interrupt a paragraph.\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n        # rule 7\n        start_pos = m.end()\n        end_pos = state.find_line_end()\n        if (open_tag and _OPEN_TAG_END.match(state.src, start_pos, end_pos)) or \\\n           (close_tag and _CLOSE_TAG_END.match(state.src, start_pos, end_pos)):\n            return _parse_html_to_newline(state, self.BLANK_LINE)\n\n        return None"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 443,
      "kind": "function",
      "qualname": "src.mistune.block_parser.BlockParser.parse",
      "span": [
        443,
        469
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, state: BlockState, rules: Optional[List[str]] = None) -> None:\n        sc = self.compile_sc(rules)\n\n        while state.cursor < state.cursor_max:\n            m = sc.search(state.src, state.cursor)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > state.cursor:\n                text = state.get_text(end_pos)\n                state.add_paragraph(text)\n                state.cursor = end_pos\n\n            end_pos2 = self.parse_method(m, state)\n            if end_pos2:\n                state.cursor = end_pos2\n            else:\n                end_pos3 = state.find_line_end()\n                text = state.get_text(end_pos3)\n                state.add_paragraph(text)\n                state.cursor = end_pos3\n\n        if state.cursor < state.cursor_max:\n            text = state.src[state.cursor :]\n            state.add_paragraph(text)\n            state.cursor = state.cursor_max",
      "old_code": "    def parse(self, state: BlockState, rules: Optional[List[str]]=None) -> None:\n        sc = self.compile_sc(rules)\n\n        while state.cursor < state.cursor_max:\n            m = sc.search(state.src, state.cursor)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > state.cursor:\n                text = state.get_text(end_pos)\n                state.add_paragraph(text)\n                state.cursor = end_pos\n\n            end_pos2 = self.parse_method(m, state)\n            if end_pos2:\n                state.cursor = end_pos2\n            else:\n                end_pos3 = state.find_line_end()\n                text = state.get_text(end_pos3)\n                state.add_paragraph(text)\n                state.cursor = end_pos3\n\n        if state.cursor < state.cursor_max:\n            text = state.src[state.cursor:]\n            state.add_paragraph(text)\n            state.cursor = state.cursor_max"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 475,
      "kind": "function",
      "qualname": "src.mistune.block_parser._parse_html_to_end",
      "span": [
        472,
        484
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_html_to_end(state: BlockState, end_marker: str, start_pos: int) -> int:\n    marker_pos = state.src.find(end_marker, start_pos)\n    if marker_pos == -1:\n        text = state.src[state.cursor :]\n        end_pos = state.cursor_max\n    else:\n        text = state.get_text(marker_pos)\n        state.cursor = marker_pos\n        end_pos = state.find_line_end()\n        text += state.get_text(end_pos)\n\n    state.append_token({\"type\": \"block_html\", \"raw\": text})\n    return end_pos",
      "old_code": "def _parse_html_to_end(state: BlockState, end_marker: str, start_pos: int) -> int:\n    marker_pos = state.src.find(end_marker, start_pos)\n    if marker_pos == -1:\n        text = state.src[state.cursor:]\n        end_pos = state.cursor_max\n    else:\n        text = state.get_text(marker_pos)\n        state.cursor = marker_pos\n        end_pos = state.find_line_end()\n        text += state.get_text(end_pos)\n\n    state.append_token({'type': 'block_html', 'raw': text})\n    return end_pos"
    },
    {
      "path": "src/mistune/block_parser.py",
      "version": "new",
      "line": 493,
      "kind": "function",
      "qualname": "src.mistune.block_parser._parse_html_to_newline",
      "span": [
        487,
        497
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_html_to_newline(state: BlockState, newline: Pattern[str]) -> int:\n    m = newline.search(state.src, state.cursor)\n    if m:\n        end_pos = m.start()\n        text = state.get_text(end_pos)\n    else:\n        text = state.src[state.cursor :]\n        end_pos = state.cursor_max\n\n    state.append_token({\"type\": \"block_html\", \"raw\": text})\n    return end_pos",
      "old_code": "def _parse_html_to_newline(state: BlockState, newline: Pattern[str]) -> int:\n    m = newline.search(state.src, state.cursor)\n    if m:\n        end_pos = m.start()\n        text = state.get_text(end_pos)\n    else:\n        text = state.src[state.cursor:]\n        end_pos = state.cursor_max\n\n    state.append_token({'type': 'block_html', 'raw': text})\n    return end_pos"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 20,
      "kind": "module",
      "qualname": "src.mistune.core",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "src.mistune.core.BlockState.__init__",
      "span": [
        40,
        56
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, parent: Optional[Any] = None) -> None:\n        self.src = \"\"\n        self.tokens = []\n\n        # current cursor position\n        self.cursor = 0\n        self.cursor_max = 0\n\n        # for list and block quote chain\n        self.list_tight = True\n        self.parent = parent\n\n        # for saving def references\n        if parent:\n            self.env = parent.env\n        else:\n            self.env = {\"ref_links\": {}}",
      "old_code": "    def __init__(self, parent: Optional[Any] = None) -> None:\n        self.src = ''\n        self.tokens = []\n\n        # current cursor position\n        self.cursor = 0\n        self.cursor_max = 0\n\n        # for list and block quote chain\n        self.list_tight = True\n        self.parent = parent\n\n        # for saving def references\n        if parent:\n            self.env = parent.env\n        else:\n            self.env = {'ref_links': {}}"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 58,
      "kind": "function",
      "qualname": "src.mistune.core.BlockState.child_state",
      "span": [
        58,
        61
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def child_state(self, src: str) -> \"BlockState\":\n        child = self.__class__(self)\n        child.process(src)\n        return child",
      "old_code": "    def child_state(self, src: str) -> 'BlockState':\n        child = self.__class__(self)\n        child.process(src)\n        return child"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 73,
      "kind": "function",
      "qualname": "src.mistune.core.BlockState.get_text",
      "span": [
        72,
        73
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def get_text(self, end_pos: int) -> str:\n        return self.src[self.cursor : end_pos]",
      "old_code": "    def get_text(self, end_pos: int) -> str:\n        return self.src[self.cursor:end_pos]"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 89,
      "kind": "function",
      "qualname": "src.mistune.core.BlockState.add_paragraph",
      "span": [
        87,
        92
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def add_paragraph(self, text: str) -> None:\n        last_token = self.last_token()\n        if last_token and last_token[\"type\"] == \"paragraph\":\n            last_token[\"text\"] += text\n        else:\n            self.tokens.append({\"type\": \"paragraph\", \"text\": text})",
      "old_code": "    def add_paragraph(self, text: str) -> None:\n        last_token = self.last_token()\n        if last_token and last_token['type'] == 'paragraph':\n            last_token['text'] += text\n        else:\n            self.tokens.append({'type': 'paragraph', 'text': text})"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 96,
      "kind": "function",
      "qualname": "src.mistune.core.BlockState.append_paragraph",
      "span": [
        94,
        100
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def append_paragraph(self) -> Optional[int]:\n        last_token = self.last_token()\n        if last_token and last_token[\"type\"] == \"paragraph\":\n            pos = self.find_line_end()\n            last_token[\"text\"] += self.get_text(pos)\n            return pos\n        return None",
      "old_code": "    def append_paragraph(self) -> Optional[int]:\n        last_token = self.last_token()\n        if last_token and last_token['type'] == 'paragraph':\n            pos = self.find_line_end()\n            last_token['text'] += self.get_text(pos)\n            return pos\n        return None"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 116,
      "kind": "function",
      "qualname": "src.mistune.core.InlineState.__init__",
      "span": [
        114,
        121
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, env: MutableMapping[str, Any]):\n        self.env = env\n        self.src = \"\"\n        self.tokens: List[Dict[str, Any]] = []\n        self.in_image = False\n        self.in_link = False\n        self.in_emphasis = False\n        self.in_strong = False",
      "old_code": "    def __init__(self, env: MutableMapping[str, Any]):\n        self.env = env\n        self.src = ''\n        self.tokens: List[Dict[str, Any]] = []\n        self.in_image = False\n        self.in_link = False\n        self.in_emphasis = False\n        self.in_strong = False"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 163,
      "kind": "function",
      "qualname": "src.mistune.core.Parser.compile_sc",
      "span": [
        161,
        175
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def compile_sc(self, rules: Optional[List[str]] = None) -> Pattern[str]:\n        if rules is None:\n            key = \"$\"\n            rules = self.rules\n        else:\n            key = \"|\".join(rules)\n\n        sc = self.__sc.get(key)\n        if sc:\n            return sc\n\n        regex = \"|\".join(r\"(?P<%s>%s)\" % (k, self.specification[k]) for k in rules)\n        sc = re.compile(regex, self.sc_flag)\n        self.__sc[key] = sc\n        return sc",
      "old_code": "    def compile_sc(self, rules: Optional[List[str]] = None) -> Pattern[str]:\n        if rules is None:\n            key = '$'\n            rules = self.rules\n        else:\n            key = '|'.join(rules)\n\n        sc = self.__sc.get(key)\n        if sc:\n            return sc\n\n        regex = '|'.join(r'(?P<%s>%s)' % (k, self.specification[k]) for k in rules)\n        sc = re.compile(regex, self.sc_flag)\n        self.__sc[key] = sc\n        return sc"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 199,
      "kind": "function",
      "qualname": "src.mistune.core.Parser.register_rule",
      "span": [
        198,
        199
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def register_rule(self, name: str, pattern: str, func: Any) -> None:\n        raise DeprecationWarning(\"This plugin is not compatible with mistune v3.\")",
      "old_code": "    def register_rule(self, name: str, pattern: str, func: Any) -> None:\n        raise DeprecationWarning('This plugin is not compatible with mistune v3.')"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 228,
      "kind": "function",
      "qualname": "src.mistune.core.BaseRenderer.register",
      "span": [
        225,
        234
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def register(self, name: str, method: Callable[..., str]) -> None:\n        \"\"\"Register a render method for the named token. For example::\n\n        def render_wiki(renderer, key, title):\n            return f'<a href=\"/wiki/{key}\">{title}</a>'\n\n        renderer.register('wiki', render_wiki)\n        \"\"\"\n        # bind self into renderer method\n        self.__methods[name] = lambda *arg, **kwargs: method(self, *arg, **kwargs)",
      "old_code": "    def register(self, name: str, method: Callable[..., str]) -> None:\n        \"\"\"Register a render method for the named token. For example::\n\n            def render_wiki(renderer, key, title):\n                return f'<a href=\"/wiki/{key}\">{title}</a>'\n\n            renderer.register('wiki', render_wiki)\n        \"\"\"\n        # bind self into renderer method\n        self.__methods[name] = lambda *arg, **kwargs: method(self, *arg, **kwargs)"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 246,
      "kind": "function",
      "qualname": "src.mistune.core.BaseRenderer.render_token",
      "span": [
        245,
        247
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        func = self._get_method(token[\"type\"])\n        return func(token, state)",
      "old_code": "    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        func = self._get_method(token['type'])\n        return func(token, state)"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 249,
      "kind": "function",
      "qualname": "src.mistune.core.BaseRenderer.iter_tokens",
      "span": [
        249,
        251
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def iter_tokens(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> Iterable[str]:\n        for tok in tokens:\n            yield self.render_token(tok, state)",
      "old_code": "    def iter_tokens(\n        self, tokens: Iterable[Dict[str, Any]], state: BlockState\n    ) -> Iterable[str]:\n        for tok in tokens:\n            yield self.render_token(tok, state)"
    },
    {
      "path": "src/mistune/core.py",
      "version": "new",
      "line": 254,
      "kind": "function",
      "qualname": "src.mistune.core.BaseRenderer.render_tokens",
      "span": [
        253,
        254
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_tokens(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        return \"\".join(self.iter_tokens(tokens, state))",
      "old_code": "    def render_tokens(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        return ''.join(self.iter_tokens(tokens, state))"
    },
    {
      "path": "src/mistune/directives/__init__.py",
      "version": "new",
      "line": 16,
      "kind": "function",
      "qualname": "src.mistune.directives.__init__.RstDirective.__init__",
      "span": [
        13,
        21
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, plugins: List[DirectivePlugin]) -> None:\n        super(RstDirective, self).__init__(plugins)\n        import warnings\n\n        warnings.warn(\n            \"'RstDirective' is deprecated, please use 'RSTDirective' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )",
      "old_code": "    def __init__(self, plugins: List[DirectivePlugin]) -> None:\n        super(RstDirective, self).__init__(plugins)\n        import warnings\n        warnings.warn(\n            \"'RstDirective' is deprecated, please use 'RSTDirective' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )"
    },
    {
      "path": "src/mistune/directives/__init__.py",
      "version": "new",
      "line": 25,
      "kind": "module",
      "qualname": "src.mistune.directives.__init__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 24,
      "kind": "class",
      "qualname": "src.mistune.directives._base.DirectiveParser",
      "span": [
        23,
        67
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class DirectiveParser(ABCMeta):\n    name = \"directive\"\n\n    @staticmethod\n    @abstractmethod\n    def parse_type(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def parse_title(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def parse_content(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @classmethod\n    def parse_tokens(cls, block: \"BlockParser\", text: str, state: \"BlockState\") -> Iterable[Dict[str, Any]]:\n        if state.depth() >= block.max_nested_level - 1 and cls.name in block.rules:\n            rules = list(block.rules)\n            rules.remove(cls.name)\n        else:\n            rules = block.rules\n        child = state.child_state(text)\n        block.parse(child, rules)\n        return child.tokens\n\n    @staticmethod\n    def parse_options(m: Match[str]) -> List[Tuple[str, str]]:\n        text = m.group(\"options\")\n        if not text.strip():\n            return []\n\n        options = []\n        for line in re.split(r\"\\n+\", text):\n            line = line.strip()[1:]\n            if not line:\n                continue\n            i = line.find(\":\")\n            k = line[:i]\n            v = line[i + 1 :].strip()\n            options.append((k, v))\n        return options",
      "old_code": "class DirectiveParser(ABCMeta):\n    name = 'directive'\n\n    @staticmethod\n    @abstractmethod\n    def parse_type(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def parse_title(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def parse_content(m: Match[str]) -> str:\n        raise NotImplementedError()\n\n    @classmethod\n    def parse_tokens(\n        cls, block: \"BlockParser\", text: str, state: \"BlockState\"\n    ) -> Iterable[Dict[str, Any]]:\n        if state.depth() >= block.max_nested_level - 1 and cls.name in block.rules:\n            rules = list(block.rules)\n            rules.remove(cls.name)\n        else:\n            rules = block.rules\n        child = state.child_state(text)\n        block.parse(child, rules)\n        return child.tokens\n\n    @staticmethod\n    def parse_options(m: Match[str]) -> List[Tuple[str, str]]:\n        text = m.group('options')\n        if not text.strip():\n            return []\n\n        options = []\n        for line in re.split(r'\\n+', text):\n            line = line.strip()[1:]\n            if not line:\n                continue\n            i = line.find(':')\n            k = line[:i]\n            v = line[i + 1:].strip()\n            options.append((k, v))\n        return options"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 42,
      "kind": "function",
      "qualname": "src.mistune.directives._base.DirectiveParser.parse_tokens",
      "span": [
        42,
        50
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_tokens(cls, block: \"BlockParser\", text: str, state: \"BlockState\") -> Iterable[Dict[str, Any]]:\n        if state.depth() >= block.max_nested_level - 1 and cls.name in block.rules:\n            rules = list(block.rules)\n            rules.remove(cls.name)\n        else:\n            rules = block.rules\n        child = state.child_state(text)\n        block.parse(child, rules)\n        return child.tokens",
      "old_code": "    def parse_tokens(\n        cls, block: \"BlockParser\", text: str, state: \"BlockState\"\n    ) -> Iterable[Dict[str, Any]]:\n        if state.depth() >= block.max_nested_level - 1 and cls.name in block.rules:\n            rules = list(block.rules)\n            rules.remove(cls.name)\n        else:\n            rules = block.rules\n        child = state.child_state(text)\n        block.parse(child, rules)\n        return child.tokens"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 54,
      "kind": "function",
      "qualname": "src.mistune.directives._base.DirectiveParser.parse_options",
      "span": [
        53,
        67
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_options(m: Match[str]) -> List[Tuple[str, str]]:\n        text = m.group(\"options\")\n        if not text.strip():\n            return []\n\n        options = []\n        for line in re.split(r\"\\n+\", text):\n            line = line.strip()[1:]\n            if not line:\n                continue\n            i = line.find(\":\")\n            k = line[:i]\n            v = line[i + 1 :].strip()\n            options.append((k, v))\n        return options",
      "old_code": "    def parse_options(m: Match[str]) -> List[Tuple[str, str]]:\n        text = m.group('options')\n        if not text.strip():\n            return []\n\n        options = []\n        for line in re.split(r'\\n+', text):\n            line = line.strip()[1:]\n            if not line:\n                continue\n            i = line.find(':')\n            k = line[:i]\n            v = line[i + 1:].strip()\n            options.append((k, v))\n        return options"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 103,
      "kind": "function",
      "qualname": "src.mistune.directives._base.BaseDirective.parse_method",
      "span": [
        94,
        116
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_method(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:\n        _type = self.parser.parse_type(m)\n        method = self._methods.get(_type)\n        if method:\n            try:\n                token = method(block, m, state)\n            except ValueError as e:\n                token = {\"type\": \"block_error\", \"raw\": str(e)}\n        else:\n            text = m.group(0)\n            token = {\n                \"type\": \"block_error\",\n                \"raw\": text,\n            }\n\n        if isinstance(token, list):\n            for tok in token:\n                state.append_token(tok)\n        else:\n            state.append_token(token)\n        return token",
      "old_code": "    def parse_method(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:\n        _type = self.parser.parse_type(m)\n        method = self._methods.get(_type)\n        if method:\n            try:\n                token = method(block, m, state)\n            except ValueError as e:\n                token = {'type': 'block_error', 'raw': str(e)}\n        else:\n            text = m.group(0)\n            token = {\n                'type': 'block_error',\n                'raw': text,\n            }\n\n        if isinstance(token, list):\n            for tok in token:\n                state.append_token(tok)\n        else:\n            state.append_token(token)\n        return token"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 119,
      "kind": "function",
      "qualname": "src.mistune.directives._base.BaseDirective.parse_directive",
      "span": [
        119,
        120
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_directive(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        raise NotImplementedError()",
      "old_code": "    def parse_directive(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        raise NotImplementedError()"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 122,
      "kind": "function",
      "qualname": "src.mistune.directives._base.BaseDirective.register_block_parser",
      "span": [
        122,
        128
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def register_block_parser(self, md: \"Markdown\", before: Optional[str] = None) -> None:\n        md.block.register(\n            self.parser.name,\n            self.directive_pattern,\n            self.parse_directive,\n            before=before,\n        )",
      "old_code": "    def register_block_parser(\n        self, md: \"Markdown\", before: Optional[str] = None\n    ) -> None:\n        md.block.register(\n            self.parser.name,\n            self.directive_pattern,\n            self.parse_directive,\n            before=before,\n        )"
    },
    {
      "path": "src/mistune/directives/_base.py",
      "version": "new",
      "line": 153,
      "kind": "function",
      "qualname": "src.mistune.directives._base.DirectivePlugin.parse_tokens",
      "span": [
        153,
        154
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_tokens(self, block: \"BlockParser\", text: str, state: \"BlockState\") -> Iterable[Dict[str, Any]]:\n        return self.parser.parse_tokens(block, text, state)",
      "old_code": "    def parse_tokens(\n        self, block: \"BlockParser\", text: str, state: \"BlockState\"\n    ) -> Iterable[Dict[str, Any]]:\n        return self.parser.parse_tokens(block, text, state)"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 12,
      "kind": "module",
      "qualname": "src.mistune.directives._fenced",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 24,
      "kind": "class",
      "qualname": "src.mistune.directives._fenced.FencedParser",
      "span": [
        23,
        36
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class FencedParser(DirectiveParser):\n    name = \"fenced_directive\"\n\n    @staticmethod\n    def parse_type(m: Match[str]) -> str:\n        return m.group(\"type\")\n\n    @staticmethod\n    def parse_title(m: Match[str]) -> str:\n        return m.group(\"title\")\n\n    @staticmethod\n    def parse_content(m: Match[str]) -> str:\n        return m.group(\"text\")",
      "old_code": "class FencedParser(DirectiveParser):\n    name = 'fenced_directive'\n\n    @staticmethod\n    def parse_type(m: Match[str]) -> str:\n        return m.group('type')\n\n    @staticmethod\n    def parse_title(m: Match[str]) -> str:\n        return m.group('title')\n\n    @staticmethod\n    def parse_content(m: Match[str]) -> str:\n        return m.group('text')"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 28,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedParser.parse_type",
      "span": [
        27,
        28
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_type(m: Match[str]) -> str:\n        return m.group(\"type\")",
      "old_code": "    def parse_type(m: Match[str]) -> str:\n        return m.group('type')"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 32,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedParser.parse_title",
      "span": [
        31,
        32
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_title(m: Match[str]) -> str:\n        return m.group(\"title\")",
      "old_code": "    def parse_title(m: Match[str]) -> str:\n        return m.group('title')"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 36,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedParser.parse_content",
      "span": [
        35,
        36
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_content(m: Match[str]) -> str:\n        return m.group(\"text\")",
      "old_code": "    def parse_content(m: Match[str]) -> str:\n        return m.group('text')"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 94,
      "kind": "class",
      "qualname": "src.mistune.directives._fenced.FencedDirective",
      "span": [
        39,
        151
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class FencedDirective(BaseDirective):\n    \"\"\"A **fenced** style of directive looks like a fenced code block, it is\n    inspired by markdown-it-docutils. The syntax looks like:\n\n    .. code-block:: text\n\n        ```{directive-type} title\n        :option-key: option value\n        :option-key: option value\n\n        content text here\n        ```\n\n    To use ``FencedDirective``, developers can add it into plugin list in\n    the :class:`Markdown` instance:\n\n    .. code-block:: python\n\n        import mistune\n        from mistune.directives import FencedDirective, Admonition\n\n        md = mistune.create_markdown(plugins=[\n            # ...\n            FencedDirective([Admonition()]),\n        ])\n\n    FencedDirective is using >= 3 backticks or curly-brackets for the fenced\n    syntax. Developers can change it to other characters, e.g. colon:\n\n    .. code-block:: python\n\n            directive = FencedDirective([Admonition()], ':')\n\n    And then the directive syntax would look like:\n\n    .. code-block:: text\n\n        ::::{note} Nesting directives\n        You can nest directives by ensuring the start and end fence matching\n        the length. For instance, in this example, the admonition is started\n        with 4 colons, then it should end with 4 colons.\n\n        You can nest another admonition with other length of colons except 4.\n\n        :::{tip} Longer outermost fence\n        It would be better that you put longer markers for the outer fence,\n        and shorter markers for the inner fence. In this example, we put 4\n        colons outsie, and 3 colons inside.\n        :::\n        ::::\n\n    :param plugins: list of directive plugins\n    :param markers: characters to determine the fence, default is backtick\n                    and curly-bracket\n    \"\"\"\n\n    parser = FencedParser\n\n    def __init__(self, plugins: List[DirectivePlugin], markers: str = \"`~\") -> None:\n        super(FencedDirective, self).__init__(plugins)\n        self.markers = markers\n        _marker_pattern = \"|\".join(re.escape(c) for c in markers)\n        self.directive_pattern = (\n            r\"^(?P<fenced_directive_mark>(?:\" + _marker_pattern + r\"){3,})\"\n            r\"\\{[a-zA-Z0-9_-]+\\}\"\n        )\n\n    def _process_directive(self, block: \"BlockParser\", marker: str, start: int, state: \"BlockState\") -> Optional[int]:\n        mlen = len(marker)\n        cursor_start = start + len(marker)\n\n        _end_pattern = (\n            r\"^ {0,3}\" + marker[0] + \"{\" + str(mlen) + r\",}\"\n            r\"[ \\t]*(?:\\n|$)\"\n        )\n        _end_re = re.compile(_end_pattern, re.M)\n\n        _end_m = _end_re.search(state.src, cursor_start)\n        if _end_m:\n            text = state.src[cursor_start : _end_m.start()]\n            end_pos = _end_m.end()\n        else:\n            text = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        m = _directive_re.match(text)\n        if not m:\n            return None\n\n        self.parse_method(block, m, state)\n        return end_pos\n\n    def parse_directive(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        marker = m.group(\"fenced_directive_mark\")\n        return self._process_directive(block, marker, m.start(), state)\n\n    def parse_fenced_code(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        info = m.group(\"fenced_3\")\n        if not info or not _type_re.match(info):\n            return block.parse_fenced_code(m, state)\n\n        if state.depth() >= block.max_nested_level:\n            return block.parse_fenced_code(m, state)\n\n        marker = m.group(\"fenced_2\")\n        return self._process_directive(block, marker, m.start(), state)\n\n    def __call__(self, md: \"Markdown\") -> None:\n        super(FencedDirective, self).__call__(md)\n        if self.markers == \"`~\":\n            md.block.register(\"fenced_code\", None, self.parse_fenced_code)\n        else:\n            self.register_block_parser(md, \"fenced_code\")",
      "old_code": "class FencedDirective(BaseDirective):\n    \"\"\"A **fenced** style of directive looks like a fenced code block, it is\n    inspired by markdown-it-docutils. The syntax looks like:\n\n    .. code-block:: text\n\n        ```{directive-type} title\n        :option-key: option value\n        :option-key: option value\n\n        content text here\n        ```\n\n    To use ``FencedDirective``, developers can add it into plugin list in\n    the :class:`Markdown` instance:\n\n    .. code-block:: python\n\n        import mistune\n        from mistune.directives import FencedDirective, Admonition\n\n        md = mistune.create_markdown(plugins=[\n            # ...\n            FencedDirective([Admonition()]),\n        ])\n\n    FencedDirective is using >= 3 backticks or curly-brackets for the fenced\n    syntax. Developers can change it to other characters, e.g. colon:\n\n    .. code-block:: python\n\n            directive = FencedDirective([Admonition()], ':')\n\n    And then the directive syntax would look like:\n\n    .. code-block:: text\n\n        ::::{note} Nesting directives\n        You can nest directives by ensuring the start and end fence matching\n        the length. For instance, in this example, the admonition is started\n        with 4 colons, then it should end with 4 colons.\n\n        You can nest another admonition with other length of colons except 4.\n\n        :::{tip} Longer outermost fence\n        It would be better that you put longer markers for the outer fence,\n        and shorter markers for the inner fence. In this example, we put 4\n        colons outsie, and 3 colons inside.\n        :::\n        ::::\n\n    :param plugins: list of directive plugins\n    :param markers: characters to determine the fence, default is backtick\n                    and curly-bracket\n    \"\"\"\n    parser = FencedParser\n\n    def __init__(self, plugins: List[DirectivePlugin], markers: str = \"`~\") -> None:\n        super(FencedDirective, self).__init__(plugins)\n        self.markers = markers\n        _marker_pattern = '|'.join(re.escape(c) for c in markers)\n        self.directive_pattern = (\n            r'^(?P<fenced_directive_mark>(?:' + _marker_pattern + r'){3,})'\n            r'\\{[a-zA-Z0-9_-]+\\}'\n        )\n\n    def _process_directive(\n        self, block: \"BlockParser\", marker: str, start: int, state: \"BlockState\"\n    ) -> Optional[int]:\n        mlen = len(marker)\n        cursor_start = start + len(marker)\n\n        _end_pattern = (\n            r'^ {0,3}' + marker[0] + '{' + str(mlen) + r',}'\n            r'[ \\t]*(?:\\n|$)'\n        )\n        _end_re = re.compile(_end_pattern, re.M)\n\n        _end_m = _end_re.search(state.src, cursor_start)\n        if _end_m:\n            text = state.src[cursor_start:_end_m.start()]\n            end_pos = _end_m.end()\n        else:\n            text = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        m = _directive_re.match(text)\n        if not m:\n            return None\n\n        self.parse_method(block, m, state)\n        return end_pos\n\n    def parse_directive(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        marker = m.group(\"fenced_directive_mark\")\n        return self._process_directive(block, marker, m.start(), state)\n\n    def parse_fenced_code(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        info = m.group(\"fenced_3\")\n        if not info or not _type_re.match(info):\n            return block.parse_fenced_code(m, state)\n\n        if state.depth() >= block.max_nested_level:\n            return block.parse_fenced_code(m, state)\n\n        marker = m.group('fenced_2')\n        return self._process_directive(block, marker, m.start(), state)\n\n    def __call__(self, md: \"Markdown\") -> None:\n        super(FencedDirective, self).__call__(md)\n        if self.markers == '`~':\n            md.block.register('fenced_code', None, self.parse_fenced_code)\n        else:\n            self.register_block_parser(md, 'fenced_code')"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 100,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedDirective.__init__",
      "span": [
        97,
        104
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, plugins: List[DirectivePlugin], markers: str = \"`~\") -> None:\n        super(FencedDirective, self).__init__(plugins)\n        self.markers = markers\n        _marker_pattern = \"|\".join(re.escape(c) for c in markers)\n        self.directive_pattern = (\n            r\"^(?P<fenced_directive_mark>(?:\" + _marker_pattern + r\"){3,})\"\n            r\"\\{[a-zA-Z0-9_-]+\\}\"\n        )",
      "old_code": "    def __init__(self, plugins: List[DirectivePlugin], markers: str = \"`~\") -> None:\n        super(FencedDirective, self).__init__(plugins)\n        self.markers = markers\n        _marker_pattern = '|'.join(re.escape(c) for c in markers)\n        self.directive_pattern = (\n            r'^(?P<fenced_directive_mark>(?:' + _marker_pattern + r'){3,})'\n            r'\\{[a-zA-Z0-9_-]+\\}'\n        )"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 106,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedDirective._process_directive",
      "span": [
        106,
        129
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _process_directive(self, block: \"BlockParser\", marker: str, start: int, state: \"BlockState\") -> Optional[int]:\n        mlen = len(marker)\n        cursor_start = start + len(marker)\n\n        _end_pattern = (\n            r\"^ {0,3}\" + marker[0] + \"{\" + str(mlen) + r\",}\"\n            r\"[ \\t]*(?:\\n|$)\"\n        )\n        _end_re = re.compile(_end_pattern, re.M)\n\n        _end_m = _end_re.search(state.src, cursor_start)\n        if _end_m:\n            text = state.src[cursor_start : _end_m.start()]\n            end_pos = _end_m.end()\n        else:\n            text = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        m = _directive_re.match(text)\n        if not m:\n            return None\n\n        self.parse_method(block, m, state)\n        return end_pos",
      "old_code": "    def _process_directive(\n        self, block: \"BlockParser\", marker: str, start: int, state: \"BlockState\"\n    ) -> Optional[int]:\n        mlen = len(marker)\n        cursor_start = start + len(marker)\n\n        _end_pattern = (\n            r'^ {0,3}' + marker[0] + '{' + str(mlen) + r',}'\n            r'[ \\t]*(?:\\n|$)'\n        )\n        _end_re = re.compile(_end_pattern, re.M)\n\n        _end_m = _end_re.search(state.src, cursor_start)\n        if _end_m:\n            text = state.src[cursor_start:_end_m.start()]\n            end_pos = _end_m.end()\n        else:\n            text = state.src[cursor_start:]\n            end_pos = state.cursor_max\n\n        m = _directive_re.match(text)\n        if not m:\n            return None\n\n        self.parse_method(block, m, state)\n        return end_pos"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 131,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedDirective.parse_directive",
      "span": [
        131,
        133
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_directive(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        marker = m.group(\"fenced_directive_mark\")\n        return self._process_directive(block, marker, m.start(), state)",
      "old_code": "    def parse_directive(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        marker = m.group(\"fenced_directive_mark\")\n        return self._process_directive(block, marker, m.start(), state)"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 135,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedDirective.parse_fenced_code",
      "span": [
        135,
        144
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_fenced_code(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        info = m.group(\"fenced_3\")\n        if not info or not _type_re.match(info):\n            return block.parse_fenced_code(m, state)\n\n        if state.depth() >= block.max_nested_level:\n            return block.parse_fenced_code(m, state)\n\n        marker = m.group(\"fenced_2\")\n        return self._process_directive(block, marker, m.start(), state)",
      "old_code": "    def parse_fenced_code(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        info = m.group(\"fenced_3\")\n        if not info or not _type_re.match(info):\n            return block.parse_fenced_code(m, state)\n\n        if state.depth() >= block.max_nested_level:\n            return block.parse_fenced_code(m, state)\n\n        marker = m.group('fenced_2')\n        return self._process_directive(block, marker, m.start(), state)"
    },
    {
      "path": "src/mistune/directives/_fenced.py",
      "version": "new",
      "line": 148,
      "kind": "function",
      "qualname": "src.mistune.directives._fenced.FencedDirective.__call__",
      "span": [
        146,
        151
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, md: \"Markdown\") -> None:\n        super(FencedDirective, self).__call__(md)\n        if self.markers == \"`~\":\n            md.block.register(\"fenced_code\", None, self.parse_fenced_code)\n        else:\n            self.register_block_parser(md, \"fenced_code\")",
      "old_code": "    def __call__(self, md: \"Markdown\") -> None:\n        super(FencedDirective, self).__call__(md)\n        if self.markers == '`~':\n            md.block.register('fenced_code', None, self.parse_fenced_code)\n        else:\n            self.register_block_parser(md, 'fenced_code')"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 11,
      "kind": "module",
      "qualname": "src.mistune.directives._rst",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 22,
      "kind": "class",
      "qualname": "src.mistune.directives._rst.RSTParser",
      "span": [
        21,
        38
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class RSTParser(DirectiveParser):\n    name = \"rst_directive\"\n\n    @staticmethod\n    def parse_type(m: Match[str]) -> str:\n        return m.group(\"type\")\n\n    @staticmethod\n    def parse_title(m: Match[str]) -> str:\n        return m.group(\"title\")\n\n    @staticmethod\n    def parse_content(m: Match[str]) -> str:\n        full_content = m.group(0)\n        text = m.group(\"text\")\n        pretext = full_content[: -len(text)]\n        leading = len(m.group(1)) + 2\n        return \"\\n\".join(line[leading:] for line in text.splitlines()) + \"\\n\"",
      "old_code": "class RSTParser(DirectiveParser):\n    name = 'rst_directive'\n\n    @staticmethod\n    def parse_type(m: Match[str]) -> str:\n        return m.group('type')\n\n    @staticmethod\n    def parse_title(m: Match[str]) -> str:\n        return m.group('title')\n\n    @staticmethod\n    def parse_content(m: Match[str]) -> str:\n        full_content = m.group(0)\n        text = m.group('text')\n        pretext = full_content[:-len(text)]\n        leading = len(m.group(1)) + 2\n        return '\\n'.join(line[leading:] for line in text.splitlines()) + '\\n'"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 26,
      "kind": "function",
      "qualname": "src.mistune.directives._rst.RSTParser.parse_type",
      "span": [
        25,
        26
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_type(m: Match[str]) -> str:\n        return m.group(\"type\")",
      "old_code": "    def parse_type(m: Match[str]) -> str:\n        return m.group('type')"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 30,
      "kind": "function",
      "qualname": "src.mistune.directives._rst.RSTParser.parse_title",
      "span": [
        29,
        30
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_title(m: Match[str]) -> str:\n        return m.group(\"title\")",
      "old_code": "    def parse_title(m: Match[str]) -> str:\n        return m.group('title')"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 35,
      "kind": "function",
      "qualname": "src.mistune.directives._rst.RSTParser.parse_content",
      "span": [
        33,
        38
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_content(m: Match[str]) -> str:\n        full_content = m.group(0)\n        text = m.group(\"text\")\n        pretext = full_content[: -len(text)]\n        leading = len(m.group(1)) + 2\n        return \"\\n\".join(line[leading:] for line in text.splitlines()) + \"\\n\"",
      "old_code": "    def parse_content(m: Match[str]) -> str:\n        full_content = m.group(0)\n        text = m.group('text')\n        pretext = full_content[:-len(text)]\n        leading = len(m.group(1)) + 2\n        return '\\n'.join(line[leading:] for line in text.splitlines()) + '\\n'"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 67,
      "kind": "class",
      "qualname": "src.mistune.directives._rst.RSTDirective",
      "span": [
        41,
        81
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class RSTDirective(BaseDirective):\n    \"\"\"A RST style of directive syntax is inspired by reStructuredText.\n    The syntax is very powerful that you can define a lot of custom\n    features on your own. The syntax looks like:\n\n    .. code-block:: text\n\n        .. directive-type:: directive value\n           :option-key: option value\n           :option-key: option value\n\n           content text here\n\n    To use ``RSTDirective``, developers can add it into plugin list in\n    the :class:`Markdown` instance:\n\n    .. code-block:: python\n\n        import mistune\n        from mistune.directives import RSTDirective, Admonition\n\n        md = mistune.create_markdown(plugins=[\n            # ...\n            RSTDirective([Admonition()]),\n        ])\n    \"\"\"\n\n    parser = RSTParser\n    directive_pattern = r\"^\\.\\. +[a-zA-Z0-9_-]+\\:\\:\"\n\n    def parse_directive(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        m2 = _directive_re.match(state.src, state.cursor)\n        if not m2:\n            return None\n\n        self.parse_method(block, m2, state)\n        return m2.end()\n\n    def __call__(self, markdown: \"Markdown\") -> None:\n        super(RSTDirective, self).__call__(markdown)\n        self.register_block_parser(markdown)",
      "old_code": "class RSTDirective(BaseDirective):\n    \"\"\"A RST style of directive syntax is inspired by reStructuredText.\n    The syntax is very powerful that you can define a lot of custom\n    features on your own. The syntax looks like:\n\n    .. code-block:: text\n\n        .. directive-type:: directive value\n           :option-key: option value\n           :option-key: option value\n\n           content text here\n\n    To use ``RSTDirective``, developers can add it into plugin list in\n    the :class:`Markdown` instance:\n\n    .. code-block:: python\n\n        import mistune\n        from mistune.directives import RSTDirective, Admonition\n\n        md = mistune.create_markdown(plugins=[\n            # ...\n            RSTDirective([Admonition()]),\n        ])\n    \"\"\"\n    parser = RSTParser\n    directive_pattern = r'^\\.\\. +[a-zA-Z0-9_-]+\\:\\:'\n\n    def parse_directive(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        m2 = _directive_re.match(state.src, state.cursor)\n        if not m2:\n            return None\n\n        self.parse_method(block, m2, state)\n        return m2.end()\n\n    def __call__(self, markdown: \"Markdown\") -> None:\n        super(RSTDirective, self).__call__(markdown)\n        self.register_block_parser(markdown)"
    },
    {
      "path": "src/mistune/directives/_rst.py",
      "version": "new",
      "line": 71,
      "kind": "function",
      "qualname": "src.mistune.directives._rst.RSTDirective.parse_directive",
      "span": [
        71,
        77
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_directive(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n        m2 = _directive_re.match(state.src, state.cursor)\n        if not m2:\n            return None\n\n        self.parse_method(block, m2, state)\n        return m2.end()",
      "old_code": "    def parse_directive(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[int]:\n        m2 = _directive_re.match(state.src, state.cursor)\n        if not m2:\n            return None\n\n        self.parse_method(block, m2, state)\n        return m2.end()"
    },
    {
      "path": "src/mistune/directives/admonition.py",
      "version": "new",
      "line": 13,
      "kind": "class",
      "qualname": "src.mistune.directives.admonition.Admonition",
      "span": [
        11,
        60
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class Admonition(DirectivePlugin):\n    SUPPORTED_NAMES = {\n        \"attention\",\n        \"caution\",\n        \"danger\",\n        \"error\",\n        \"hint\",\n        \"important\",\n        \"note\",\n        \"tip\",\n        \"warning\",\n    }\n\n    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        name = self.parse_type(m)\n        attrs = {\"name\": name}\n        options = dict(self.parse_options(m))\n        if \"class\" in options:\n            attrs[\"class\"] = options[\"class\"]\n\n        title = self.parse_title(m)\n        if not title:\n            title = name.capitalize()\n\n        content = self.parse_content(m)\n        children = [\n            {\n                \"type\": \"admonition_title\",\n                \"text\": title,\n            },\n            {\n                \"type\": \"admonition_content\",\n                \"children\": self.parse_tokens(block, content, state),\n            },\n        ]\n        return {\n            \"type\": \"admonition\",\n            \"children\": children,\n            \"attrs\": attrs,\n        }\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"admonition\", render_admonition)\n            md.renderer.register(\"admonition_title\", render_admonition_title)\n            md.renderer.register(\"admonition_content\", render_admonition_content)",
      "old_code": "class Admonition(DirectivePlugin):\n    SUPPORTED_NAMES = {\n        \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n        \"important\", \"note\", \"tip\", \"warning\",\n    }\n\n    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        name = self.parse_type(m)\n        attrs = {'name': name}\n        options = dict(self.parse_options(m))\n        if 'class' in options:\n            attrs['class'] = options['class']\n\n        title = self.parse_title(m)\n        if not title:\n            title = name.capitalize()\n\n        content = self.parse_content(m)\n        children = [\n            {\n                'type': 'admonition_title',\n                'text': title,\n            },\n            {\n                'type': 'admonition_content',\n                'children': self.parse_tokens(block, content, state),\n            }\n        ]\n        return {\n            'type': 'admonition',\n            'children': children,\n            'attrs': attrs,\n        }\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('admonition', render_admonition)\n            md.renderer.register('admonition_title', render_admonition_title)\n            md.renderer.register('admonition_content', render_admonition_content)"
    },
    {
      "path": "src/mistune/directives/admonition.py",
      "version": "new",
      "line": 24,
      "kind": "function",
      "qualname": "src.mistune.directives.admonition.Admonition.parse",
      "span": [
        24,
        50
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        name = self.parse_type(m)\n        attrs = {\"name\": name}\n        options = dict(self.parse_options(m))\n        if \"class\" in options:\n            attrs[\"class\"] = options[\"class\"]\n\n        title = self.parse_title(m)\n        if not title:\n            title = name.capitalize()\n\n        content = self.parse_content(m)\n        children = [\n            {\n                \"type\": \"admonition_title\",\n                \"text\": title,\n            },\n            {\n                \"type\": \"admonition_content\",\n                \"children\": self.parse_tokens(block, content, state),\n            },\n        ]\n        return {\n            \"type\": \"admonition\",\n            \"children\": children,\n            \"attrs\": attrs,\n        }",
      "old_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        name = self.parse_type(m)\n        attrs = {'name': name}\n        options = dict(self.parse_options(m))\n        if 'class' in options:\n            attrs['class'] = options['class']\n\n        title = self.parse_title(m)\n        if not title:\n            title = name.capitalize()\n\n        content = self.parse_content(m)\n        children = [\n            {\n                'type': 'admonition_title',\n                'text': title,\n            },\n            {\n                'type': 'admonition_content',\n                'children': self.parse_tokens(block, content, state),\n            }\n        ]\n        return {\n            'type': 'admonition',\n            'children': children,\n            'attrs': attrs,\n        }"
    },
    {
      "path": "src/mistune/directives/admonition.py",
      "version": "new",
      "line": 57,
      "kind": "function",
      "qualname": "src.mistune.directives.admonition.Admonition.__call__",
      "span": [
        52,
        60
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"admonition\", render_admonition)\n            md.renderer.register(\"admonition_title\", render_admonition_title)\n            md.renderer.register(\"admonition_content\", render_admonition_content)",
      "old_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('admonition', render_admonition)\n            md.renderer.register('admonition_title', render_admonition_title)\n            md.renderer.register('admonition_content', render_admonition_content)"
    },
    {
      "path": "src/mistune/directives/admonition.py",
      "version": "new",
      "line": 65,
      "kind": "function",
      "qualname": "src.mistune.directives.admonition.render_admonition",
      "span": [
        63,
        68
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_admonition(self: Any, text: str, name: str, **attrs: Any) -> str:\n    html = '<section class=\"admonition ' + name\n    _cls = attrs.get(\"class\")\n    if _cls:\n        html += \" \" + _cls\n    return html + '\">\\n' + text + \"</section>\\n\"",
      "old_code": "def render_admonition(self: Any, text: str, name: str, **attrs: Any) -> str:\n    html = '<section class=\"admonition ' + name\n    _cls = attrs.get('class')\n    if _cls:\n        html += ' ' + _cls\n    return html + '\">\\n' + text + '</section>\\n'"
    },
    {
      "path": "src/mistune/directives/admonition.py",
      "version": "new",
      "line": 72,
      "kind": "function",
      "qualname": "src.mistune.directives.admonition.render_admonition_title",
      "span": [
        71,
        72
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_admonition_title(self: Any, text: str) -> str:\n    return '<p class=\"admonition-title\">' + text + \"</p>\\n\"",
      "old_code": "def render_admonition_title(self: Any, text: str) -> str:\n    return '<p class=\"admonition-title\">' + text + '</p>\\n'"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 14,
      "kind": "module",
      "qualname": "src.mistune.directives.image",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 22,
      "kind": "function",
      "qualname": "src.mistune.directives.image._parse_attrs",
      "span": [
        20,
        38
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_attrs(options: Dict[str, Any]) -> Dict[str, Any]:\n    attrs = {}\n    if \"alt\" in options:\n        attrs[\"alt\"] = options[\"alt\"]\n\n    # validate align\n    align = options.get(\"align\")\n    if align and align in _allowed_aligns:\n        attrs[\"align\"] = align\n\n    height = options.get(\"height\")\n    width = options.get(\"width\")\n    if height and _num_re.match(height):\n        attrs[\"height\"] = height\n    if width and _num_re.match(width):\n        attrs[\"width\"] = width\n    if \"target\" in options:\n        attrs[\"target\"] = escape_url(options[\"target\"])\n    return attrs",
      "old_code": "def _parse_attrs(options: Dict[str, Any]) -> Dict[str, Any]:\n    attrs = {}\n    if 'alt' in options:\n        attrs['alt'] = options['alt']\n\n    # validate align\n    align = options.get('align')\n    if align and align in _allowed_aligns:\n        attrs['align'] = align\n\n    height = options.get('height')\n    width = options.get('width')\n    if height and _num_re.match(height):\n        attrs['height'] = height\n    if width and _num_re.match(width):\n        attrs['width'] = width\n    if 'target' in options:\n        attrs['target'] = escape_url(options['target'])\n    return attrs"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 42,
      "kind": "class",
      "qualname": "src.mistune.directives.image.Image",
      "span": [
        41,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class Image(DirectivePlugin):\n    NAME = \"image\"\n\n    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        attrs = _parse_attrs(options)\n        attrs[\"src\"] = self.parse_title(m)\n        return {\"type\": \"block_image\", \"attrs\": attrs}\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"block_image\", render_block_image)",
      "old_code": "class Image(DirectivePlugin):\n    NAME = 'image'\n\n    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        attrs = _parse_attrs(options)\n        attrs['src'] = self.parse_title(m)\n        return {'type': 'block_image', 'attrs': attrs}\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('block_image', render_block_image)"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 44,
      "kind": "function",
      "qualname": "src.mistune.directives.image.Image.parse",
      "span": [
        44,
        48
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        attrs = _parse_attrs(options)\n        attrs[\"src\"] = self.parse_title(m)\n        return {\"type\": \"block_image\", \"attrs\": attrs}",
      "old_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        attrs = _parse_attrs(options)\n        attrs['src'] = self.parse_title(m)\n        return {'type': 'block_image', 'attrs': attrs}"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 53,
      "kind": "function",
      "qualname": "src.mistune.directives.image.Image.__call__",
      "span": [
        50,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"block_image\", render_block_image)",
      "old_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('block_image', render_block_image)"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 58,
      "kind": "function",
      "qualname": "src.mistune.directives.image.render_block_image",
      "span": [
        57,
        95
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_block_image(\n    self: \"HTMLRenderer\",\n    src: str,\n    alt: Optional[str] = None,\n    width: Optional[str] = None,\n    height: Optional[str] = None,\n    **attrs: Any,\n) -> str:\n    img = '<img src=\"' + escape_text(src) + '\"'\n    style = \"\"\n    if alt:\n        img += ' alt=\"' + escape_text(alt) + '\"'\n    if width:\n        if width.isdigit():\n            img += ' width=\"' + width + '\"'\n        else:\n            style += \"width:\" + width + \";\"\n    if height:\n        if height.isdigit():\n            img += ' height=\"' + height + '\"'\n        else:\n            style += \"height:\" + height + \";\"\n    if style:\n        img += ' style=\"' + escape_text(style) + '\"'\n\n    img += \" />\"\n\n    _cls = \"block-image\"\n    align = attrs.get(\"align\")\n    if align:\n        _cls += \" align-\" + align\n\n    target = attrs.get(\"target\")\n    if target:\n        href = self.safe_url(target)\n        outer = '<a class=\"' + _cls + '\" href=\"' + href + '\">'\n        return outer + img + \"</a>\\n\"\n    else:\n        return '<div class=\"' + _cls + '\">' + img + \"</div>\\n\"",
      "old_code": "def render_block_image(\n    self: 'HTMLRenderer',\n    src: str,\n    alt: Optional[str] = None,\n    width: Optional[str] = None,\n    height: Optional[str] = None,\n    **attrs: Any,\n) -> str:\n    img = '<img src=\"' + escape_text(src) + '\"'\n    style = ''\n    if alt:\n        img += ' alt=\"' + escape_text(alt) + '\"'\n    if width:\n        if width.isdigit():\n            img += ' width=\"' + width + '\"'\n        else:\n            style += 'width:' + width + ';'\n    if height:\n        if height.isdigit():\n            img += ' height=\"' + height + '\"'\n        else:\n            style += 'height:' + height + ';'\n    if style:\n        img += ' style=\"' + escape_text(style) + '\"'\n\n    img += ' />'\n\n    _cls = 'block-image'\n    align = attrs.get('align')\n    if align:\n        _cls += ' align-' + align\n\n    target = attrs.get('target')\n    if target:\n        href = self.safe_url(target)\n        outer = '<a class=\"' + _cls + '\" href=\"' + href + '\">'\n        return outer + img + '</a>\\n'\n    else:\n        return '<div class=\"' + _cls + '\">' + img + '</div>\\n'"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 99,
      "kind": "class",
      "qualname": "src.mistune.directives.image.Figure",
      "span": [
        98,
        149
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class Figure(DirectivePlugin):\n    NAME = \"figure\"\n\n    def parse_directive_content(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[List[Dict[str, Any]]]:\n        content = self.parse_content(m)\n        if not content:\n            return None\n\n        tokens = list(self.parse_tokens(block, content, state))\n        caption = tokens[0]\n        if caption[\"type\"] == \"paragraph\":\n            caption[\"type\"] = \"figcaption\"\n            children = [caption]\n            if len(tokens) > 1:\n                children.append({\"type\": \"legend\", \"children\": tokens[1:]})\n            return children\n        return None\n\n    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        image_attrs = _parse_attrs(options)\n        image_attrs[\"src\"] = self.parse_title(m)\n\n        align = image_attrs.pop(\"align\", None)\n        fig_attrs = {}\n        if align:\n            fig_attrs[\"align\"] = align\n        for k in [\"figwidth\", \"figclass\"]:\n            if k in options:\n                fig_attrs[k] = options[k]\n\n        children = [{\"type\": \"block_image\", \"attrs\": image_attrs}]\n        content = self.parse_directive_content(block, m, state)\n        if content:\n            children.extend(content)\n        return {\n            \"type\": \"figure\",\n            \"attrs\": fig_attrs,\n            \"children\": children,\n        }\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"figure\", render_figure)\n            md.renderer.register(\"block_image\", render_block_image)\n            md.renderer.register(\"figcaption\", render_figcaption)\n            md.renderer.register(\"legend\", render_legend)",
      "old_code": "class Figure(DirectivePlugin):\n    NAME = 'figure'\n\n    def parse_directive_content(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[List[Dict[str, Any]]]:\n        content = self.parse_content(m)\n        if not content:\n            return None\n\n        tokens = list(self.parse_tokens(block, content, state))\n        caption = tokens[0]\n        if caption['type'] == 'paragraph':\n            caption['type'] = 'figcaption'\n            children = [caption]\n            if len(tokens) > 1:\n                children.append({\n                    'type': 'legend',\n                    'children': tokens[1:]\n                })\n            return children\n        return None\n\n    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        image_attrs = _parse_attrs(options)\n        image_attrs['src'] = self.parse_title(m)\n\n        align = image_attrs.pop('align', None)\n        fig_attrs = {}\n        if align:\n            fig_attrs['align'] = align\n        for k in ['figwidth', 'figclass']:\n            if k in options:\n                fig_attrs[k] = options[k]\n\n        children = [{'type': 'block_image', 'attrs': image_attrs}]\n        content = self.parse_directive_content(block, m, state)\n        if content:\n            children.extend(content)\n        return {\n            'type': 'figure',\n            'attrs': fig_attrs,\n            'children': children,\n        }\n\n    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('figure', render_figure)\n            md.renderer.register('block_image', render_block_image)\n            md.renderer.register('figcaption', render_figcaption)\n            md.renderer.register('legend', render_legend)"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 110,
      "kind": "function",
      "qualname": "src.mistune.directives.image.Figure.parse_directive_content",
      "span": [
        101,
        116
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_directive_content(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[List[Dict[str, Any]]]:\n        content = self.parse_content(m)\n        if not content:\n            return None\n\n        tokens = list(self.parse_tokens(block, content, state))\n        caption = tokens[0]\n        if caption[\"type\"] == \"paragraph\":\n            caption[\"type\"] = \"figcaption\"\n            children = [caption]\n            if len(tokens) > 1:\n                children.append({\"type\": \"legend\", \"children\": tokens[1:]})\n            return children\n        return None",
      "old_code": "    def parse_directive_content(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Optional[List[Dict[str, Any]]]:\n        content = self.parse_content(m)\n        if not content:\n            return None\n\n        tokens = list(self.parse_tokens(block, content, state))\n        caption = tokens[0]\n        if caption['type'] == 'paragraph':\n            caption['type'] = 'figcaption'\n            children = [caption]\n            if len(tokens) > 1:\n                children.append({\n                    'type': 'legend',\n                    'children': tokens[1:]\n                })\n            return children\n        return None"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 118,
      "kind": "function",
      "qualname": "src.mistune.directives.image.Figure.parse",
      "span": [
        118,
        139
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        image_attrs = _parse_attrs(options)\n        image_attrs[\"src\"] = self.parse_title(m)\n\n        align = image_attrs.pop(\"align\", None)\n        fig_attrs = {}\n        if align:\n            fig_attrs[\"align\"] = align\n        for k in [\"figwidth\", \"figclass\"]:\n            if k in options:\n                fig_attrs[k] = options[k]\n\n        children = [{\"type\": \"block_image\", \"attrs\": image_attrs}]\n        content = self.parse_directive_content(block, m, state)\n        if content:\n            children.extend(content)\n        return {\n            \"type\": \"figure\",\n            \"attrs\": fig_attrs,\n            \"children\": children,\n        }",
      "old_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        options = dict(self.parse_options(m))\n        image_attrs = _parse_attrs(options)\n        image_attrs['src'] = self.parse_title(m)\n\n        align = image_attrs.pop('align', None)\n        fig_attrs = {}\n        if align:\n            fig_attrs['align'] = align\n        for k in ['figwidth', 'figclass']:\n            if k in options:\n                fig_attrs[k] = options[k]\n\n        children = [{'type': 'block_image', 'attrs': image_attrs}]\n        content = self.parse_directive_content(block, m, state)\n        if content:\n            children.extend(content)\n        return {\n            'type': 'figure',\n            'attrs': fig_attrs,\n            'children': children,\n        }"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 145,
      "kind": "function",
      "qualname": "src.mistune.directives.image.Figure.__call__",
      "span": [
        141,
        149
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"figure\", render_figure)\n            md.renderer.register(\"block_image\", render_block_image)\n            md.renderer.register(\"figcaption\", render_figcaption)\n            md.renderer.register(\"legend\", render_legend)",
      "old_code": "    def __call__(self, directive: \"BaseDirective\", md: \"Markdown\") -> None:\n        directive.register(self.NAME, self.parse)\n\n        assert md.renderer is not None\n        if md.renderer.NAME == 'html':\n            md.renderer.register('figure', render_figure)\n            md.renderer.register('block_image', render_block_image)\n            md.renderer.register('figcaption', render_figcaption)\n            md.renderer.register('legend', render_legend)"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 161,
      "kind": "function",
      "qualname": "src.mistune.directives.image.render_figure",
      "span": [
        152,
        168
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_figure(\n    self: Any,\n    text: str,\n    align: Optional[str] = None,\n    figwidth: Optional[str] = None,\n    figclass: Optional[str] = None,\n) -> str:\n    _cls = \"figure\"\n    if align:\n        _cls += \" align-\" + align\n    if figclass:\n        _cls += \" \" + figclass\n\n    html = '<figure class=\"' + _cls + '\"'\n    if figwidth:\n        html += ' style=\"width:' + figwidth + '\"'\n    return html + \">\\n\" + text + \"</figure>\\n\"",
      "old_code": "def render_figure(\n    self: Any,\n    text: str,\n    align: Optional[str] = None,\n    figwidth: Optional[str] = None,\n    figclass: Optional[str] = None,\n) -> str:\n    _cls = \"figure\"\n    if align:\n        _cls += ' align-' + align\n    if figclass:\n        _cls += ' ' + figclass\n\n    html = '<figure class=\"' + _cls + '\"'\n    if figwidth:\n        html += ' style=\"width:' + figwidth + '\"'\n    return html + '>\\n' + text + '</figure>\\n'"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 172,
      "kind": "function",
      "qualname": "src.mistune.directives.image.render_figcaption",
      "span": [
        171,
        172
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_figcaption(self: Any, text: str) -> str:\n    return \"<figcaption>\" + text + \"</figcaption>\\n\"",
      "old_code": "def render_figcaption(self: Any, text: str) -> str:\n    return '<figcaption>' + text + '</figcaption>\\n'"
    },
    {
      "path": "src/mistune/directives/image.py",
      "version": "new",
      "line": 176,
      "kind": "function",
      "qualname": "src.mistune.directives.image.render_legend",
      "span": [
        175,
        176
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_legend(self: Any, text: str) -> str:\n    return '<div class=\"legend\">\\n' + text + \"</div>\\n\"",
      "old_code": "def render_legend(self: Any, text: str) -> str:\n    return '<div class=\"legend\">\\n' + text + '</div>\\n'"
    },
    {
      "path": "src/mistune/directives/include.py",
      "version": "new",
      "line": 11,
      "kind": "module",
      "qualname": "src.mistune.directives.include",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/include.py",
      "version": "new",
      "line": 18,
      "kind": "function",
      "qualname": "src.mistune.directives.include.Include.parse",
      "span": [
        13,
        64
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:\n        source_file = state.env.get(\"__file__\")\n        if not source_file:\n            return {\"type\": \"block_error\", \"raw\": \"Missing source file\"}\n\n        encoding = \"utf-8\"\n        options = self.parse_options(m)\n        if options:\n            attrs = dict(options)\n            if \"encoding\" in attrs:\n                encoding = attrs[\"encoding\"]\n        else:\n            attrs = {}\n\n        relpath = self.parse_title(m)\n        dest = os.path.join(os.path.dirname(source_file), relpath)\n        dest = os.path.normpath(dest)\n\n        if dest == source_file:\n            return {\n                \"type\": \"block_error\",\n                \"raw\": \"Could not include self: \" + relpath,\n            }\n\n        if not os.path.isfile(dest):\n            return {\n                \"type\": \"block_error\",\n                \"raw\": \"Could not find file: \" + relpath,\n            }\n\n        with open(dest, \"rb\") as f:\n            content = f.read().decode(encoding)\n\n        ext = os.path.splitext(relpath)[1]\n        if ext in {\".md\", \".markdown\", \".mkd\"}:\n            new_state = block.state_cls()\n            new_state.env[\"__file__\"] = dest\n            new_state.process(content)\n            block.parse(new_state)\n            return new_state.tokens\n\n        elif ext in {\".html\", \".xhtml\", \".htm\"}:\n            return {\"type\": \"block_html\", \"raw\": content}\n\n        attrs[\"filepath\"] = dest\n        return {\n            \"type\": \"include\",\n            \"raw\": content,\n            \"attrs\": attrs,\n        }",
      "old_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:\n        source_file = state.env.get(\"__file__\")\n        if not source_file:\n            return {'type': 'block_error', 'raw': 'Missing source file'}\n\n        encoding = 'utf-8'\n        options = self.parse_options(m)\n        if options:\n            attrs = dict(options)\n            if 'encoding' in attrs:\n                encoding = attrs['encoding']\n        else:\n            attrs = {}\n\n        relpath = self.parse_title(m)\n        dest = os.path.join(os.path.dirname(source_file), relpath)\n        dest = os.path.normpath(dest)\n\n        if dest == source_file:\n            return {\n                'type': 'block_error',\n                'raw': 'Could not include self: ' + relpath,\n            }\n\n        if not os.path.isfile(dest):\n            return {\n                'type': 'block_error',\n                'raw': 'Could not find file: ' + relpath,\n            }\n\n        with open(dest, 'rb') as f:\n            content = f.read().decode(encoding)\n\n        ext = os.path.splitext(relpath)[1]\n        if ext in {'.md', '.markdown', '.mkd'}:\n            new_state = block.state_cls()\n            new_state.env['__file__'] = dest\n            new_state.process(content)\n            block.parse(new_state)\n            return new_state.tokens\n\n        elif ext in {'.html', '.xhtml', '.htm'}:\n            return {'type': 'block_html', 'raw': content}\n\n        attrs['filepath'] = dest\n        return {\n            'type': 'include',\n            'raw': content,\n            'attrs': attrs,\n        }"
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 2,
      "kind": "module",
      "qualname": "src.mistune.directives.toc",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 33,
      "kind": "function",
      "qualname": "src.mistune.directives.toc.TableOfContents.generate_heading_id",
      "span": [
        32,
        33
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def generate_heading_id(self, token: Dict[str, Any], index: int) -> str:\n        return \"toc_\" + str(index + 1)",
      "old_code": "    def generate_heading_id(self, token: Dict[str, Any], index: int) -> str:\n        return 'toc_' + str(index + 1)"
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 35,
      "kind": "function",
      "qualname": "src.mistune.directives.toc.TableOfContents.parse",
      "span": [
        35,
        59
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Dict[str, Any]:\n        title = self.parse_title(m)\n        options = self.parse_options(m)\n        if options:\n            d_options = dict(options)\n            collapse = \"collapse\" in d_options\n            min_level = _normalize_level(d_options, \"min-level\", self.min_level)\n            max_level = _normalize_level(d_options, \"max-level\", self.max_level)\n            if min_level < self.min_level:\n                raise ValueError(f'\"min-level\" option MUST be >= {self.min_level}')\n            if max_level > self.max_level:\n                raise ValueError(f'\"max-level\" option MUST be <= {self.max_level}')\n            if min_level > max_level:\n                raise ValueError('\"min-level\" option MUST be less than \"max-level\" option')\n        else:\n            collapse = False\n            min_level = self.min_level\n            max_level = self.max_level\n\n        attrs = {\n            \"min_level\": min_level,\n            \"max_level\": max_level,\n            \"collapse\": collapse,\n        }\n        return {\"type\": \"toc\", \"text\": title or \"\", \"attrs\": attrs}",
      "old_code": "    def parse(\n        self, block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n    ) -> Dict[str, Any]:\n        title = self.parse_title(m)\n        options = self.parse_options(m)\n        if options:\n            d_options = dict(options)\n            collapse = 'collapse' in d_options\n            min_level = _normalize_level(d_options, 'min-level', self.min_level)\n            max_level = _normalize_level(d_options, 'max-level', self.max_level)\n            if min_level < self.min_level:\n                raise ValueError(f'\"min-level\" option MUST be >= {self.min_level}')\n            if max_level > self.max_level:\n                raise ValueError(f'\"max-level\" option MUST be <= {self.max_level}')\n            if min_level > max_level:\n                raise ValueError('\"min-level\" option MUST be less than \"max-level\" option')\n        else:\n            collapse = False\n            min_level = self.min_level\n            max_level = self.max_level\n\n        attrs = {\n            'min_level': min_level,\n            'max_level': max_level,\n            'collapse': collapse,\n        }\n        return {'type': 'toc', 'text': title or '', 'attrs': attrs}"
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 66,
      "kind": "function",
      "qualname": "src.mistune.directives.toc.TableOfContents.toc_hook",
      "span": [
        61,
        82
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def toc_hook(self, md: \"Markdown\", state: \"BlockState\") -> None:\n        sections = []\n        headings = []\n\n        for tok in state.tokens:\n            if tok[\"type\"] == \"toc\":\n                sections.append(tok)\n            elif tok[\"type\"] == \"heading\":\n                headings.append(tok)\n\n        if sections:\n            toc_items = []\n            # adding ID for each heading\n            for i, tok in enumerate(headings):\n                tok[\"attrs\"][\"id\"] = self.generate_heading_id(tok, i)\n                toc_items.append(normalize_toc_item(md, tok))\n\n            for sec in sections:\n                _min = sec[\"attrs\"][\"min_level\"]\n                _max = sec[\"attrs\"][\"max_level\"]\n                toc = [item for item in toc_items if _min <= item[0] <= _max]\n                sec[\"attrs\"][\"toc\"] = toc",
      "old_code": "    def toc_hook(self, md: \"Markdown\", state: \"BlockState\") -> None:\n        sections = []\n        headings = []\n\n        for tok in state.tokens:\n            if tok['type'] == 'toc':\n                sections.append(tok)\n            elif tok['type'] == 'heading':\n                headings.append(tok)\n\n        if sections:\n            toc_items = []\n            # adding ID for each heading\n            for i, tok in enumerate(headings):\n                tok['attrs']['id'] = self.generate_heading_id(tok, i)\n                toc_items.append(normalize_toc_item(md, tok))\n\n            for sec in sections:\n                _min = sec['attrs']['min_level']\n                _max = sec['attrs']['max_level']\n                toc = [item for item in toc_items if _min <= item[0] <= _max]\n                sec['attrs']['toc'] = toc"
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 87,
      "kind": "function",
      "qualname": "src.mistune.directives.toc.TableOfContents.__call__",
      "span": [
        84,
        89
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, directive: BaseDirective, md: \"Markdown\") -> None:\n        if md.renderer and md.renderer.NAME == \"html\":\n            # only works with HTML renderer\n            directive.register(\"toc\", self.parse)\n            md.before_render_hooks.append(self.toc_hook)\n            md.renderer.register(\"toc\", render_html_toc)",
      "old_code": "    def __call__(self, directive: BaseDirective, md: \"Markdown\") -> None:\n        if md.renderer and md.renderer.NAME == \"html\":\n            # only works with HTML renderer\n            directive.register('toc', self.parse)\n            md.before_render_hooks.append(self.toc_hook)\n            md.renderer.register('toc', render_html_toc)"
    },
    {
      "path": "src/mistune/directives/toc.py",
      "version": "new",
      "line": 92,
      "kind": "function",
      "qualname": "src.mistune.directives.toc.render_html_toc",
      "span": [
        92,
        101
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_html_toc(renderer: \"BaseRenderer\", title: str, collapse: bool = False, **attrs: Any) -> str:\n    if not title:\n        title = \"Table of Contents\"\n    content = render_toc_ul(attrs[\"toc\"])\n\n    html = '<details class=\"toc\"'\n    if not collapse:\n        html += \" open\"\n    html += \">\\n<summary>\" + title + \"</summary>\\n\"\n    return html + content + \"</details>\\n\"",
      "old_code": "def render_html_toc(\n    renderer: \"BaseRenderer\", title: str, collapse: bool = False, **attrs: Any\n) -> str:\n    if not title:\n        title = 'Table of Contents'\n    content = render_toc_ul(attrs['toc'])\n\n    html = '<details class=\"toc\"'\n    if not collapse:\n        html += ' open'\n    html += '>\\n<summary>' + title + '</summary>\\n'\n    return html + content + '</details>\\n'"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 7,
      "kind": "module",
      "qualname": "src.mistune.helpers",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 107,
      "kind": "function",
      "qualname": "src.mistune.helpers.unescape_char",
      "span": [
        106,
        107
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def unescape_char(text: str) -> str:\n    return _ESCAPE_CHAR_RE.sub(r\"\\1\", text)",
      "old_code": "def unescape_char(text: str) -> str:\n    return _ESCAPE_CHAR_RE.sub(r'\\1', text)"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 122,
      "kind": "function",
      "qualname": "src.mistune.helpers.parse_link_text",
      "span": [
        110,
        133
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_link_text(src: str, pos: int) -> Union[Tuple[str, int], Tuple[None, None]]:\n    level = 1\n    found = False\n    start_pos = pos\n\n    while pos < len(src):\n        m = _INLINE_SQUARE_BRACKET_RE.search(src, pos)\n        if not m:\n            break\n\n        pos = m.end()\n        marker = m.group(0)\n        if marker == \"]\":\n            level -= 1\n            if level == 0:\n                found = True\n                break\n        else:\n            level += 1\n\n    if found:\n        text = src[start_pos : pos - 1]\n        return text, pos\n    return None, None",
      "old_code": "def parse_link_text(src: str, pos: int) -> Union[Tuple[str, int], Tuple[None, None]]:\n    level = 1\n    found = False\n    start_pos = pos\n\n    while pos < len(src):\n        m = _INLINE_SQUARE_BRACKET_RE.search(src, pos)\n        if not m:\n            break\n\n        pos = m.end()\n        marker = m.group(0)\n        if marker == ']':\n            level -= 1\n            if level == 0:\n                found = True\n                break\n        else:\n            level += 1\n\n    if found:\n        text = src[start_pos:pos-1]\n        return text, pos\n    return None, None"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 136,
      "kind": "function",
      "qualname": "src.mistune.helpers.parse_link_label",
      "span": [
        136,
        141
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_link_label(src: str, start_pos: int) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = _INLINE_LINK_LABEL_RE.match(src, start_pos)\n    if m:\n        label = m.group(0)[:-1]\n        return label, m.end()\n    return None, None",
      "old_code": "def parse_link_label(\n    src: str, start_pos: int\n) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = _INLINE_LINK_LABEL_RE.match(src, start_pos)\n    if m:\n        label = m.group(0)[:-1]\n        return label, m.end()\n    return None, None"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 144,
      "kind": "function",
      "qualname": "src.mistune.helpers.parse_link_href",
      "span": [
        144,
        166
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_link_href(src: str, start_pos: int, block: bool = False) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = LINK_BRACKET_START.match(src, start_pos)\n    if m:\n        start_pos = m.end() - 1\n        m = LINK_BRACKET_RE.match(src, start_pos)\n        if m:\n            return m.group(1), m.end()\n        return None, None\n\n    if block:\n        m = LINK_HREF_BLOCK_RE.match(src, start_pos)\n    else:\n        m = LINK_HREF_INLINE_RE.match(src, start_pos)\n\n    if not m:\n        return None, None\n\n    end_pos = m.end()\n    href = m.group(1)\n\n    if block and src[end_pos - 1] == href[-1]:\n        return href, end_pos\n    return href, end_pos - 1",
      "old_code": "def parse_link_href(\n    src: str, start_pos: int, block: bool = False\n) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = LINK_BRACKET_START.match(src, start_pos)\n    if m:\n        start_pos = m.end() - 1\n        m = LINK_BRACKET_RE.match(src, start_pos)\n        if m:\n            return m.group(1), m.end()\n        return None, None\n\n    if block:\n        m = LINK_HREF_BLOCK_RE.match(src, start_pos)\n    else:\n        m = LINK_HREF_INLINE_RE.match(src, start_pos)\n\n    if not m:\n        return None, None\n\n    end_pos = m.end()\n    href = m.group(1)\n\n    if block and src[end_pos - 1] == href[-1]:\n        return href, end_pos\n    return href, end_pos - 1"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 169,
      "kind": "function",
      "qualname": "src.mistune.helpers.parse_link_title",
      "span": [
        169,
        175
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_link_title(src: str, start_pos: int, max_pos: int) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = LINK_TITLE_RE.match(src, start_pos, max_pos)\n    if m:\n        title = m.group(1)[1:-1]\n        title = unescape_char(title)\n        return title, m.end()\n    return None, None",
      "old_code": "def parse_link_title(\n    src: str, start_pos: int, max_pos: int\n) -> Union[Tuple[str, int], Tuple[None, None]]:\n    m = LINK_TITLE_RE.match(src, start_pos, max_pos)\n    if m:\n        title = m.group(1)[1:-1]\n        title = unescape_char(title)\n        return title, m.end()\n    return None, None"
    },
    {
      "path": "src/mistune/helpers.py",
      "version": "new",
      "line": 178,
      "kind": "function",
      "qualname": "src.mistune.helpers.parse_link",
      "span": [
        178,
        193
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_link(src: str, pos: int) -> Union[Tuple[Dict[str, Any], int], Tuple[None, None]]:\n    href, href_pos = parse_link_href(src, pos)\n    if href is None:\n        return None, None\n    assert href_pos is not None\n    title, title_pos = parse_link_title(src, href_pos, len(src))\n    next_pos = title_pos or href_pos\n    m = PAREN_END_RE.match(src, next_pos)\n    if not m:\n        return None, None\n\n    href = unescape_char(href)\n    attrs = {\"url\": escape_url(href)}\n    if title:\n        attrs[\"title\"] = title\n    return attrs, m.end()",
      "old_code": "def parse_link(\n    src: str, pos: int\n) -> Union[Tuple[Dict[str, Any], int], Tuple[None, None]]:\n    href, href_pos = parse_link_href(src, pos)\n    if href is None:\n        return None, None\n    assert href_pos is not None\n    title, title_pos = parse_link_title(src, href_pos, len(src))\n    next_pos = title_pos or href_pos\n    m = PAREN_END_RE.match(src, next_pos)\n    if not m:\n        return None, None\n\n    href = unescape_char(href)\n    attrs = {'url': escape_url(href)}\n    if title:\n        attrs['title'] = title\n    return attrs, m.end()"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 24,
      "kind": "module",
      "qualname": "src.mistune.inline_parser",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 56,
      "kind": "class",
      "qualname": "src.mistune.inline_parser.InlineParser",
      "span": [
        51,
        406
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class InlineParser(Parser[InlineState]):\n    sc_flag = 0\n    state_cls = InlineState\n\n    #: linebreak leaves two spaces at the end of line\n    STD_LINEBREAK = r\"(?:\\\\| {2,})\\n\\s*\"\n\n    #: every new line becomes <br>\n    HARD_LINEBREAK = r\" *\\n\\s*\"\n\n    # we only need to find the start pattern of an inline token\n    SPECIFICATION = {\n        # e.g. \\`, \\$\n        \"escape\": r\"(?:\\\\\" + PUNCTUATION + \")+\",\n        # `code, ```code\n        \"codespan\": r\"`{1,}\",\n        # *w, **w, _w, __w\n        \"emphasis\": r\"\\*{1,3}(?=[^\\s*])|\\b_{1,3}(?=[^\\s_])\",\n        # [link], ![img]\n        \"link\": r\"!?\\[\",\n        # <https://example.com>. regex copied from commonmark.js\n        \"auto_link\": r\"<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>\",\n        \"auto_email\": AUTO_EMAIL,\n        \"inline_html\": INLINE_HTML,\n        \"linebreak\": STD_LINEBREAK,\n        \"softbreak\": HARD_LINEBREAK,\n        \"prec_auto_link\": r\"<[A-Za-z][A-Za-z\\d.+-]{1,31}:\",\n        \"prec_inline_html\": r\"</?\" + HTML_TAGNAME + r\"|<!|<\\?\",\n    }\n    DEFAULT_RULES = (\n        \"escape\",\n        \"codespan\",\n        \"emphasis\",\n        \"link\",\n        \"auto_link\",\n        \"auto_email\",\n        \"inline_html\",\n        \"linebreak\",\n    )\n\n    def __init__(self, hard_wrap: bool = False) -> None:\n        super(InlineParser, self).__init__()\n\n        self.hard_wrap = hard_wrap\n        # lazy add linebreak\n        if hard_wrap:\n            self.specification[\"linebreak\"] = self.HARD_LINEBREAK\n        else:\n            self.rules.append(\"softbreak\")\n\n        self._methods = {name: getattr(self, \"parse_\" + name) for name in self.rules}\n\n    def parse_escape(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        text = unescape_char(text)\n        state.append_token(\n            {\n                \"type\": \"text\",\n                \"raw\": text,\n            }\n        )\n        return m.end()\n\n    def parse_link(self, m: Match[str], state: InlineState) -> Optional[int]:\n        pos = m.end()\n\n        marker = m.group(0)\n        is_image = marker[0] == \"!\"\n        if is_image and state.in_image:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n        elif not is_image and state.in_link:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        text = None\n        label, end_pos = parse_link_label(state.src, pos)\n        if label is None:\n            text, end_pos = parse_link_text(state.src, pos)\n            if text is None:\n                return None\n\n        assert end_pos is not None\n\n        if text is None:\n            text = label\n\n        assert text is not None\n\n        if end_pos >= len(state.src) and label is None:\n            return None\n\n        rules = [\"codespan\", \"prec_auto_link\", \"prec_inline_html\"]\n        prec_pos = self.precedence_scan(m, state, end_pos, rules)\n        if prec_pos:\n            return prec_pos\n\n        if end_pos < len(state.src):\n            c = state.src[end_pos]\n            if c == \"(\":\n                # standard link [text](<url> \"title\")\n                attrs, pos2 = parse_link(state.src, end_pos + 1)\n                if pos2:\n                    token = self.__parse_link_token(is_image, text, attrs, state)\n                    state.append_token(token)\n                    return pos2\n\n            elif c == \"[\":\n                # standard ref link [text][label]\n                label2, pos2 = parse_link_label(state.src, end_pos + 1)\n                if pos2:\n                    end_pos = pos2\n                    if label2:\n                        label = label2\n\n        if label is None:\n            return None\n\n        ref_links = state.env.get(\"ref_links\")\n        if not ref_links:\n            return None\n\n        key = unikey(label)\n        env = ref_links.get(key)\n        if env:\n            attrs = {\"url\": env[\"url\"], \"title\": env.get(\"title\")}\n            token = self.__parse_link_token(is_image, text, attrs, state)\n            token[\"ref\"] = key\n            token[\"label\"] = label\n            state.append_token(token)\n            return end_pos\n        return None\n\n    def __parse_link_token(\n        self,\n        is_image: bool,\n        text: str,\n        attrs: Optional[Dict[str, Any]],\n        state: InlineState,\n    ) -> Dict[str, Any]:\n        new_state = state.copy()\n        new_state.src = text\n        if is_image:\n            new_state.in_image = True\n            token = {\n                \"type\": \"image\",\n                \"children\": self.render(new_state),\n                \"attrs\": attrs,\n            }\n        else:\n            new_state.in_link = True\n            token = {\n                \"type\": \"link\",\n                \"children\": self.render(new_state),\n                \"attrs\": attrs,\n            }\n        return token\n\n    def parse_auto_link(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        self._add_auto_link(text, text, state)\n        return pos\n\n    def parse_auto_email(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        url = \"mailto:\" + text\n        self._add_auto_link(url, text, state)\n        return pos\n\n    def _add_auto_link(self, url: str, text: str, state: InlineState) -> None:\n        state.append_token(\n            {\n                \"type\": \"link\",\n                \"children\": [{\"type\": \"text\", \"raw\": text}],\n                \"attrs\": {\"url\": escape_url(url)},\n            }\n        )\n\n    def parse_emphasis(self, m: Match[str], state: InlineState) -> int:\n        pos = m.end()\n\n        marker = m.group(0)\n        mlen = len(marker)\n        if mlen == 1 and state.in_emphasis:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n        elif mlen == 2 and state.in_strong:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        _end_re = EMPHASIS_END_RE[marker]\n        m1 = _end_re.search(state.src, pos)\n        if not m1:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        end_pos = m1.end()\n        text = state.src[pos : end_pos - mlen]\n\n        prec_pos = self.precedence_scan(m, state, end_pos)\n        if prec_pos:\n            return prec_pos\n\n        new_state = state.copy()\n        new_state.src = text\n        if mlen == 1:\n            new_state.in_emphasis = True\n            children = self.render(new_state)\n            state.append_token({\"type\": \"emphasis\", \"children\": children})\n        elif mlen == 2:\n            new_state.in_strong = True\n            children = self.render(new_state)\n            state.append_token({\"type\": \"strong\", \"children\": children})\n        else:\n            new_state.in_emphasis = True\n            new_state.in_strong = True\n\n            children = [{\"type\": \"strong\", \"children\": self.render(new_state)}]\n            state.append_token(\n                {\n                    \"type\": \"emphasis\",\n                    \"children\": children,\n                }\n            )\n        return end_pos\n\n    def parse_codespan(self, m: Match[str], state: InlineState) -> int:\n        marker = m.group(0)\n        # require same marker with same length at end\n\n        pattern = re.compile(r\"(.*?[^`])\" + marker + r\"(?!`)\", re.S)\n\n        pos = m.end()\n        m2 = pattern.match(state.src, pos)\n        if m2:\n            end_pos = m2.end()\n            code = m2.group(1)\n            # Line endings are treated like spaces\n            code = code.replace(\"\\n\", \" \")\n            if len(code.strip()):\n                if code.startswith(\" \") and code.endswith(\" \"):\n                    code = code[1:-1]\n            state.append_token({\"type\": \"codespan\", \"raw\": code})\n            return end_pos\n        else:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n    def parse_linebreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({\"type\": \"linebreak\"})\n        return m.end()\n\n    def parse_softbreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({\"type\": \"softbreak\"})\n        return m.end()\n\n    def parse_inline_html(self, m: Match[str], state: InlineState) -> int:\n        end_pos = m.end()\n        html = m.group(0)\n        state.append_token({\"type\": \"inline_html\", \"raw\": html})\n        if html.startswith((\"<a \", \"<a>\", \"<A \", \"<A>\")):\n            state.in_link = True\n        elif html.startswith((\"</a \", \"</a>\", \"</A \", \"</A>\")):\n            state.in_link = False\n        return end_pos\n\n    def process_text(self, text: str, state: InlineState) -> None:\n        state.append_token({\"type\": \"text\", \"raw\": text})\n\n    def parse(self, state: InlineState) -> List[Dict[str, Any]]:\n        pos = 0\n        sc = self.compile_sc()\n        while pos < len(state.src):\n            m = sc.search(state.src, pos)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > pos:\n                hole = state.src[pos:end_pos]\n                self.process_text(hole, state)\n\n            new_pos = self.parse_method(m, state)\n            if not new_pos:\n                # move cursor 1 character forward\n                pos = end_pos + 1\n                hole = state.src[end_pos:pos]\n                self.process_text(hole, state)\n            else:\n                pos = new_pos\n\n        if pos == 0:\n            # special case, just pure text\n            self.process_text(state.src, state)\n        elif pos < len(state.src):\n            self.process_text(state.src[pos:], state)\n        return state.tokens\n\n    def precedence_scan(\n        self,\n        m: Match[str],\n        state: InlineState,\n        end_pos: int,\n        rules: Optional[List[str]] = None,\n    ) -> Optional[int]:\n        if rules is None:\n            rules = [\"codespan\", \"link\", \"prec_auto_link\", \"prec_inline_html\"]\n\n        mark_pos = m.end()\n        sc = self.compile_sc(rules)\n        m1 = sc.search(state.src, mark_pos, end_pos)\n        if not m1:\n            return None\n\n        lastgroup = m1.lastgroup\n        if not lastgroup:\n            return None\n        rule_name = lastgroup.replace(\"prec_\", \"\")\n        sc = self.compile_sc([rule_name])\n        m2 = sc.match(state.src, m1.start())\n        if not m2:\n            return None\n\n        func = self._methods[rule_name]\n        new_state = state.copy()\n        new_state.src = state.src\n        m2_pos = func(m2, new_state)\n        if not m2_pos or m2_pos < end_pos:\n            return None\n\n        raw_text = state.src[m.start() : m2.start()]\n        state.append_token({\"type\": \"text\", \"raw\": raw_text})\n        for token in new_state.tokens:\n            state.append_token(token)\n        return m2_pos\n\n    def render(self, state: InlineState) -> List[Dict[str, Any]]:\n        self.parse(state)\n        return state.tokens\n\n    def __call__(self, s: str, env: MutableMapping[str, Any]) -> List[Dict[str, Any]]:\n        state = self.state_cls(env)\n        state.src = s\n        return self.render(state)",
      "old_code": "class InlineParser(Parser[InlineState]):\n    sc_flag = 0\n    state_cls = InlineState\n\n    #: linebreak leaves two spaces at the end of line\n    STD_LINEBREAK = r'(?:\\\\| {2,})\\n\\s*'\n\n    #: every new line becomes <br>\n    HARD_LINEBREAK = r' *\\n\\s*'\n\n    # we only need to find the start pattern of an inline token\n    SPECIFICATION = {\n        # e.g. \\`, \\$\n        'escape': r'(?:\\\\' + PUNCTUATION + ')+',\n\n        # `code, ```code\n        'codespan': r'`{1,}',\n\n        # *w, **w, _w, __w\n        'emphasis': r'\\*{1,3}(?=[^\\s*])|\\b_{1,3}(?=[^\\s_])',\n\n        # [link], ![img]\n        'link': r'!?\\[',\n\n        # <https://example.com>. regex copied from commonmark.js\n        'auto_link': r'<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>',\n        'auto_email': AUTO_EMAIL,\n\n        'inline_html': INLINE_HTML,\n\n        'linebreak': STD_LINEBREAK,\n        'softbreak': HARD_LINEBREAK,\n\n        'prec_auto_link': r'<[A-Za-z][A-Za-z\\d.+-]{1,31}:',\n        'prec_inline_html': r'</?' + HTML_TAGNAME + r'|<!|<\\?',\n    }\n    DEFAULT_RULES = (\n        'escape',\n        'codespan',\n        'emphasis',\n        'link',\n        'auto_link',\n        'auto_email',\n        'inline_html',\n        'linebreak',\n    )\n\n    def __init__(self, hard_wrap: bool = False) -> None:\n        super(InlineParser, self).__init__()\n\n        self.hard_wrap = hard_wrap\n        # lazy add linebreak\n        if hard_wrap:\n            self.specification['linebreak'] = self.HARD_LINEBREAK\n        else:\n            self.rules.append('softbreak')\n\n        self._methods = {\n            name: getattr(self, 'parse_' + name) for name in self.rules\n        }\n\n    def parse_escape(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        text = unescape_char(text)\n        state.append_token({\n            'type': 'text',\n            'raw': text,\n        })\n        return m.end()\n\n    def parse_link(self, m: Match[str], state: InlineState) -> Optional[int]:\n        pos = m.end()\n\n        marker = m.group(0)\n        is_image = marker[0] == '!'\n        if is_image and state.in_image:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n        elif not is_image and state.in_link:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        text = None\n        label, end_pos = parse_link_label(state.src, pos)\n        if label is None:\n            text, end_pos = parse_link_text(state.src, pos)\n            if text is None:\n                return None\n\n        assert end_pos is not None\n\n        if text is None:\n            text = label\n\n        assert text is not None\n\n        if end_pos >= len(state.src) and label is None:\n            return None\n\n        rules = ['codespan', 'prec_auto_link', 'prec_inline_html']\n        prec_pos = self.precedence_scan(m, state, end_pos, rules)\n        if prec_pos:\n            return prec_pos\n\n        if end_pos < len(state.src):\n            c = state.src[end_pos]\n            if c == '(':\n                # standard link [text](<url> \"title\")\n                attrs, pos2 = parse_link(state.src, end_pos + 1)\n                if pos2:\n                    token = self.__parse_link_token(is_image, text, attrs, state)\n                    state.append_token(token)\n                    return pos2\n\n            elif c == '[':\n                # standard ref link [text][label]\n                label2, pos2 = parse_link_label(state.src, end_pos + 1)\n                if pos2:\n                    end_pos = pos2\n                    if label2:\n                        label = label2\n\n        if label is None:\n            return None\n\n        ref_links = state.env.get('ref_links')\n        if not ref_links:\n            return None\n\n        key = unikey(label)\n        env = ref_links.get(key)\n        if env:\n            attrs = {'url': env['url'], 'title': env.get('title')}\n            token = self.__parse_link_token(is_image, text, attrs, state)\n            token['ref'] = key\n            token['label'] = label\n            state.append_token(token)\n            return end_pos\n        return None\n\n    def __parse_link_token(\n        self,\n        is_image: bool,\n        text: str,\n        attrs: Optional[Dict[str, Any]],\n        state: InlineState,\n    ) -> Dict[str, Any]:\n        new_state = state.copy()\n        new_state.src = text\n        if is_image:\n            new_state.in_image = True\n            token = {\n                'type': 'image',\n                'children': self.render(new_state),\n                'attrs': attrs,\n            }\n        else:\n            new_state.in_link = True\n            token = {\n                'type': 'link',\n                'children': self.render(new_state),\n                'attrs': attrs,\n            }\n        return token\n\n    def parse_auto_link(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        self._add_auto_link(text, text, state)\n        return pos\n\n    def parse_auto_email(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        url = 'mailto:' + text\n        self._add_auto_link(url, text, state)\n        return pos\n\n    def _add_auto_link(self, url: str, text: str, state: InlineState) -> None:\n        state.append_token({\n            'type': 'link',\n            'children': [{'type': 'text', 'raw': text}],\n            'attrs': {'url': escape_url(url)},\n        })\n\n    def parse_emphasis(self, m: Match[str], state: InlineState) -> int:\n        pos = m.end()\n\n        marker = m.group(0)\n        mlen = len(marker)\n        if mlen == 1 and state.in_emphasis:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n        elif mlen == 2 and state.in_strong:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        _end_re = EMPHASIS_END_RE[marker]\n        m1 = _end_re.search(state.src, pos)\n        if not m1:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        end_pos = m1.end()\n        text = state.src[pos:end_pos-mlen]\n\n        prec_pos = self.precedence_scan(m, state, end_pos)\n        if prec_pos:\n            return prec_pos\n\n        new_state = state.copy()\n        new_state.src = text\n        if mlen == 1:\n            new_state.in_emphasis = True\n            children = self.render(new_state)\n            state.append_token({'type': 'emphasis', 'children': children})\n        elif mlen == 2:\n            new_state.in_strong = True\n            children = self.render(new_state)\n            state.append_token({'type': 'strong', 'children': children})\n        else:\n            new_state.in_emphasis = True\n            new_state.in_strong = True\n\n            children = [{\n                'type': 'strong',\n                'children': self.render(new_state)\n            }]\n            state.append_token({\n                'type': 'emphasis',\n                'children': children,\n            })\n        return end_pos\n\n    def parse_codespan(self, m: Match[str], state: InlineState) -> int:\n        marker = m.group(0)\n        # require same marker with same length at end\n\n        pattern = re.compile(r'(.*?[^`])' + marker + r'(?!`)', re.S)\n\n        pos = m.end()\n        m2 = pattern.match(state.src, pos)\n        if m2:\n            end_pos = m2.end()\n            code = m2.group(1)\n            # Line endings are treated like spaces\n            code = code.replace('\\n', ' ')\n            if len(code.strip()):\n                if code.startswith(' ') and code.endswith(' '):\n                    code = code[1:-1]\n            state.append_token({'type': 'codespan', 'raw': code})\n            return end_pos\n        else:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n    def parse_linebreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({'type': 'linebreak'})\n        return m.end()\n\n    def parse_softbreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({'type': 'softbreak'})\n        return m.end()\n\n    def parse_inline_html(self, m: Match[str], state: InlineState) -> int:\n        end_pos = m.end()\n        html = m.group(0)\n        state.append_token({'type': 'inline_html', 'raw': html})\n        if html.startswith(('<a ', '<a>', '<A ', '<A>')):\n            state.in_link = True\n        elif html.startswith(('</a ', '</a>', '</A ', '</A>')):\n            state.in_link = False\n        return end_pos\n\n    def process_text(self, text: str, state: InlineState) -> None:\n        state.append_token({'type': 'text', 'raw': text})\n\n    def parse(self, state: InlineState) -> List[Dict[str, Any]]:\n        pos = 0\n        sc = self.compile_sc()\n        while pos < len(state.src):\n            m = sc.search(state.src, pos)\n            if not m:\n                break\n\n            end_pos = m.start()\n            if end_pos > pos:\n                hole = state.src[pos:end_pos]\n                self.process_text(hole, state)\n\n            new_pos = self.parse_method(m, state)\n            if not new_pos:\n                # move cursor 1 character forward\n                pos = end_pos + 1\n                hole = state.src[end_pos:pos]\n                self.process_text(hole, state)\n            else:\n                pos = new_pos\n\n        if pos == 0:\n            # special case, just pure text\n            self.process_text(state.src, state)\n        elif pos < len(state.src):\n            self.process_text(state.src[pos:], state)\n        return state.tokens\n\n    def precedence_scan(\n        self,\n        m: Match[str],\n        state: InlineState,\n        end_pos: int,\n        rules: Optional[List[str]] = None,\n    ) -> Optional[int]:\n        if rules is None:\n            rules = ['codespan', 'link', 'prec_auto_link', 'prec_inline_html']\n\n        mark_pos = m.end()\n        sc = self.compile_sc(rules)\n        m1 = sc.search(state.src, mark_pos, end_pos)\n        if not m1:\n            return None\n\n        lastgroup = m1.lastgroup\n        if not lastgroup:\n            return None\n        rule_name = lastgroup.replace(\"prec_\", \"\")\n        sc = self.compile_sc([rule_name])\n        m2 = sc.match(state.src, m1.start())\n        if not m2:\n            return None\n\n        func = self._methods[rule_name]\n        new_state = state.copy()\n        new_state.src = state.src\n        m2_pos = func(m2, new_state)\n        if not m2_pos or m2_pos < end_pos:\n            return None\n\n        raw_text = state.src[m.start():m2.start()]\n        state.append_token({'type': 'text', 'raw': raw_text})\n        for token in new_state.tokens:\n            state.append_token(token)\n        return m2_pos\n\n    def render(self, state: InlineState) -> List[Dict[str, Any]]:\n        self.parse(state)\n        return state.tokens\n\n    def __call__(self, s: str, env: MutableMapping[str, Any]) -> List[Dict[str, Any]]:\n        state = self.state_cls(env)\n        state.src = s\n        return self.render(state)"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 97,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.__init__",
      "span": [
        91,
        101
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, hard_wrap: bool = False) -> None:\n        super(InlineParser, self).__init__()\n\n        self.hard_wrap = hard_wrap\n        # lazy add linebreak\n        if hard_wrap:\n            self.specification[\"linebreak\"] = self.HARD_LINEBREAK\n        else:\n            self.rules.append(\"softbreak\")\n\n        self._methods = {name: getattr(self, \"parse_\" + name) for name in self.rules}",
      "old_code": "    def __init__(self, hard_wrap: bool = False) -> None:\n        super(InlineParser, self).__init__()\n\n        self.hard_wrap = hard_wrap\n        # lazy add linebreak\n        if hard_wrap:\n            self.specification['linebreak'] = self.HARD_LINEBREAK\n        else:\n            self.rules.append('softbreak')\n\n        self._methods = {\n            name: getattr(self, 'parse_' + name) for name in self.rules\n        }"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 106,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_escape",
      "span": [
        103,
        112
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_escape(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        text = unescape_char(text)\n        state.append_token(\n            {\n                \"type\": \"text\",\n                \"raw\": text,\n            }\n        )\n        return m.end()",
      "old_code": "    def parse_escape(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        text = unescape_char(text)\n        state.append_token({\n            'type': 'text',\n            'raw': text,\n        })\n        return m.end()"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 118,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_link",
      "span": [
        114,
        182
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_link(self, m: Match[str], state: InlineState) -> Optional[int]:\n        pos = m.end()\n\n        marker = m.group(0)\n        is_image = marker[0] == \"!\"\n        if is_image and state.in_image:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n        elif not is_image and state.in_link:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        text = None\n        label, end_pos = parse_link_label(state.src, pos)\n        if label is None:\n            text, end_pos = parse_link_text(state.src, pos)\n            if text is None:\n                return None\n\n        assert end_pos is not None\n\n        if text is None:\n            text = label\n\n        assert text is not None\n\n        if end_pos >= len(state.src) and label is None:\n            return None\n\n        rules = [\"codespan\", \"prec_auto_link\", \"prec_inline_html\"]\n        prec_pos = self.precedence_scan(m, state, end_pos, rules)\n        if prec_pos:\n            return prec_pos\n\n        if end_pos < len(state.src):\n            c = state.src[end_pos]\n            if c == \"(\":\n                # standard link [text](<url> \"title\")\n                attrs, pos2 = parse_link(state.src, end_pos + 1)\n                if pos2:\n                    token = self.__parse_link_token(is_image, text, attrs, state)\n                    state.append_token(token)\n                    return pos2\n\n            elif c == \"[\":\n                # standard ref link [text][label]\n                label2, pos2 = parse_link_label(state.src, end_pos + 1)\n                if pos2:\n                    end_pos = pos2\n                    if label2:\n                        label = label2\n\n        if label is None:\n            return None\n\n        ref_links = state.env.get(\"ref_links\")\n        if not ref_links:\n            return None\n\n        key = unikey(label)\n        env = ref_links.get(key)\n        if env:\n            attrs = {\"url\": env[\"url\"], \"title\": env.get(\"title\")}\n            token = self.__parse_link_token(is_image, text, attrs, state)\n            token[\"ref\"] = key\n            token[\"label\"] = label\n            state.append_token(token)\n            return end_pos\n        return None",
      "old_code": "    def parse_link(self, m: Match[str], state: InlineState) -> Optional[int]:\n        pos = m.end()\n\n        marker = m.group(0)\n        is_image = marker[0] == '!'\n        if is_image and state.in_image:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n        elif not is_image and state.in_link:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        text = None\n        label, end_pos = parse_link_label(state.src, pos)\n        if label is None:\n            text, end_pos = parse_link_text(state.src, pos)\n            if text is None:\n                return None\n\n        assert end_pos is not None\n\n        if text is None:\n            text = label\n\n        assert text is not None\n\n        if end_pos >= len(state.src) and label is None:\n            return None\n\n        rules = ['codespan', 'prec_auto_link', 'prec_inline_html']\n        prec_pos = self.precedence_scan(m, state, end_pos, rules)\n        if prec_pos:\n            return prec_pos\n\n        if end_pos < len(state.src):\n            c = state.src[end_pos]\n            if c == '(':\n                # standard link [text](<url> \"title\")\n                attrs, pos2 = parse_link(state.src, end_pos + 1)\n                if pos2:\n                    token = self.__parse_link_token(is_image, text, attrs, state)\n                    state.append_token(token)\n                    return pos2\n\n            elif c == '[':\n                # standard ref link [text][label]\n                label2, pos2 = parse_link_label(state.src, end_pos + 1)\n                if pos2:\n                    end_pos = pos2\n                    if label2:\n                        label = label2\n\n        if label is None:\n            return None\n\n        ref_links = state.env.get('ref_links')\n        if not ref_links:\n            return None\n\n        key = unikey(label)\n        env = ref_links.get(key)\n        if env:\n            attrs = {'url': env['url'], 'title': env.get('title')}\n            token = self.__parse_link_token(is_image, text, attrs, state)\n            token['ref'] = key\n            token['label'] = label\n            state.append_token(token)\n            return end_pos\n        return None"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 196,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.__parse_link_token",
      "span": [
        184,
        207
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __parse_link_token(\n        self,\n        is_image: bool,\n        text: str,\n        attrs: Optional[Dict[str, Any]],\n        state: InlineState,\n    ) -> Dict[str, Any]:\n        new_state = state.copy()\n        new_state.src = text\n        if is_image:\n            new_state.in_image = True\n            token = {\n                \"type\": \"image\",\n                \"children\": self.render(new_state),\n                \"attrs\": attrs,\n            }\n        else:\n            new_state.in_link = True\n            token = {\n                \"type\": \"link\",\n                \"children\": self.render(new_state),\n                \"attrs\": attrs,\n            }\n        return token",
      "old_code": "    def __parse_link_token(\n        self,\n        is_image: bool,\n        text: str,\n        attrs: Optional[Dict[str, Any]],\n        state: InlineState,\n    ) -> Dict[str, Any]:\n        new_state = state.copy()\n        new_state.src = text\n        if is_image:\n            new_state.in_image = True\n            token = {\n                'type': 'image',\n                'children': self.render(new_state),\n                'attrs': attrs,\n            }\n        else:\n            new_state.in_link = True\n            token = {\n                'type': 'link',\n                'children': self.render(new_state),\n                'attrs': attrs,\n            }\n        return token"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 228,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_auto_email",
      "span": [
        220,
        230
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_auto_email(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        url = \"mailto:\" + text\n        self._add_auto_link(url, text, state)\n        return pos",
      "old_code": "    def parse_auto_email(self, m: Match[str], state: InlineState) -> int:\n        text = m.group(0)\n        pos = m.end()\n        if state.in_link:\n            self.process_text(text, state)\n            return pos\n\n        text = text[1:-1]\n        url = 'mailto:' + text\n        self._add_auto_link(url, text, state)\n        return pos"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 233,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser._add_auto_link",
      "span": [
        232,
        239
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _add_auto_link(self, url: str, text: str, state: InlineState) -> None:\n        state.append_token(\n            {\n                \"type\": \"link\",\n                \"children\": [{\"type\": \"text\", \"raw\": text}],\n                \"attrs\": {\"url\": escape_url(url)},\n            }\n        )",
      "old_code": "    def _add_auto_link(self, url: str, text: str, state: InlineState) -> None:\n        state.append_token({\n            'type': 'link',\n            'children': [{'type': 'text', 'raw': text}],\n            'attrs': {'url': escape_url(url)},\n        })"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 247,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_emphasis",
      "span": [
        241,
        287
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_emphasis(self, m: Match[str], state: InlineState) -> int:\n        pos = m.end()\n\n        marker = m.group(0)\n        mlen = len(marker)\n        if mlen == 1 and state.in_emphasis:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n        elif mlen == 2 and state.in_strong:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        _end_re = EMPHASIS_END_RE[marker]\n        m1 = _end_re.search(state.src, pos)\n        if not m1:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos\n\n        end_pos = m1.end()\n        text = state.src[pos : end_pos - mlen]\n\n        prec_pos = self.precedence_scan(m, state, end_pos)\n        if prec_pos:\n            return prec_pos\n\n        new_state = state.copy()\n        new_state.src = text\n        if mlen == 1:\n            new_state.in_emphasis = True\n            children = self.render(new_state)\n            state.append_token({\"type\": \"emphasis\", \"children\": children})\n        elif mlen == 2:\n            new_state.in_strong = True\n            children = self.render(new_state)\n            state.append_token({\"type\": \"strong\", \"children\": children})\n        else:\n            new_state.in_emphasis = True\n            new_state.in_strong = True\n\n            children = [{\"type\": \"strong\", \"children\": self.render(new_state)}]\n            state.append_token(\n                {\n                    \"type\": \"emphasis\",\n                    \"children\": children,\n                }\n            )\n        return end_pos",
      "old_code": "    def parse_emphasis(self, m: Match[str], state: InlineState) -> int:\n        pos = m.end()\n\n        marker = m.group(0)\n        mlen = len(marker)\n        if mlen == 1 and state.in_emphasis:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n        elif mlen == 2 and state.in_strong:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        _end_re = EMPHASIS_END_RE[marker]\n        m1 = _end_re.search(state.src, pos)\n        if not m1:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos\n\n        end_pos = m1.end()\n        text = state.src[pos:end_pos-mlen]\n\n        prec_pos = self.precedence_scan(m, state, end_pos)\n        if prec_pos:\n            return prec_pos\n\n        new_state = state.copy()\n        new_state.src = text\n        if mlen == 1:\n            new_state.in_emphasis = True\n            children = self.render(new_state)\n            state.append_token({'type': 'emphasis', 'children': children})\n        elif mlen == 2:\n            new_state.in_strong = True\n            children = self.render(new_state)\n            state.append_token({'type': 'strong', 'children': children})\n        else:\n            new_state.in_emphasis = True\n            new_state.in_strong = True\n\n            children = [{\n                'type': 'strong',\n                'children': self.render(new_state)\n            }]\n            state.append_token({\n                'type': 'emphasis',\n                'children': children,\n            })\n        return end_pos"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 293,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_codespan",
      "span": [
        289,
        309
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_codespan(self, m: Match[str], state: InlineState) -> int:\n        marker = m.group(0)\n        # require same marker with same length at end\n\n        pattern = re.compile(r\"(.*?[^`])\" + marker + r\"(?!`)\", re.S)\n\n        pos = m.end()\n        m2 = pattern.match(state.src, pos)\n        if m2:\n            end_pos = m2.end()\n            code = m2.group(1)\n            # Line endings are treated like spaces\n            code = code.replace(\"\\n\", \" \")\n            if len(code.strip()):\n                if code.startswith(\" \") and code.endswith(\" \"):\n                    code = code[1:-1]\n            state.append_token({\"type\": \"codespan\", \"raw\": code})\n            return end_pos\n        else:\n            state.append_token({\"type\": \"text\", \"raw\": marker})\n            return pos",
      "old_code": "    def parse_codespan(self, m: Match[str], state: InlineState) -> int:\n        marker = m.group(0)\n        # require same marker with same length at end\n\n        pattern = re.compile(r'(.*?[^`])' + marker + r'(?!`)', re.S)\n\n        pos = m.end()\n        m2 = pattern.match(state.src, pos)\n        if m2:\n            end_pos = m2.end()\n            code = m2.group(1)\n            # Line endings are treated like spaces\n            code = code.replace('\\n', ' ')\n            if len(code.strip()):\n                if code.startswith(' ') and code.endswith(' '):\n                    code = code[1:-1]\n            state.append_token({'type': 'codespan', 'raw': code})\n            return end_pos\n        else:\n            state.append_token({'type': 'text', 'raw': marker})\n            return pos"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 312,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_linebreak",
      "span": [
        311,
        313
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_linebreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({\"type\": \"linebreak\"})\n        return m.end()",
      "old_code": "    def parse_linebreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({'type': 'linebreak'})\n        return m.end()"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 316,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_softbreak",
      "span": [
        315,
        317
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_softbreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({\"type\": \"softbreak\"})\n        return m.end()",
      "old_code": "    def parse_softbreak(self, m: Match[str], state: InlineState) -> int:\n        state.append_token({'type': 'softbreak'})\n        return m.end()"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 322,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.parse_inline_html",
      "span": [
        319,
        327
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse_inline_html(self, m: Match[str], state: InlineState) -> int:\n        end_pos = m.end()\n        html = m.group(0)\n        state.append_token({\"type\": \"inline_html\", \"raw\": html})\n        if html.startswith((\"<a \", \"<a>\", \"<A \", \"<A>\")):\n            state.in_link = True\n        elif html.startswith((\"</a \", \"</a>\", \"</A \", \"</A>\")):\n            state.in_link = False\n        return end_pos",
      "old_code": "    def parse_inline_html(self, m: Match[str], state: InlineState) -> int:\n        end_pos = m.end()\n        html = m.group(0)\n        state.append_token({'type': 'inline_html', 'raw': html})\n        if html.startswith(('<a ', '<a>', '<A ', '<A>')):\n            state.in_link = True\n        elif html.startswith(('</a ', '</a>', '</A ', '</A>')):\n            state.in_link = False\n        return end_pos"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 330,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.process_text",
      "span": [
        329,
        330
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def process_text(self, text: str, state: InlineState) -> None:\n        state.append_token({\"type\": \"text\", \"raw\": text})",
      "old_code": "    def process_text(self, text: str, state: InlineState) -> None:\n        state.append_token({'type': 'text', 'raw': text})"
    },
    {
      "path": "src/mistune/inline_parser.py",
      "version": "new",
      "line": 369,
      "kind": "function",
      "qualname": "src.mistune.inline_parser.InlineParser.precedence_scan",
      "span": [
        361,
        397
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def precedence_scan(\n        self,\n        m: Match[str],\n        state: InlineState,\n        end_pos: int,\n        rules: Optional[List[str]] = None,\n    ) -> Optional[int]:\n        if rules is None:\n            rules = [\"codespan\", \"link\", \"prec_auto_link\", \"prec_inline_html\"]\n\n        mark_pos = m.end()\n        sc = self.compile_sc(rules)\n        m1 = sc.search(state.src, mark_pos, end_pos)\n        if not m1:\n            return None\n\n        lastgroup = m1.lastgroup\n        if not lastgroup:\n            return None\n        rule_name = lastgroup.replace(\"prec_\", \"\")\n        sc = self.compile_sc([rule_name])\n        m2 = sc.match(state.src, m1.start())\n        if not m2:\n            return None\n\n        func = self._methods[rule_name]\n        new_state = state.copy()\n        new_state.src = state.src\n        m2_pos = func(m2, new_state)\n        if not m2_pos or m2_pos < end_pos:\n            return None\n\n        raw_text = state.src[m.start() : m2.start()]\n        state.append_token({\"type\": \"text\", \"raw\": raw_text})\n        for token in new_state.tokens:\n            state.append_token(token)\n        return m2_pos",
      "old_code": "    def precedence_scan(\n        self,\n        m: Match[str],\n        state: InlineState,\n        end_pos: int,\n        rules: Optional[List[str]] = None,\n    ) -> Optional[int]:\n        if rules is None:\n            rules = ['codespan', 'link', 'prec_auto_link', 'prec_inline_html']\n\n        mark_pos = m.end()\n        sc = self.compile_sc(rules)\n        m1 = sc.search(state.src, mark_pos, end_pos)\n        if not m1:\n            return None\n\n        lastgroup = m1.lastgroup\n        if not lastgroup:\n            return None\n        rule_name = lastgroup.replace(\"prec_\", \"\")\n        sc = self.compile_sc([rule_name])\n        m2 = sc.match(state.src, m1.start())\n        if not m2:\n            return None\n\n        func = self._methods[rule_name]\n        new_state = state.copy()\n        new_state.src = state.src\n        m2_pos = func(m2, new_state)\n        if not m2_pos or m2_pos < end_pos:\n            return None\n\n        raw_text = state.src[m.start():m2.start()]\n        state.append_token({'type': 'text', 'raw': raw_text})\n        for token in new_state.tokens:\n            state.append_token(token)\n        return m2_pos"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 12,
      "kind": "module",
      "qualname": "src.mistune.list_parser",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 22,
      "kind": "function",
      "qualname": "src.mistune.list_parser.parse_list",
      "span": [
        20,
        74
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n    text = m.group(\"list_3\")\n    if not text.strip():\n        # Example 285\n        # an empty list item cannot interrupt a paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n    marker = m.group(\"list_2\")\n    ordered = len(marker) > 1\n    depth = state.depth()\n    token: Dict[str, Any] = {\n        \"type\": \"list\",\n        \"children\": [],\n        \"tight\": True,\n        \"bullet\": marker[-1],\n        \"attrs\": {\n            \"depth\": depth,\n            \"ordered\": ordered,\n        },\n    }\n    if ordered:\n        start = int(marker[:-1])\n        if start != 1:\n            # Example 304\n            # we allow only lists starting with 1 to interrupt paragraphs\n            end_pos = state.append_paragraph()\n            if end_pos:\n                return end_pos\n            token[\"attrs\"][\"start\"] = start\n\n    state.cursor = m.end() + 1\n    groups: Optional[Tuple[str, str, str]] = (m.group(\"list_1\"), marker, text)\n\n    if depth >= block.max_nested_level - 1:\n        rules = list(block.list_rules)\n        rules.remove(\"list\")\n    else:\n        rules = block.list_rules\n\n    bullet = _get_list_bullet(marker[-1])\n    while groups:\n        groups = _parse_list_item(block, bullet, groups, token, state, rules)\n\n    end_pos = token.pop(\"_end_pos\", None)\n    _transform_tight_list(token)\n    if end_pos:\n        index = token.pop(\"_tok_index\")\n        state.tokens.insert(index, token)\n        return end_pos\n\n    state.append_token(token)\n    return state.cursor",
      "old_code": "def parse_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n    text = m.group('list_3')\n    if not text.strip():\n        # Example 285\n        # an empty list item cannot interrupt a paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n    marker = m.group('list_2')\n    ordered = len(marker) > 1\n    depth = state.depth()\n    token: Dict[str, Any] = {\n        'type': 'list',\n        'children': [],\n        'tight': True,\n        'bullet': marker[-1],\n        'attrs': {\n            'depth': depth,\n            'ordered': ordered,\n        },\n    }\n    if ordered:\n        start = int(marker[:-1])\n        if start != 1:\n            # Example 304\n            # we allow only lists starting with 1 to interrupt paragraphs\n            end_pos = state.append_paragraph()\n            if end_pos:\n                return end_pos\n            token['attrs']['start'] = start\n\n    state.cursor = m.end() + 1\n    groups: Optional[Tuple[str, str, str]] = (m.group(\"list_1\"), marker, text)\n\n    if depth >= block.max_nested_level - 1:\n        rules = list(block.list_rules)\n        rules.remove('list')\n    else:\n        rules = block.list_rules\n\n    bullet = _get_list_bullet(marker[-1])\n    while groups:\n        groups = _parse_list_item(block, bullet, groups, token, state, rules)\n\n    end_pos = token.pop('_end_pos', None)\n    _transform_tight_list(token)\n    if end_pos:\n        index = token.pop('_tok_index')\n        state.tokens.insert(index, token)\n        return end_pos\n\n    state.append_token(token)\n    return state.cursor"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 78,
      "kind": "function",
      "qualname": "src.mistune.list_parser._transform_tight_list",
      "span": [
        77,
        85
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _transform_tight_list(token: Dict[str, Any]) -> None:\n    if token[\"tight\"]:\n        # reset tight list item\n        for list_item in token[\"children\"]:\n            for tok in list_item[\"children\"]:\n                if tok[\"type\"] == \"paragraph\":\n                    tok[\"type\"] = \"block_text\"\n                elif tok[\"type\"] == \"list\":\n                    _transform_tight_list(tok)",
      "old_code": "def _transform_tight_list(token: Dict[str, Any]) -> None:\n    if token['tight']:\n        # reset tight list item\n        for list_item in token['children']:\n            for tok in list_item['children']:\n                if tok['type'] == 'paragraph':\n                    tok['type'] = 'block_text'\n                elif tok['type'] == 'list':\n                    _transform_tight_list(tok)"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 102,
      "kind": "function",
      "qualname": "src.mistune.list_parser._parse_list_item",
      "span": [
        88,
        188
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: Tuple[str, str, str],\n    token: Dict[str, Any],\n    state: \"BlockState\",\n    rules: List[str],\n) -> Optional[Tuple[str, str, str]]:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    pairs = [\n        (\"thematic_break\", block.specification[\"thematic_break\"]),\n        (\"fenced_code\", block.specification[\"fenced_code\"]),\n        (\"atx_heading\", block.specification[\"atx_heading\"]),\n        (\"block_quote\", block.specification[\"block_quote\"]),\n        (\"block_html\", block.specification[\"block_html\"]),\n        (\"list\", block.specification[\"list\"]),\n    ]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace(\"3\", _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, (\"list_item\", item_pattern))\n    regex = \"|\".join(r\"(?P<%s>(?<=\\n)%s)\" % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = \"\"\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = \" \" * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += \"\\n\"\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == \"list_item\":\n                if prev_blank_line:\n                    token[\"tight\"] = False\n                next_group = (m.group(\"listitem_1\"), m.group(\"listitem_2\"), m.group(\"listitem_3\"))\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == \"list\":\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token[\"_tok_index\"] = tok_index\n                token[\"_end_pos\"] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token[\"tight\"] and _is_loose_list(child.tokens):\n        token[\"tight\"] = False\n\n    token[\"children\"].append(\n        {\n            \"type\": \"list_item\",\n            \"children\": child.tokens,\n        }\n    )\n    if next_group:\n        return next_group\n\n    return None",
      "old_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: Tuple[str, str, str],\n    token: Dict[str, Any],\n    state: \"BlockState\",\n    rules: List[str],\n) -> Optional[Tuple[str, str, str]]:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    pairs = [\n        ('thematic_break', block.specification['thematic_break']),\n        ('fenced_code', block.specification['fenced_code']),\n        ('atx_heading', block.specification['atx_heading']),\n        ('block_quote', block.specification['block_quote']),\n        ('block_html', block.specification['block_html']),\n        ('list', block.specification['list']),\n    ]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace('3', _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, ('list_item', item_pattern))\n    regex = '|'.join(r'(?P<%s>(?<=\\n)%s)' % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = ''\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = ' ' * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += '\\n'\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == 'list_item':\n                if prev_blank_line:\n                    token['tight'] = False\n                next_group = (\n                    m.group('listitem_1'),\n                    m.group('listitem_2'),\n                    m.group('listitem_3')\n                )\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == 'list':\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token['_tok_index'] = tok_index\n                token['_end_pos'] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token['tight'] and _is_loose_list(child.tokens):\n        token['tight'] = False\n\n    token['children'].append({\n        'type': 'list_item',\n        'children': child.tokens,\n    })\n    if next_group:\n        return next_group\n\n    return None"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 192,
      "kind": "function",
      "qualname": "src.mistune.list_parser._get_list_bullet",
      "span": [
        191,
        202
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _get_list_bullet(c: str) -> str:\n    if c == \".\":\n        bullet = r\"\\d{0,9}\\.\"\n    elif c == \")\":\n        bullet = r\"\\d{0,9}\\)\"\n    elif c == \"*\":\n        bullet = r\"\\*\"\n    elif c == \"+\":\n        bullet = r\"\\+\"\n    else:\n        bullet = \"-\"\n    return bullet",
      "old_code": "def _get_list_bullet(c: str) -> str:\n    if c == '.':\n        bullet = r'\\d{0,9}\\.'\n    elif c == ')':\n        bullet = r'\\d{0,9}\\)'\n    elif c == '*':\n        bullet = r'\\*'\n    elif c == '+':\n        bullet = r'\\+'\n    else:\n        bullet = '-'\n    return bullet"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 209,
      "kind": "function",
      "qualname": "src.mistune.list_parser._compile_list_item_pattern",
      "span": [
        205,
        212
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _compile_list_item_pattern(bullet: str, leading_width: int) -> str:\n    if leading_width > 3:\n        leading_width = 3\n    return (\n        r\"^(?P<listitem_1> {0,\" + str(leading_width) + \"})\"\n        r\"(?P<listitem_2>\" + bullet + \")\"\n        r\"(?P<listitem_3>[ \\t]*|[ \\t][^\\n]+)$\"\n    )",
      "old_code": "def _compile_list_item_pattern(bullet: str, leading_width: int) -> str:\n    if leading_width > 3:\n        leading_width = 3\n    return (\n        r'^(?P<listitem_1> {0,' + str(leading_width) + '})'\n        r'(?P<listitem_2>' + bullet + ')'\n        r'(?P<listitem_3>[ \\t]*|[ \\t][^\\n]+)$'\n    )"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 222,
      "kind": "function",
      "qualname": "src.mistune.list_parser._compile_continue_width",
      "span": [
        215,
        233
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _compile_continue_width(text: str, leading_width: int) -> Tuple[str, int]:\n    text = expand_leading_tab(text, 3)\n    text = expand_tab(text)\n\n    m2 = _LINE_HAS_TEXT.match(text)\n    if m2:\n        # indent code, startswith 5 spaces\n        if text.startswith(\"     \"):\n            space_width = 1\n        else:\n            space_width = len(m2.group(1))\n\n        text = text[space_width:] + \"\\n\"\n    else:\n        space_width = 1\n        text = \"\"\n\n    continue_width = leading_width + space_width\n    return text, continue_width",
      "old_code": "def _compile_continue_width(text: str, leading_width: int) -> Tuple[str, int]:\n    text = expand_leading_tab(text, 3)\n    text = expand_tab(text)\n\n    m2 = _LINE_HAS_TEXT.match(text)\n    if m2:\n        # indent code, startswith 5 spaces\n        if text.startswith('     '):\n            space_width = 1\n        else:\n            space_width = len(m2.group(1))\n\n        text = text[space_width:] + '\\n'\n    else:\n        space_width = 1\n        text = ''\n\n    continue_width = leading_width + space_width\n    return text, continue_width"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 239,
      "kind": "function",
      "qualname": "src.mistune.list_parser._clean_list_item_text",
      "span": [
        236,
        251
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _clean_list_item_text(src: str, continue_width: int) -> str:\n    # according to Example 7, tab should be treated as 3 spaces\n    rv = []\n    trim_space = \" \" * continue_width\n    lines = src.split(\"\\n\")\n    for line in lines:\n        if line.startswith(trim_space):\n            line = line.replace(trim_space, \"\", 1)\n            # according to CommonMark Example 5\n            # tab should be treated as 4 spaces\n            line = expand_tab(line)\n            rv.append(line)\n        else:\n            rv.append(line)\n\n    return \"\\n\".join(rv)",
      "old_code": "def _clean_list_item_text(src: str, continue_width: int) -> str:\n    # according to Example 7, tab should be treated as 3 spaces\n    rv = []\n    trim_space = ' ' * continue_width\n    lines = src.split('\\n')\n    for line in lines:\n        if line.startswith(trim_space):\n            line = line.replace(trim_space, '', 1)\n            # according to CommonMark Example 5\n            # tab should be treated as 4 spaces\n            line = expand_tab(line)\n            rv.append(line)\n        else:\n            rv.append(line)\n\n    return '\\n'.join(rv)"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 257,
      "kind": "function",
      "qualname": "src.mistune.list_parser._is_loose_list",
      "span": [
        254,
        263
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _is_loose_list(tokens: Iterable[Dict[str, Any]]) -> bool:\n    paragraph_count = 0\n    for tok in tokens:\n        if tok[\"type\"] == \"blank_line\":\n            return True\n        if tok[\"type\"] == \"paragraph\":\n            paragraph_count += 1\n            if paragraph_count > 1:\n                return True\n    return False",
      "old_code": "def _is_loose_list(tokens: Iterable[Dict[str, Any]]) -> bool:\n    paragraph_count = 0\n    for tok in tokens:\n        if tok['type'] == 'blank_line':\n            return True\n        if tok['type'] == 'paragraph':\n            paragraph_count += 1\n            if paragraph_count > 1:\n                return True\n    return False"
    },
    {
      "path": "src/mistune/markdown.py",
      "version": "new",
      "line": 59,
      "kind": "function",
      "qualname": "src.mistune.markdown.Markdown._iter_render",
      "span": [
        59,
        69
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _iter_render(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> Iterable[Dict[str, Any]]:\n        for tok in tokens:\n            if \"children\" in tok:\n                children = self._iter_render(tok[\"children\"], state)\n                tok[\"children\"] = list(children)\n            elif \"text\" in tok:\n                text = tok.pop(\"text\")\n                # process inline text\n                # avoid striping emsp or other unicode spaces\n                tok[\"children\"] = self.inline(text.strip(\" \\r\\n\\t\\f\"), state.env)\n            yield tok",
      "old_code": "    def _iter_render(\n        self, tokens: Iterable[Dict[str, Any]], state: BlockState\n    ) -> Iterable[Dict[str, Any]]:\n        for tok in tokens:\n            if 'children' in tok:\n                children = self._iter_render(tok['children'], state)\n                tok['children'] = list(children)\n            elif 'text' in tok:\n                text = tok.pop('text')\n                # process inline text\n                # avoid striping emsp or other unicode spaces\n                tok['children'] = self.inline(text.strip(' \\r\\n\\t\\f'), state.env)\n            yield tok"
    },
    {
      "path": "src/mistune/markdown.py",
      "version": "new",
      "line": 71,
      "kind": "function",
      "qualname": "src.mistune.markdown.Markdown.parse",
      "span": [
        71,
        102
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def parse(self, s: str, state: Optional[BlockState] = None) -> Tuple[Union[str, List[Dict[str, Any]]], BlockState]:\n        \"\"\"Parse and convert the given markdown string. If renderer is None,\n        the returned **result** will be parsed markdown tokens.\n\n        :param s: markdown string\n        :param state: instance of BlockState\n        :returns: result, state\n        \"\"\"\n        if state is None:\n            state = self.block.state_cls()\n\n        # normalize line separator\n        s = s.replace(\"\\r\\n\", \"\\n\")\n        s = s.replace(\"\\r\", \"\\n\")\n        if not s.endswith(\"\\n\"):\n            s += \"\\n\"\n\n        state.process(s)\n\n        for hook in self.before_parse_hooks:\n            hook(self, state)\n\n        self.block.parse(state)\n\n        for hook2 in self.before_render_hooks:\n            hook2(self, state)\n\n        result = self.render_state(state)\n\n        for hook3 in self.after_render_hooks:\n            result = hook3(self, result, state)\n        return result, state",
      "old_code": "    def parse(\n        self, s: str, state: Optional[BlockState] = None\n    ) -> Tuple[Union[str, List[Dict[str, Any]]], BlockState]:\n        \"\"\"Parse and convert the given markdown string. If renderer is None,\n        the returned **result** will be parsed markdown tokens.\n\n        :param s: markdown string\n        :param state: instance of BlockState\n        :returns: result, state\n        \"\"\"\n        if state is None:\n            state = self.block.state_cls()\n\n        # normalize line separator\n        s = s.replace('\\r\\n', '\\n')\n        s = s.replace('\\r', '\\n')\n        if not s.endswith('\\n'):\n            s += '\\n'\n\n        state.process(s)\n\n        for hook in self.before_parse_hooks:\n            hook(self, state)\n\n        self.block.parse(state)\n\n        for hook2 in self.before_render_hooks:\n            hook2(self, state)\n\n        result = self.render_state(state)\n\n        for hook3 in self.after_render_hooks:\n            result = hook3(self, result, state)\n        return result, state"
    },
    {
      "path": "src/mistune/markdown.py",
      "version": "new",
      "line": 110,
      "kind": "function",
      "qualname": "src.mistune.markdown.Markdown.read",
      "span": [
        104,
        115
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def read(\n        self, filepath: str, encoding: str = \"utf-8\", state: Optional[BlockState] = None\n    ) -> Tuple[Union[str, List[Dict[str, Any]]], BlockState]:\n        if state is None:\n            state = self.block.state_cls()\n\n        state.env[\"__file__\"] = filepath\n        with open(filepath, \"rb\") as f:\n            s = f.read()\n\n        s2 = s.decode(encoding)\n        return self.parse(s2, state)",
      "old_code": "    def read(\n        self, filepath: str, encoding: str = \"utf-8\", state: Optional[BlockState] = None\n    ) -> Tuple[Union[str, List[Dict[str, Any]]], BlockState]:\n        if state is None:\n            state = self.block.state_cls()\n\n        state.env['__file__'] = filepath\n        with open(filepath, 'rb') as f:\n            s = f.read()\n\n        s2 = s.decode(encoding)\n        return self.parse(s2, state)"
    },
    {
      "path": "src/mistune/markdown.py",
      "version": "new",
      "line": 119,
      "kind": "function",
      "qualname": "src.mistune.markdown.Markdown.__call__",
      "span": [
        117,
        120
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, s: str) -> Union[str, List[Dict[str, Any]]]:\n        if s is None:\n            s = \"\\n\"\n        return self.parse(s)[0]",
      "old_code": "    def __call__(self, s: str) -> Union[str, List[Dict[str, Any]]]:\n        if s is None:\n            s = '\\n'\n        return self.parse(s)[0]"
    },
    {
      "path": "src/mistune/plugins/__init__.py",
      "version": "new",
      "line": 8,
      "kind": "module",
      "qualname": "src.mistune.plugins.__init__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/abbr.py",
      "version": "new",
      "line": 14,
      "kind": "module",
      "qualname": "src.mistune.plugins.abbr",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/abbr.py",
      "version": "new",
      "line": 27,
      "kind": "function",
      "qualname": "src.mistune.plugins.abbr.parse_ref_abbr",
      "span": [
        23,
        33
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_ref_abbr(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    ref = state.env.get(\"ref_abbrs\")\n    if not ref:\n        ref = {}\n    key = m.group(\"abbr_key\")\n    text = m.group(\"abbr_text\")\n    ref[key] = text.strip()\n    state.env[\"ref_abbrs\"] = ref\n    # abbr definition can split paragraph\n    state.append_token({\"type\": \"blank_line\"})\n    return m.end() + 1",
      "old_code": "def parse_ref_abbr(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    ref = state.env.get(\"ref_abbrs\")\n    if not ref:\n        ref = {}\n    key = m.group('abbr_key')\n    text = m.group('abbr_text')\n    ref[key] = text.strip()\n    state.env['ref_abbrs'] = ref\n    # abbr definition can split paragraph\n    state.append_token({'type': 'blank_line'})\n    return m.end() + 1"
    },
    {
      "path": "src/mistune/plugins/abbr.py",
      "version": "new",
      "line": 39,
      "kind": "function",
      "qualname": "src.mistune.plugins.abbr.process_text",
      "span": [
        36,
        73
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def process_text(inline: \"InlineParser\", text: str, state: \"InlineState\") -> None:\n    ref = state.env.get(\"ref_abbrs\")\n    if not ref:\n        return state.append_token({\"type\": \"text\", \"raw\": text})\n\n    if state.tokens:\n        last = state.tokens[-1]\n        if last[\"type\"] == \"text\":\n            state.tokens.pop()\n            text = last[\"raw\"] + text\n\n    abbrs_re = state.env.get(\"abbrs_re\")\n    if not abbrs_re:\n        abbrs_re = re.compile(r\"|\".join(re.escape(k) for k in ref.keys()))\n        state.env[\"abbrs_re\"] = abbrs_re\n\n    pos = 0\n    while pos < len(text):\n        m = abbrs_re.search(text, pos)\n        if not m:\n            break\n\n        end_pos = m.start()\n        if end_pos > pos:\n            hole = text[pos:end_pos]\n            state.append_token({\"type\": \"text\", \"raw\": hole})\n\n        label = m.group(0)\n        state.append_token(\n            {\"type\": \"abbr\", \"children\": [{\"type\": \"text\", \"raw\": label}], \"attrs\": {\"title\": ref[label]}}\n        )\n        pos = m.end()\n\n    if pos == 0:\n        # special case, just pure text\n        state.append_token({\"type\": \"text\", \"raw\": text})\n    elif pos < len(text):\n        state.append_token({\"type\": \"text\", \"raw\": text[pos:]})",
      "old_code": "def process_text(inline: \"InlineParser\", text: str, state: \"InlineState\") -> None:\n    ref = state.env.get(\"ref_abbrs\")\n    if not ref:\n        return state.append_token({'type': 'text', 'raw': text})\n\n    if state.tokens:\n        last = state.tokens[-1]\n        if last['type'] == 'text':\n            state.tokens.pop()\n            text = last['raw'] + text\n\n    abbrs_re = state.env.get('abbrs_re')\n    if not abbrs_re:\n        abbrs_re = re.compile(r'|'.join(re.escape(k) for k in ref.keys()))\n        state.env['abbrs_re'] = abbrs_re\n\n    pos = 0\n    while pos < len(text):\n        m = abbrs_re.search(text, pos)\n        if not m:\n            break\n\n        end_pos = m.start()\n        if end_pos > pos:\n            hole = text[pos:end_pos]\n            state.append_token({'type': 'text', 'raw': hole})\n\n        label = m.group(0)\n        state.append_token({\n            'type': 'abbr',\n            'children': [{'type': 'text', 'raw': label}],\n            'attrs': {'title': ref[label]}\n        })\n        pos = m.end()\n\n    if pos == 0:\n        # special case, just pure text\n        state.append_token({'type': 'text', 'raw': text})\n    elif pos < len(text):\n        state.append_token({'type': 'text', 'raw': text[pos:]})"
    },
    {
      "path": "src/mistune/plugins/abbr.py",
      "version": "new",
      "line": 78,
      "kind": "function",
      "qualname": "src.mistune.plugins.abbr.render_abbr",
      "span": [
        76,
        79
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_abbr(renderer: \"BaseRenderer\", text: str, title: str) -> str:\n    if not title:\n        return \"<abbr>\" + text + \"</abbr>\"\n    return '<abbr title=\"' + escape(title) + '\">' + text + \"</abbr>\"",
      "old_code": "def render_abbr(renderer: \"BaseRenderer\", text: str, title: str) -> str:\n    if not title:\n        return '<abbr>' + text + '</abbr>'\n    return '<abbr title=\"' + escape(title) + '\">' + text + '</abbr>'"
    },
    {
      "path": "src/mistune/plugins/abbr.py",
      "version": "new",
      "line": 105,
      "kind": "function",
      "qualname": "src.mistune.plugins.abbr.abbr",
      "span": [
        82,
        109
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def abbr(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support abbreviations, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#abbr\n\n    Here is an example:\n\n    .. code-block:: text\n\n        The HTML specification\n        is maintained by the W3C.\n\n        *[HTML]: Hyper Text Markup Language\n        *[W3C]:  World Wide Web Consortium\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        The <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification\n        is maintained by the <abbr title=\"World Wide Web Consortium\">W3C</abbr>.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register(\"ref_abbr\", REF_ABBR, parse_ref_abbr, before=\"paragraph\")\n    # replace process_text\n    md.inline.process_text = types.MethodType(process_text, md.inline)  # type: ignore[method-assign]\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"abbr\", render_abbr)",
      "old_code": "def abbr(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support abbreviations, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#abbr\n\n    Here is an example:\n\n    .. code-block:: text\n\n        The HTML specification\n        is maintained by the W3C.\n\n        *[HTML]: Hyper Text Markup Language\n        *[W3C]:  World Wide Web Consortium\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        The <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification\n        is maintained by the <abbr title=\"World Wide Web Consortium\">W3C</abbr>.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register('ref_abbr', REF_ABBR, parse_ref_abbr, before='paragraph')\n    # replace process_text\n    md.inline.process_text = types.MethodType(process_text, md.inline)  # type: ignore[method-assign]\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('abbr', render_abbr)"
    },
    {
      "path": "src/mistune/plugins/def_list.py",
      "version": "new",
      "line": 11,
      "kind": "module",
      "qualname": "src.mistune.plugins.def_list",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/def_list.py",
      "version": "new",
      "line": 40,
      "kind": "function",
      "qualname": "src.mistune.plugins.def_list.parse_def_list",
      "span": [
        30,
        46
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_def_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    pos = m.end()\n    children = list(_parse_def_item(block, m))\n\n    m2 = DEF_RE.match(state.src, pos)\n    while m2:\n        children.extend(list(_parse_def_item(block, m2)))\n        pos = m2.end()\n        m2 = DEF_RE.match(state.src, pos)\n\n    state.append_token(\n        {\n            \"type\": \"def_list\",\n            \"children\": children,\n        }\n    )\n    return pos",
      "old_code": "def parse_def_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    pos = m.end()\n    children = list(_parse_def_item(block, m))\n\n    m2 = DEF_RE.match(state.src, pos)\n    while m2:\n        children.extend(list(_parse_def_item(block, m2)))\n        pos = m2.end()\n        m2 = DEF_RE.match(state.src, pos)\n\n    state.append_token({\n        'type': 'def_list',\n        'children': children,\n    })\n    return pos"
    },
    {
      "path": "src/mistune/plugins/def_list.py",
      "version": "new",
      "line": 53,
      "kind": "function",
      "qualname": "src.mistune.plugins.def_list._parse_def_item",
      "span": [
        49,
        84
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_def_item(block: \"BlockParser\", m: Match[str]) -> Iterable[Dict[str, Any]]:\n    head = m.group(\"def_list_head\")\n    for line in head.splitlines():\n        yield {\n            \"type\": \"def_list_head\",\n            \"text\": line,\n        }\n\n    src = m.group(0)\n    end = len(head)\n\n    m2 = DD_START_RE.search(src, end)\n    assert m2 is not None\n    start = m2.start()\n    prev_blank_line = src[end:start] == \"\\n\"\n    while m2:\n        m2 = DD_START_RE.search(src, start + 1)\n        if not m2:\n            break\n\n        end = m2.start()\n        text = src[start:end].replace(\":\", \" \", 1)\n        children = _process_text(block, text, prev_blank_line)\n        prev_blank_line = bool(HAS_BLANK_LINE_RE.search(text))\n        yield {\n            \"type\": \"def_list_item\",\n            \"children\": children,\n        }\n        start = end\n\n    text = src[start:].replace(\":\", \" \", 1)\n    children = _process_text(block, text, prev_blank_line)\n    yield {\n        \"type\": \"def_list_item\",\n        \"children\": children,\n    }",
      "old_code": "def _parse_def_item(block: \"BlockParser\", m: Match[str]) -> Iterable[Dict[str, Any]]:\n    head = m.group(\"def_list_head\")\n    for line in head.splitlines():\n        yield {\n          'type': 'def_list_head',\n          'text': line,\n        }\n\n    src = m.group(0)\n    end = len(head)\n\n    m2 = DD_START_RE.search(src, end)\n    assert m2 is not None\n    start = m2.start()\n    prev_blank_line = src[end:start] == '\\n'\n    while m2:\n        m2 = DD_START_RE.search(src, start + 1)\n        if not m2:\n            break\n\n        end = m2.start()\n        text = src[start:end].replace(':', ' ', 1)\n        children = _process_text(block, text, prev_blank_line)\n        prev_blank_line = bool(HAS_BLANK_LINE_RE.search(text))\n        yield {\n          'type': 'def_list_item',\n          'children': children,\n        }\n        start = end\n\n    text = src[start:].replace(':', ' ', 1)\n    children = _process_text(block, text, prev_blank_line)\n    yield {\n      'type': 'def_list_item',\n      'children': children,\n    }"
    },
    {
      "path": "src/mistune/plugins/def_list.py",
      "version": "new",
      "line": 94,
      "kind": "function",
      "qualname": "src.mistune.plugins.def_list._process_text",
      "span": [
        87,
        96
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _process_text(block: \"BlockParser\", text: str, loose: bool) -> List[Any]:\n    text = TRIM_RE.sub(\"\", text)\n    state = block.state_cls()\n    state.process(strip_end(text))\n    # use default list rules\n    block.parse(state, block.list_rules)\n    tokens = state.tokens\n    if not loose and len(tokens) == 1 and tokens[0][\"type\"] == \"paragraph\":\n        tokens[0][\"type\"] = \"block_text\"\n    return tokens",
      "old_code": "def _process_text(block: \"BlockParser\", text: str, loose: bool) -> List[Any]:\n    text = TRIM_RE.sub(\"\", text)\n    state = block.state_cls()\n    state.process(strip_end(text))\n    # use default list rules\n    block.parse(state, block.list_rules)\n    tokens = state.tokens\n    if not loose and len(tokens) == 1 and tokens[0]['type'] == 'paragraph':\n        tokens[0]['type'] = 'block_text'\n    return tokens"
    },
    {
      "path": "src/mistune/plugins/def_list.py",
      "version": "new",
      "line": 141,
      "kind": "function",
      "qualname": "src.mistune.plugins.def_list.def_list",
      "span": [
        111,
        145
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def def_list(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support def list, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#def-list\n\n    Here is an example:\n\n    .. code-block:: text\n\n        Apple\n        :   Pomaceous fruit of plants of the genus Malus in\n            the family Rosaceae.\n\n        Orange\n        :   The fruit of an evergreen tree of the genus Citrus.\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <dl>\n        <dt>Apple</dt>\n        <dd>Pomaceous fruit of plants of the genus Malus in\n        the family Rosaceae.</dd>\n\n        <dt>Orange</dt>\n        <dd>The fruit of an evergreen tree of the genus Citrus.</dd>\n        </dl>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register(\"def_list\", DEF_PATTERN, parse_def_list, before=\"paragraph\")\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"def_list\", render_def_list)\n        md.renderer.register(\"def_list_head\", render_def_list_head)\n        md.renderer.register(\"def_list_item\", render_def_list_item)",
      "old_code": "def def_list(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support def list, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#def-list\n\n    Here is an example:\n\n    .. code-block:: text\n\n        Apple\n        :   Pomaceous fruit of plants of the genus Malus in\n            the family Rosaceae.\n\n        Orange\n        :   The fruit of an evergreen tree of the genus Citrus.\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <dl>\n        <dt>Apple</dt>\n        <dd>Pomaceous fruit of plants of the genus Malus in\n        the family Rosaceae.</dd>\n\n        <dt>Orange</dt>\n        <dd>The fruit of an evergreen tree of the genus Citrus.</dd>\n        </dl>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register('def_list', DEF_PATTERN, parse_def_list, before='paragraph')\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('def_list', render_def_list)\n        md.renderer.register('def_list_head', render_def_list_head)\n        md.renderer.register('def_list_item', render_def_list_item)"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 14,
      "kind": "module",
      "qualname": "src.mistune.plugins.footnotes",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 29,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.parse_inline_footnote",
      "span": [
        29,
        42
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_inline_footnote(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    key = unikey(m.group(\"footnote_key\"))\n    ref = state.env.get(\"ref_footnotes\")\n    if ref and key in ref:\n        notes = state.env.get(\"footnotes\")\n        if not notes:\n            notes = []\n        if key not in notes:\n            notes.append(key)\n            state.env[\"footnotes\"] = notes\n        state.append_token({\"type\": \"footnote_ref\", \"raw\": key, \"attrs\": {\"index\": notes.index(key) + 1}})\n    else:\n        state.append_token({\"type\": \"text\", \"raw\": m.group(0)})\n    return m.end()",
      "old_code": "def parse_inline_footnote(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> int:\n    key = unikey(m.group(\"footnote_key\"))\n    ref = state.env.get(\"ref_footnotes\")\n    if ref and key in ref:\n        notes = state.env.get('footnotes')\n        if not notes:\n            notes = []\n        if key not in notes:\n            notes.append(key)\n            state.env['footnotes'] = notes\n        state.append_token({\n          'type': 'footnote_ref',\n          'raw': key,\n          'attrs': {'index': notes.index(key) + 1}\n        })\n    else:\n        state.append_token({'type': 'text', 'raw': m.group(0)})\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 45,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.parse_ref_footnote",
      "span": [
        45,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_ref_footnote(block: \"BlockParser\", m: Match[str], state: BlockState) -> int:\n    ref = state.env.get(\"ref_footnotes\")\n    if not ref:\n        ref = {}\n\n    key = unikey(m.group(\"footnote_key\"))\n    if key not in ref:\n        ref[key] = m.group(\"footnote_text\")\n        state.env[\"ref_footnotes\"] = ref\n    return m.end()",
      "old_code": "def parse_ref_footnote(\n    block: \"BlockParser\", m: Match[str], state: BlockState\n) -> int:\n    ref = state.env.get(\"ref_footnotes\")\n    if not ref:\n        ref = {}\n\n    key = unikey(m.group('footnote_key'))\n    if key not in ref:\n        ref[key] = m.group('footnote_text')\n        state.env['ref_footnotes'] = ref\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 57,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.parse_footnote_item",
      "span": [
        57,
        78
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_footnote_item(block: \"BlockParser\", key: str, index: int, state: BlockState) -> Dict[str, Any]:\n    ref = state.env.get(\"ref_footnotes\")\n    if not ref:\n        raise ValueError(\"Missing 'ref_footnotes'.\")\n    text = ref[key]\n\n    lines = text.splitlines()\n    second_line = None\n    for second_line in lines[1:]:\n        if second_line:\n            break\n\n    if second_line:\n        spaces = len(second_line) - len(second_line.lstrip())\n        pattern = re.compile(r\"^ {\" + str(spaces) + r\",}\", flags=re.M)\n        text = pattern.sub(\"\", text).strip()\n        items = _PARAGRAPH_SPLIT.split(text)\n        children = [{\"type\": \"paragraph\", \"text\": s} for s in items]\n    else:\n        text = text.strip()\n        children = [{\"type\": \"paragraph\", \"text\": text}]\n    return {\"type\": \"footnote_item\", \"children\": children, \"attrs\": {\"key\": key, \"index\": index}}",
      "old_code": "def parse_footnote_item(\n    block: \"BlockParser\", key: str, index: int, state: BlockState\n) -> Dict[str, Any]:\n    ref = state.env.get(\"ref_footnotes\")\n    if not ref:\n        raise ValueError(\"Missing 'ref_footnotes'.\")\n    text = ref[key]\n\n    lines = text.splitlines()\n    second_line = None\n    for second_line in lines[1:]:\n        if second_line:\n            break\n\n    if second_line:\n      spaces = len(second_line) - len(second_line.lstrip())\n      pattern = re.compile(r'^ {' + str(spaces) + r',}', flags=re.M)\n      text = pattern.sub('', text).strip()\n      items = _PARAGRAPH_SPLIT.split(text)\n      children = [{'type': 'paragraph', 'text': s} for s in items]\n    else:\n      text = text.strip()\n      children = [{'type': 'paragraph', 'text': text}]\n    return {\n        'type': 'footnote_item',\n        'children': children,\n        'attrs': {'key': key, 'index': index}\n    }"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 88,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.md_footnotes_hook",
      "span": [
        81,
        92
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def md_footnotes_hook(\n    md: \"Markdown\", result: Union[str, List[Dict[str, Any]]], state: BlockState\n) -> Union[str, List[Dict[str, Any]]]:\n    notes = state.env.get(\"footnotes\")\n    if not notes:\n        return result\n\n    children = [parse_footnote_item(md.block, k, i + 1, state) for i, k in enumerate(notes)]\n    state = BlockState()\n    state.tokens = [{\"type\": \"footnotes\", \"children\": children}]\n    output = md.render_state(state)\n    return result + output  # type: ignore[operator]",
      "old_code": "def md_footnotes_hook(\n    md: \"Markdown\", result: Union[str, List[Dict[str, Any]]], state: BlockState\n) -> Union[str, List[Dict[str, Any]]]:\n    notes = state.env.get(\"footnotes\")\n    if not notes:\n        return result\n\n    children = [\n        parse_footnote_item(md.block, k, i + 1, state)\n        for i, k in enumerate(notes)\n    ]\n    state = BlockState()\n    state.tokens = [{'type': 'footnotes', 'children': children}]\n    output = md.render_state(state)\n    return result + output  # type: ignore[operator]"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 98,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.render_footnote_ref",
      "span": [
        95,
        98
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_footnote_ref(renderer: \"BaseRenderer\", key: str, index: int) -> str:\n    i = str(index)\n    html = '<sup class=\"footnote-ref\" id=\"fnref-' + i + '\">'\n    return html + '<a href=\"#fn-' + i + '\">' + i + \"</a></sup>\"",
      "old_code": "def render_footnote_ref(renderer: \"BaseRenderer\", key: str, index: int) -> str:\n    i = str(index)\n    html = '<sup class=\"footnote-ref\" id=\"fnref-' + i + '\">'\n    return html + '<a href=\"#fn-' + i + '\">' + i + '</a></sup>'"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 105,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.render_footnote_item",
      "span": [
        105,
        109
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_footnote_item(renderer: \"BaseRenderer\", text: str, key: str, index: int) -> str:\n    i = str(index)\n    back = '<a href=\"#fnref-' + i + '\" class=\"footnote\">&#8617;</a>'\n    text = text.rstrip()[:-4] + back + \"</p>\"\n    return '<li id=\"fn-' + i + '\">' + text + \"</li>\\n\"",
      "old_code": "def render_footnote_item(\n    renderer: \"BaseRenderer\", text: str, key: str, index: int\n) -> str:\n    i = str(index)\n    back = '<a href=\"#fnref-' + i + '\" class=\"footnote\">&#8617;</a>'\n    text = text.rstrip()[:-4] + back + '</p>'\n    return '<li id=\"fn-' + i + '\">' + text + '</li>\\n'"
    },
    {
      "path": "src/mistune/plugins/footnotes.py",
      "version": "new",
      "line": 138,
      "kind": "function",
      "qualname": "src.mistune.plugins.footnotes.footnotes",
      "span": [
        112,
        154
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def footnotes(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support footnotes, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#footnotes\n\n    Here is an example:\n\n    .. code-block:: text\n\n        That's some text with a footnote.[^1]\n\n        [^1]: And that's the footnote.\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <p>That's some text with a footnote.<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup></p>\n        <section class=\"footnotes\">\n        <ol>\n        <li id=\"fn-1\"><p>And that's the footnote.<a href=\"#fnref-1\" class=\"footnote\">&#8617;</a></p></li>\n        </ol>\n        </section>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        \"footnote\",\n        INLINE_FOOTNOTE,\n        parse_inline_footnote,\n        before=\"link\",\n    )\n    md.block.register(\n        \"ref_footnote\",\n        REF_FOOTNOTE,\n        parse_ref_footnote,\n        before=\"ref_link\",\n    )\n    md.after_render_hooks.append(md_footnotes_hook)\n\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"footnote_ref\", render_footnote_ref)\n        md.renderer.register(\"footnote_item\", render_footnote_item)\n        md.renderer.register(\"footnotes\", render_footnotes)",
      "old_code": "def footnotes(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support footnotes, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#footnotes\n\n    Here is an example:\n\n    .. code-block:: text\n\n        That's some text with a footnote.[^1]\n\n        [^1]: And that's the footnote.\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <p>That's some text with a footnote.<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup></p>\n        <section class=\"footnotes\">\n        <ol>\n        <li id=\"fn-1\"><p>And that's the footnote.<a href=\"#fnref-1\" class=\"footnote\">&#8617;</a></p></li>\n        </ol>\n        </section>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        'footnote',\n        INLINE_FOOTNOTE,\n        parse_inline_footnote,\n        before='link',\n    )\n    md.block.register(\n        'ref_footnote',\n        REF_FOOTNOTE,\n        parse_ref_footnote,\n        before='ref_link',\n    )\n    md.after_render_hooks.append(md_footnotes_hook)\n\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('footnote_ref', render_footnote_ref)\n        md.renderer.register('footnote_item', render_footnote_item)\n        md.renderer.register('footnotes', render_footnotes)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 13,
      "kind": "module",
      "qualname": "src.mistune.plugins.formatting",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 21,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.parse_strikethrough",
      "span": [
        21,
        22
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_strikethrough(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"strikethrough\", _STRIKE_END)",
      "old_code": "def parse_strikethrough(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"strikethrough\", _STRIKE_END)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 29,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.parse_mark",
      "span": [
        29,
        30
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_mark(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"mark\", _MARK_END)",
      "old_code": "def parse_mark(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"mark\", _MARK_END)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 37,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.parse_insert",
      "span": [
        37,
        38
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_insert(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"insert\", _INSERT_END)",
      "old_code": "def parse_insert(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> Optional[int]:\n    return _parse_to_end(inline, m, state, \"insert\", _INSERT_END)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 45,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.parse_superscript",
      "span": [
        45,
        46
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_superscript(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    return _parse_script(inline, m, state, \"superscript\")",
      "old_code": "def parse_superscript(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> int:\n    return _parse_script(inline, m, state, \"superscript\")"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 73,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting._parse_to_end",
      "span": [
        61,
        78
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_to_end(\n    inline: \"InlineParser\",\n    m: Match[str],\n    state: \"InlineState\",\n    tok_type: str,\n    end_pattern: Pattern[str],\n) -> Optional[int]:\n    pos = m.end()\n    m1 = end_pattern.search(state.src, pos)\n    if not m1:\n        return None\n    end_pos = m1.end()\n    text = state.src[pos : end_pos - 2]\n    new_state = state.copy()\n    new_state.src = text\n    children = inline.render(new_state)\n    state.append_token({\"type\": tok_type, \"children\": children})\n    return end_pos",
      "old_code": "def _parse_to_end(\n    inline: \"InlineParser\",\n    m: Match[str],\n    state: \"InlineState\",\n    tok_type: str,\n    end_pattern: Pattern[str],\n) -> Optional[int]:\n    pos = m.end()\n    m1 = end_pattern.search(state.src, pos)\n    if not m1:\n        return None\n    end_pos = m1.end()\n    text = state.src[pos:end_pos-2]\n    new_state = state.copy()\n    new_state.src = text\n    children = inline.render(new_state)\n    state.append_token({'type': tok_type, 'children': children})\n    return end_pos"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 81,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting._parse_script",
      "span": [
        81,
        87
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_script(inline: \"InlineParser\", m: Match[str], state: \"InlineState\", tok_type: str) -> int:\n    text = m.group(0)\n    new_state = state.copy()\n    new_state.src = text[1:-1].replace(\"\\\\ \", \" \")\n    children = inline.render(new_state)\n    state.append_token({\"type\": tok_type, \"children\": children})\n    return m.end()",
      "old_code": "def _parse_script(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\", tok_type: str\n) -> int:\n    text = m.group(0)\n    new_state = state.copy()\n    new_state.src = text[1:-1].replace('\\\\ ', ' ')\n    children = inline.render(new_state)\n    state.append_token({\n        'type': tok_type,\n        'children': children\n    })\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 107,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.strikethrough",
      "span": [
        90,
        113
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def strikethrough(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support strikethrough. Spec defined by\n    GitHub flavored Markdown and commonly used by many parsers:\n\n    .. code-block:: text\n\n        ~~This was mistaken text~~\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <del>This was mistaken text</del>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        \"strikethrough\",\n        r\"~~(?=[^\\s~])\",\n        parse_strikethrough,\n        before=\"link\",\n    )\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"strikethrough\", render_strikethrough)",
      "old_code": "def strikethrough(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support strikethrough. Spec defined by\n    GitHub flavored Markdown and commonly used by many parsers:\n\n    .. code-block:: text\n\n        ~~This was mistaken text~~\n\n    It will be converted into HTML:\n\n    .. code-block:: html\n\n        <del>This was mistaken text</del>\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        'strikethrough',\n        r'~~(?=[^\\s~])',\n        parse_strikethrough,\n        before='link',\n    )\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('strikethrough', render_strikethrough)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 127,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.mark",
      "span": [
        116,
        133
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def mark(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<mark>`` tag. Spec defined at\n    https://facelessuser.github.io/pymdown-extensions/extensions/mark/:\n\n    .. code-block:: text\n\n        ==mark me== ==mark \\\\=\\\\= equal==\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        \"mark\",\n        r\"==(?=[^\\s=])\",\n        parse_mark,\n        before=\"link\",\n    )\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"mark\", render_mark)",
      "old_code": "def mark(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<mark>`` tag. Spec defined at\n    https://facelessuser.github.io/pymdown-extensions/extensions/mark/:\n\n    .. code-block:: text\n\n        ==mark me== ==mark \\\\=\\\\= equal==\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        'mark',\n        r'==(?=[^\\s=])',\n        parse_mark,\n        before='link',\n    )\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('mark', render_mark)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 147,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.insert",
      "span": [
        136,
        153
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def insert(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<ins>`` tag. Spec defined at\n    https://facelessuser.github.io/pymdown-extensions/extensions/caret/#insert:\n\n    .. code-block:: text\n\n        ^^insert me^^\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        \"insert\",\n        r\"\\^\\^(?=[^\\s\\^])\",\n        parse_insert,\n        before=\"link\",\n    )\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"insert\", render_insert)",
      "old_code": "def insert(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<ins>`` tag. Spec defined at\n    https://facelessuser.github.io/pymdown-extensions/extensions/caret/#insert:\n\n    .. code-block:: text\n\n        ^^insert me^^\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\n        'insert',\n        r'\\^\\^(?=[^\\s\\^])',\n        parse_insert,\n        before='link',\n    )\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('insert', render_insert)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 166,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.superscript",
      "span": [
        156,
        168
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def superscript(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<sup>`` tag. Spec defined at\n    https://pandoc.org/MANUAL.html#superscripts-and-subscripts:\n\n    .. code-block:: text\n\n        2^10^ is 1024.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\"superscript\", SUPERSCRIPT_PATTERN, parse_superscript, before=\"linebreak\")\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"superscript\", render_superscript)",
      "old_code": "def superscript(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<sup>`` tag. Spec defined at\n    https://pandoc.org/MANUAL.html#superscripts-and-subscripts:\n\n    .. code-block:: text\n\n        2^10^ is 1024.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register('superscript', SUPERSCRIPT_PATTERN, parse_superscript, before='linebreak')\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('superscript', render_superscript)"
    },
    {
      "path": "src/mistune/plugins/formatting.py",
      "version": "new",
      "line": 181,
      "kind": "function",
      "qualname": "src.mistune.plugins.formatting.subscript",
      "span": [
        171,
        183
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def subscript(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<sub>`` tag. Spec defined at\n    https://pandoc.org/MANUAL.html#superscripts-and-subscripts:\n\n    .. code-block:: text\n\n        H~2~O is a liquid.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\"subscript\", SUBSCRIPT_PATTERN, parse_subscript, before=\"linebreak\")\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"subscript\", render_subscript)",
      "old_code": "def subscript(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to add ``<sub>`` tag. Spec defined at\n    https://pandoc.org/MANUAL.html#superscripts-and-subscripts:\n\n    .. code-block:: text\n\n        H~2~O is a liquid.\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register('subscript', SUBSCRIPT_PATTERN, parse_subscript, before='linebreak')\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('subscript', render_subscript)"
    },
    {
      "path": "src/mistune/plugins/math.py",
      "version": "new",
      "line": 9,
      "kind": "module",
      "qualname": "src.mistune.plugins.math",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/math.py",
      "version": "new",
      "line": 21,
      "kind": "function",
      "qualname": "src.mistune.plugins.math.parse_inline_math",
      "span": [
        21,
        24
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_inline_math(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(\"math_text\")\n    state.append_token({\"type\": \"inline_math\", \"raw\": text})\n    return m.end()",
      "old_code": "def parse_inline_math(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> int:\n    text = m.group(\"math_text\")\n    state.append_token({\"type\": \"inline_math\", \"raw\": text})\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/math.py",
      "version": "new",
      "line": 51,
      "kind": "function",
      "qualname": "src.mistune.plugins.math.math",
      "span": [
        35,
        55
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def math(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support math. The syntax is used\n    by many markdown extensions:\n\n    .. code-block:: text\n\n        Block math is surrounded by $$:\n\n        $$\n        f(a)=f(b)\n        $$\n\n        Inline math is surrounded by `$`, such as $f(a)=f(b)$\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register(\"block_math\", BLOCK_MATH_PATTERN, parse_block_math, before=\"list\")\n    md.inline.register(\"inline_math\", INLINE_MATH_PATTERN, parse_inline_math, before=\"link\")\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"block_math\", render_block_math)\n        md.renderer.register(\"inline_math\", render_inline_math)",
      "old_code": "def math(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support math. The syntax is used\n    by many markdown extensions:\n\n    .. code-block:: text\n\n        Block math is surrounded by $$:\n\n        $$\n        f(a)=f(b)\n        $$\n\n        Inline math is surrounded by `$`, such as $f(a)=f(b)$\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register('block_math', BLOCK_MATH_PATTERN, parse_block_math, before='list')\n    md.inline.register('inline_math', INLINE_MATH_PATTERN, parse_inline_math, before='link')\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('block_math', render_block_math)\n        md.renderer.register('inline_math', render_inline_math)"
    },
    {
      "path": "src/mistune/plugins/math.py",
      "version": "new",
      "line": 60,
      "kind": "function",
      "qualname": "src.mistune.plugins.math.math_in_quote",
      "span": [
        58,
        60
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def math_in_quote(md: \"Markdown\") -> None:\n    \"\"\"Enable block math plugin in block quote.\"\"\"\n    md.block.insert_rule(md.block.block_quote_rules, \"block_math\", before=\"list\")",
      "old_code": "def math_in_quote(md: \"Markdown\") -> None:\n    \"\"\"Enable block math plugin in block quote.\"\"\"\n    md.block.insert_rule(md.block.block_quote_rules, 'block_math', before='list')"
    },
    {
      "path": "src/mistune/plugins/math.py",
      "version": "new",
      "line": 65,
      "kind": "function",
      "qualname": "src.mistune.plugins.math.math_in_list",
      "span": [
        63,
        65
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def math_in_list(md: \"Markdown\") -> None:\n    \"\"\"Enable block math plugin in list.\"\"\"\n    md.block.insert_rule(md.block.list_rules, \"block_math\", before=\"list\")",
      "old_code": "def math_in_list(md: \"Markdown\") -> None:\n    \"\"\"Enable block math plugin in list.\"\"\"\n    md.block.insert_rule(md.block.list_rules, 'block_math', before='list')"
    },
    {
      "path": "src/mistune/plugins/ruby.py",
      "version": "new",
      "line": 13,
      "kind": "module",
      "qualname": "src.mistune.plugins.ruby",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/ruby.py",
      "version": "new",
      "line": 19,
      "kind": "function",
      "qualname": "src.mistune.plugins.ruby.parse_ruby",
      "span": [
        17,
        41
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_ruby(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)[1:-2]\n    items = text.split(\")\")\n    tokens = []\n    for item in items:\n        rb, rt = item.split(\"(\")\n        tokens.append({\"type\": \"ruby\", \"raw\": rb, \"attrs\": {\"rt\": rt}})\n\n    end_pos = m.end()\n\n    next_match = _ruby_re.match(state.src, end_pos)\n    if next_match:\n        for tok in tokens:\n            state.append_token(tok)\n        return parse_ruby(inline, next_match, state)\n\n    # repeat link logic\n    if end_pos < len(state.src):\n        link_pos = _parse_ruby_link(inline, state, end_pos, tokens)\n        if link_pos:\n            return link_pos\n\n    for tok in tokens:\n        state.append_token(tok)\n    return end_pos",
      "old_code": "def parse_ruby(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)[1:-2]\n    items = text.split(')')\n    tokens = []\n    for item in items:\n        rb, rt = item.split('(')\n        tokens.append({\n            'type': 'ruby',\n            'raw': rb,\n            'attrs': {'rt': rt}\n        })\n\n    end_pos = m.end()\n\n    next_match = _ruby_re.match(state.src, end_pos)\n    if next_match:\n        for tok in tokens:\n            state.append_token(tok)\n        return parse_ruby(inline, next_match, state)\n\n    # repeat link logic\n    if end_pos < len(state.src):\n        link_pos = _parse_ruby_link(inline, state, end_pos, tokens)\n        if link_pos:\n            return link_pos\n\n    for tok in tokens:\n        state.append_token(tok)\n    return end_pos"
    },
    {
      "path": "src/mistune/plugins/ruby.py",
      "version": "new",
      "line": 48,
      "kind": "function",
      "qualname": "src.mistune.plugins.ruby._parse_ruby_link",
      "span": [
        44,
        87
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_ruby_link(\n    inline: \"InlineParser\", state: \"InlineState\", pos: int, tokens: List[Dict[str, Any]]\n) -> Optional[int]:\n    c = state.src[pos]\n    if c == \"(\":\n        # standard link [text](<url> \"title\")\n        attrs, link_pos = parse_link(state.src, pos + 1)\n        if link_pos:\n            state.append_token(\n                {\n                    \"type\": \"link\",\n                    \"children\": tokens,\n                    \"attrs\": attrs,\n                }\n            )\n            return link_pos\n\n    elif c == \"[\":\n        # standard ref link [text][label]\n        label, link_pos = parse_link_label(state.src, pos + 1)\n        if label and link_pos:\n            ref_links = state.env[\"ref_links\"]\n            key = unikey(label)\n            env = ref_links.get(key)\n            if env:\n                attrs = {\"url\": env[\"url\"], \"title\": env.get(\"title\")}\n                state.append_token(\n                    {\n                        \"type\": \"link\",\n                        \"children\": tokens,\n                        \"attrs\": attrs,\n                    }\n                )\n            else:\n                for tok in tokens:\n                    state.append_token(tok)\n                state.append_token(\n                    {\n                        \"type\": \"text\",\n                        \"raw\": \"[\" + label + \"]\",\n                    }\n                )\n            return link_pos\n    return None",
      "old_code": "def _parse_ruby_link(\n    inline: \"InlineParser\", state: \"InlineState\", pos: int, tokens: List[Dict[str, Any]]\n) -> Optional[int]:\n    c = state.src[pos]\n    if c == '(':\n        # standard link [text](<url> \"title\")\n        attrs, link_pos = parse_link(state.src, pos + 1)\n        if link_pos:\n            state.append_token({\n                'type': 'link',\n                'children': tokens,\n                'attrs': attrs,\n            })\n            return link_pos\n\n    elif c == '[':\n        # standard ref link [text][label]\n        label, link_pos = parse_link_label(state.src, pos + 1)\n        if label and link_pos:\n            ref_links = state.env['ref_links']\n            key = unikey(label)\n            env = ref_links.get(key)\n            if env:\n                attrs = {'url': env['url'], 'title': env.get('title')}\n                state.append_token({\n                    'type': 'link',\n                    'children': tokens,\n                    'attrs': attrs,\n                })\n            else:\n                for tok in tokens:\n                    state.append_token(tok)\n                state.append_token({\n                    'type': 'text',\n                    'raw': '[' + label + ']',\n                })\n            return link_pos\n    return None"
    },
    {
      "path": "src/mistune/plugins/ruby.py",
      "version": "new",
      "line": 110,
      "kind": "function",
      "qualname": "src.mistune.plugins.ruby.ruby",
      "span": [
        94,
        112
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def ruby(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support ``<ruby>`` tag. The syntax is defined\n    at https://lepture.com/en/2022/markdown-ruby-markup:\n\n    .. code-block:: text\n\n        [漢字(ㄏㄢˋㄗˋ)]\n        [漢(ㄏㄢˋ)字(ㄗˋ)]\n\n        [漢字(ㄏㄢˋㄗˋ)][link]\n        [漢字(ㄏㄢˋㄗˋ)](/url \"title\")\n\n        [link]: /url \"title\"\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register(\"ruby\", RUBY_PATTERN, parse_ruby, before=\"link\")\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"ruby\", render_ruby)",
      "old_code": "def ruby(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support ``<ruby>`` tag. The syntax is defined\n    at https://lepture.com/en/2022/markdown-ruby-markup:\n\n    .. code-block:: text\n\n        [漢字(ㄏㄢˋㄗˋ)]\n        [漢(ㄏㄢˋ)字(ㄗˋ)]\n\n        [漢字(ㄏㄢˋㄗˋ)][link]\n        [漢字(ㄏㄢˋㄗˋ)](/url \"title\")\n\n        [link]: /url \"title\"\n\n    :param md: Markdown instance\n    \"\"\"\n    md.inline.register('ruby', RUBY_PATTERN, parse_ruby, before='link')\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('ruby', render_ruby)"
    },
    {
      "path": "src/mistune/plugins/speedup.py",
      "version": "new",
      "line": 13,
      "kind": "module",
      "qualname": "src.mistune.plugins.speedup",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/speedup.py",
      "version": "new",
      "line": 24,
      "kind": "function",
      "qualname": "src.mistune.plugins.speedup.parse_text",
      "span": [
        22,
        26
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_text(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)\n    text = HARD_LINEBREAK_RE.sub(\"\\n\", text)\n    inline.process_text(text, state)\n    return m.end()",
      "old_code": "def parse_text(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)\n    text = HARD_LINEBREAK_RE.sub('\\n', text)\n    inline.process_text(text, state)\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/speedup.py",
      "version": "new",
      "line": 37,
      "kind": "function",
      "qualname": "src.mistune.plugins.speedup.speedup",
      "span": [
        35,
        50
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def speedup(md: \"Markdown\") -> None:\n    \"\"\"Increase the speed of parsing paragraph and inline text.\"\"\"\n    md.block.register(\"paragraph\", PARAGRAPH, parse_paragraph)\n\n    punc = r\"\\\\><!\\[_*`~\\^\\$=\"\n    text_pattern = r\"[\\s\\S]+?(?=[\" + punc + r\"]|\"\n    if \"url_link\" in md.inline.rules:\n        text_pattern += \"https?:|\"\n\n    if md.inline.hard_wrap:\n        text_pattern += r\" *\\n|\"\n    else:\n        text_pattern += r\" {2,}\\n|\"\n\n    text_pattern += r\"$)\"\n    md.inline.register(\"text\", text_pattern, parse_text)",
      "old_code": "def speedup(md: \"Markdown\") -> None:\n    \"\"\"Increase the speed of parsing paragraph and inline text.\"\"\"\n    md.block.register('paragraph', PARAGRAPH, parse_paragraph)\n\n    punc = r'\\\\><!\\[_*`~\\^\\$='\n    text_pattern = r'[\\s\\S]+?(?=[' + punc + r']|'\n    if 'url_link' in md.inline.rules:\n        text_pattern += 'https?:|'\n\n    if md.inline.hard_wrap:\n        text_pattern += r' *\\n|'\n    else:\n        text_pattern += r' {2,}\\n|'\n\n    text_pattern += r'$)'\n    md.inline.register('text', text_pattern, parse_text)"
    },
    {
      "path": "src/mistune/plugins/spoiler.py",
      "version": "new",
      "line": 10,
      "kind": "module",
      "qualname": "src.mistune.plugins.spoiler",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/spoiler.py",
      "version": "new",
      "line": 18,
      "kind": "function",
      "qualname": "src.mistune.plugins.spoiler.parse_block_spoiler",
      "span": [
        18,
        46
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_block_spoiler(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    text, end_pos = block.extract_block_quote(m, state)\n    if not text.endswith(\"\\n\"):\n        # ensure it endswith \\n to make sure\n        # _BLOCK_SPOILER_MATCH.match works\n        text += \"\\n\"\n\n    depth = state.depth()\n    if not depth and _BLOCK_SPOILER_MATCH.match(text):\n        text = _BLOCK_SPOILER_START.sub(\"\", text)\n        tok_type = \"block_spoiler\"\n    else:\n        tok_type = \"block_quote\"\n\n    # scan children state\n    child = state.child_state(text)\n    if state.depth() >= block.max_nested_level - 1:\n        rules = list(block.block_quote_rules)\n        rules.remove(\"block_quote\")\n    else:\n        rules = block.block_quote_rules\n\n    block.parse(child, rules)\n    token = {\"type\": tok_type, \"children\": child.tokens}\n    if end_pos:\n        state.prepend_token(token)\n        return end_pos\n    state.append_token(token)\n    return state.cursor",
      "old_code": "def parse_block_spoiler(\n    block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n) -> int:\n    text, end_pos = block.extract_block_quote(m, state)\n    if not text.endswith('\\n'):\n        # ensure it endswith \\n to make sure\n        # _BLOCK_SPOILER_MATCH.match works\n        text += '\\n'\n\n    depth = state.depth()\n    if not depth and _BLOCK_SPOILER_MATCH.match(text):\n        text = _BLOCK_SPOILER_START.sub('', text)\n        tok_type = 'block_spoiler'\n    else:\n        tok_type = 'block_quote'\n\n    # scan children state\n    child = state.child_state(text)\n    if state.depth() >= block.max_nested_level - 1:\n        rules = list(block.block_quote_rules)\n        rules.remove('block_quote')\n    else:\n        rules = block.block_quote_rules\n\n    block.parse(child, rules)\n    token = {'type': tok_type, 'children': child.tokens}\n    if end_pos:\n        state.prepend_token(token)\n        return end_pos\n    state.append_token(token)\n    return state.cursor"
    },
    {
      "path": "src/mistune/plugins/spoiler.py",
      "version": "new",
      "line": 49,
      "kind": "function",
      "qualname": "src.mistune.plugins.spoiler.parse_inline_spoiler",
      "span": [
        49,
        55
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_inline_spoiler(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(\"spoiler_text\")\n    new_state = state.copy()\n    new_state.src = text\n    children = inline.render(new_state)\n    state.append_token({\"type\": \"inline_spoiler\", \"children\": children})\n    return m.end()",
      "old_code": "def parse_inline_spoiler(\n    inline: \"InlineParser\", m: Match[str], state: \"InlineState\"\n) -> int:\n    text = m.group(\"spoiler_text\")\n    new_state = state.copy()\n    new_state.src = text\n    children = inline.render(new_state)\n    state.append_token({'type': 'inline_spoiler', 'children': children})\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/spoiler.py",
      "version": "new",
      "line": 83,
      "kind": "function",
      "qualname": "src.mistune.plugins.spoiler.spoiler",
      "span": [
        66,
        87
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def spoiler(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support block and inline spoiler. The\n    syntax is inspired by stackexchange:\n\n    .. code-block:: text\n\n        Block level spoiler looks like block quote, but with `>!`:\n\n        >! this is spoiler\n        >!\n        >! the content will be hidden\n\n        Inline spoiler is surrounded by `>!` and `!<`, such as >! hide me !<.\n\n    :param md: Markdown instance\n    \"\"\"\n    # reset block quote parser with block spoiler parser\n    md.block.register(\"block_quote\", None, parse_block_spoiler)\n    md.inline.register(\"inline_spoiler\", INLINE_SPOILER_PATTERN, parse_inline_spoiler)\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"block_spoiler\", render_block_spoiler)\n        md.renderer.register(\"inline_spoiler\", render_inline_spoiler)",
      "old_code": "def spoiler(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support block and inline spoiler. The\n    syntax is inspired by stackexchange:\n\n    .. code-block:: text\n\n        Block level spoiler looks like block quote, but with `>!`:\n\n        >! this is spoiler\n        >!\n        >! the content will be hidden\n\n        Inline spoiler is surrounded by `>!` and `!<`, such as >! hide me !<.\n\n    :param md: Markdown instance\n    \"\"\"\n    # reset block quote parser with block spoiler parser\n    md.block.register('block_quote', None, parse_block_spoiler)\n    md.inline.register('inline_spoiler', INLINE_SPOILER_PATTERN, parse_inline_spoiler)\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('block_spoiler', render_block_spoiler)\n        md.renderer.register('inline_spoiler', render_inline_spoiler)"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 22,
      "kind": "module",
      "qualname": "src.mistune.plugins.table",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 43,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.parse_table",
      "span": [
        43,
        65
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_table(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n    pos = m.end()\n    header = m.group(\"table_head\")\n    align = m.group(\"table_align\")\n    thead, aligns = _process_thead(header, align)\n    if not thead:\n        return None\n    assert aligns is not None\n\n    rows = []\n    body = m.group(\"table_body\")\n    for text in body.splitlines():\n        m2 = TABLE_CELL.match(text)\n        if not m2:  # pragma: no cover\n            return None\n        row = _process_row(m2.group(1), aligns)\n        if not row:\n            return None\n        rows.append(row)\n\n    children = [thead, {\"type\": \"table_body\", \"children\": rows}]\n    state.append_token({\"type\": \"table\", \"children\": children})\n    return pos",
      "old_code": "def parse_table(\n    block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n) -> Optional[int]:\n    pos = m.end()\n    header = m.group('table_head')\n    align = m.group('table_align')\n    thead, aligns = _process_thead(header, align)\n    if not thead:\n        return None\n    assert aligns is not None\n\n    rows = []\n    body = m.group('table_body')\n    for text in body.splitlines():\n        m2 = TABLE_CELL.match(text)\n        if not m2:  # pragma: no cover\n            return None\n        row = _process_row(m2.group(1), aligns)\n        if not row:\n            return None\n        rows.append(row)\n\n    children = [thead, {'type': 'table_body', 'children': rows}]\n    state.append_token({'type': 'table', 'children': children})\n    return pos"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 68,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.parse_nptable",
      "span": [
        68,
        86
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_nptable(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> Optional[int]:\n    header = m.group(\"nptable_head\")\n    align = m.group(\"nptable_align\")\n    thead, aligns = _process_thead(header, align)\n    if not thead:\n        return None\n    assert aligns is not None\n\n    rows = []\n    body = m.group(\"nptable_body\")\n    for text in body.splitlines():\n        row = _process_row(text, aligns)\n        if not row:\n            return None\n        rows.append(row)\n\n    children = [thead, {\"type\": \"table_body\", \"children\": rows}]\n    state.append_token({\"type\": \"table\", \"children\": children})\n    return m.end()",
      "old_code": "def parse_nptable(\n    block: \"BlockParser\", m: Match[str], state: \"BlockState\"\n) -> Optional[int]:\n    header = m.group(\"nptable_head\")\n    align = m.group(\"nptable_align\")\n    thead, aligns = _process_thead(header, align)\n    if not thead:\n        return None\n    assert aligns is not None\n\n    rows = []\n    body = m.group('nptable_body')\n    for text in body.splitlines():\n        row = _process_row(text, aligns)\n        if not row:\n            return None\n        rows.append(row)\n\n    children = [thead, {'type': 'table_body', 'children': rows}]\n    state.append_token({'type': 'table', 'children': children})\n    return m.end()"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 89,
      "kind": "function",
      "qualname": "src.mistune.plugins.table._process_thead",
      "span": [
        89,
        110
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _process_thead(header: str, align: str) -> Union[Tuple[None, None], Tuple[Dict[str, Any], List[str]]]:\n    headers = CELL_SPLIT.split(header)\n    aligns = CELL_SPLIT.split(align)\n    if len(headers) != len(aligns):\n        return None, None\n\n    for i, v in enumerate(aligns):\n        if ALIGN_CENTER.match(v):\n            aligns[i] = \"center\"\n        elif ALIGN_LEFT.match(v):\n            aligns[i] = \"left\"\n        elif ALIGN_RIGHT.match(v):\n            aligns[i] = \"right\"\n        else:\n            aligns[i] = None\n\n    children = [\n        {\"type\": \"table_cell\", \"text\": text.strip(), \"attrs\": {\"align\": aligns[i], \"head\": True}}\n        for i, text in enumerate(headers)\n    ]\n    thead = {\"type\": \"table_head\", \"children\": children}\n    return thead, aligns",
      "old_code": "def _process_thead(\n    header: str, align: str\n) -> Union[Tuple[None, None], Tuple[Dict[str, Any], List[str]]]:\n    headers = CELL_SPLIT.split(header)\n    aligns = CELL_SPLIT.split(align)\n    if len(headers) != len(aligns):\n      return None, None\n\n    for i, v in enumerate(aligns):\n        if ALIGN_CENTER.match(v):\n            aligns[i] = 'center'\n        elif ALIGN_LEFT.match(v):\n            aligns[i] = 'left'\n        elif ALIGN_RIGHT.match(v):\n            aligns[i] = 'right'\n        else:\n            aligns[i] = None\n\n    children = [\n        {\n            'type': 'table_cell',\n            'text': text.strip(),\n            'attrs': {'align': aligns[i], 'head': True}\n        }\n        for i, text in enumerate(headers)\n    ]\n    thead = {'type': 'table_head', 'children': children}\n    return thead, aligns"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 119,
      "kind": "function",
      "qualname": "src.mistune.plugins.table._process_row",
      "span": [
        113,
        122
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _process_row(text: str, aligns: List[str]) -> Optional[Dict[str, Any]]:\n    cells = CELL_SPLIT.split(text)\n    if len(cells) != len(aligns):\n        return None\n\n    children = [\n        {\"type\": \"table_cell\", \"text\": text.strip(), \"attrs\": {\"align\": aligns[i], \"head\": False}}\n        for i, text in enumerate(cells)\n    ]\n    return {\"type\": \"table_row\", \"children\": children}",
      "old_code": "def _process_row(text: str, aligns: List[str]) -> Optional[Dict[str, Any]]:\n    cells = CELL_SPLIT.split(text)\n    if len(cells) != len(aligns):\n        return None\n\n    children = [\n        {\n            'type': 'table_cell',\n            'text': text.strip(),\n            'attrs': {'align': aligns[i], 'head': False}\n        }\n        for i, text in enumerate(cells)\n    ]\n    return {'type': 'table_row', 'children': children}"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 141,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.render_table_cell",
      "span": [
        141,
        151
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_table_cell(renderer: \"BaseRenderer\", text: str, align: Optional[str] = None, head: bool = False) -> str:\n    if head:\n        tag = \"th\"\n    else:\n        tag = \"td\"\n\n    html = \"  <\" + tag\n    if align:\n        html += ' style=\"text-align:' + align + '\"'\n\n    return html + \">\" + text + \"</\" + tag + \">\\n\"",
      "old_code": "def render_table_cell(\n    renderer: \"BaseRenderer\", text: str, align: Optional[str] = None, head: bool = False\n) -> str:\n    if head:\n        tag = 'th'\n    else:\n        tag = 'td'\n\n    html = '  <' + tag\n    if align:\n        html += ' style=\"text-align:' + align + '\"'\n\n    return html + '>' + text + '</' + tag + '>\\n'"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 169,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.table",
      "span": [
        154,
        177
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def table(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support table, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#table\n\n    Here is an example:\n\n    .. code-block:: text\n\n        First Header  | Second Header\n        ------------- | -------------\n        Content Cell  | Content Cell\n        Content Cell  | Content Cell\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register(\"table\", TABLE_PATTERN, parse_table, before=\"paragraph\")\n    md.block.register(\"nptable\", NP_TABLE_PATTERN, parse_nptable, before=\"paragraph\")\n\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"table\", render_table)\n        md.renderer.register(\"table_head\", render_table_head)\n        md.renderer.register(\"table_body\", render_table_body)\n        md.renderer.register(\"table_row\", render_table_row)\n        md.renderer.register(\"table_cell\", render_table_cell)",
      "old_code": "def table(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support table, spec defined at\n    https://michelf.ca/projects/php-markdown/extra/#table\n\n    Here is an example:\n\n    .. code-block:: text\n\n        First Header  | Second Header\n        ------------- | -------------\n        Content Cell  | Content Cell\n        Content Cell  | Content Cell\n\n    :param md: Markdown instance\n    \"\"\"\n    md.block.register('table', TABLE_PATTERN, parse_table, before='paragraph')\n    md.block.register('nptable', NP_TABLE_PATTERN, parse_nptable, before='paragraph')\n\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('table', render_table)\n        md.renderer.register('table_head', render_table_head)\n        md.renderer.register('table_body', render_table_body)\n        md.renderer.register('table_row', render_table_row)\n        md.renderer.register('table_cell', render_table_cell)"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 182,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.table_in_quote",
      "span": [
        180,
        183
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def table_in_quote(md: \"Markdown\") -> None:\n    \"\"\"Enable table plugin in block quotes.\"\"\"\n    md.block.insert_rule(md.block.block_quote_rules, \"table\", before=\"paragraph\")\n    md.block.insert_rule(md.block.block_quote_rules, \"nptable\", before=\"paragraph\")",
      "old_code": "def table_in_quote(md: \"Markdown\") -> None:\n    \"\"\"Enable table plugin in block quotes.\"\"\"\n    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')\n    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')"
    },
    {
      "path": "src/mistune/plugins/table.py",
      "version": "new",
      "line": 188,
      "kind": "function",
      "qualname": "src.mistune.plugins.table.table_in_list",
      "span": [
        186,
        189
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def table_in_list(md: \"Markdown\") -> None:\n    \"\"\"Enable table plugin in list.\"\"\"\n    md.block.insert_rule(md.block.list_rules, \"table\", before=\"paragraph\")\n    md.block.insert_rule(md.block.list_rules, \"nptable\", before=\"paragraph\")",
      "old_code": "def table_in_list(md: \"Markdown\") -> None:\n    \"\"\"Enable table plugin in list.\"\"\"\n    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')\n    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')"
    },
    {
      "path": "src/mistune/plugins/task_lists.py",
      "version": "new",
      "line": 8,
      "kind": "module",
      "qualname": "src.mistune.plugins.task_lists",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/task_lists.py",
      "version": "new",
      "line": 18,
      "kind": "function",
      "qualname": "src.mistune.plugins.task_lists.render_task_list_item",
      "span": [
        18,
        30
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_task_list_item(renderer: \"BaseRenderer\", text: str, checked: bool = False) -> str:\n    checkbox = '<input class=\"task-list-item-checkbox\" type=\"checkbox\" disabled'\n    if checked:\n        checkbox += \" checked/>\"\n    else:\n        checkbox += \"/>\"\n\n    if text.startswith(\"<p>\"):\n        text = text.replace(\"<p>\", \"<p>\" + checkbox, 1)\n    else:\n        text = checkbox + text\n\n    return '<li class=\"task-list-item\">' + text + \"</li>\\n\"",
      "old_code": "def render_task_list_item(\n    renderer: \"BaseRenderer\", text: str, checked: bool = False\n) -> str:\n    checkbox = '<input class=\"task-list-item-checkbox\" ' 'type=\"checkbox\" disabled'\n    if checked:\n        checkbox += ' checked/>'\n    else:\n        checkbox += '/>'\n\n    if text.startswith('<p>'):\n        text = text.replace('<p>', '<p>' + checkbox, 1)\n    else:\n        text = checkbox + text\n\n    return '<li class=\"task-list-item\">' + text + '</li>\\n'"
    },
    {
      "path": "src/mistune/plugins/task_lists.py",
      "version": "new",
      "line": 45,
      "kind": "function",
      "qualname": "src.mistune.plugins.task_lists.task_lists",
      "span": [
        33,
        46
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def task_lists(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support task lists. Spec defined by\n    GitHub flavored Markdown and commonly used by many parsers:\n\n    .. code-block:: text\n\n        - [ ] unchecked task\n        - [x] checked task\n\n    :param md: Markdown instance\n    \"\"\"\n    md.before_render_hooks.append(task_lists_hook)\n    if md.renderer and md.renderer.NAME == \"html\":\n        md.renderer.register(\"task_list_item\", render_task_list_item)",
      "old_code": "def task_lists(md: \"Markdown\") -> None:\n    \"\"\"A mistune plugin to support task lists. Spec defined by\n    GitHub flavored Markdown and commonly used by many parsers:\n\n    .. code-block:: text\n\n        - [ ] unchecked task\n        - [x] checked task\n\n    :param md: Markdown instance\n    \"\"\"\n    md.before_render_hooks.append(task_lists_hook)\n    if md.renderer and md.renderer.NAME == 'html':\n        md.renderer.register('task_list_item', render_task_list_item)"
    },
    {
      "path": "src/mistune/plugins/task_lists.py",
      "version": "new",
      "line": 49,
      "kind": "function",
      "qualname": "src.mistune.plugins.task_lists._rewrite_all_list_items",
      "span": [
        49,
        55
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _rewrite_all_list_items(tokens: Iterable[Dict[str, Any]]) -> Iterable[Dict[str, Any]]:\n    for tok in tokens:\n        if tok[\"type\"] == \"list_item\":\n            _rewrite_list_item(tok)\n        if \"children\" in tok:\n            _rewrite_all_list_items(tok[\"children\"])\n    return tokens",
      "old_code": "def _rewrite_all_list_items(\n    tokens: Iterable[Dict[str, Any]]\n) -> Iterable[Dict[str, Any]]:\n    for tok in tokens:\n        if tok['type'] == 'list_item':\n            _rewrite_list_item(tok)\n        if 'children' in tok:\n            _rewrite_all_list_items(tok['children'])\n    return tokens"
    },
    {
      "path": "src/mistune/plugins/task_lists.py",
      "version": "new",
      "line": 59,
      "kind": "function",
      "qualname": "src.mistune.plugins.task_lists._rewrite_list_item",
      "span": [
        58,
        69
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _rewrite_list_item(tok: Dict[str, Any]) -> None:\n    children = tok[\"children\"]\n    if children:\n        first_child = children[0]\n        text = first_child.get(\"text\", \"\")\n        m = TASK_LIST_ITEM.match(text)\n        if m:\n            mark = m.group(1)\n            first_child[\"text\"] = text[m.end() :]\n\n            tok[\"type\"] = \"task_list_item\"\n            tok[\"attrs\"] = {\"checked\": mark != \"[ ]\"}",
      "old_code": "def _rewrite_list_item(tok: Dict[str, Any]) -> None:\n    children = tok['children']\n    if children:\n        first_child = children[0]\n        text = first_child.get('text', '')\n        m = TASK_LIST_ITEM.match(text)\n        if m:\n            mark = m.group(1)\n            first_child['text'] = text[m.end():]\n\n            tok['type'] = 'task_list_item'\n            tok['attrs'] = {'checked': mark != '[ ]'}"
    },
    {
      "path": "src/mistune/plugins/url.py",
      "version": "new",
      "line": 10,
      "kind": "module",
      "qualname": "src.mistune.plugins.url",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/plugins/url.py",
      "version": "new",
      "line": 21,
      "kind": "function",
      "qualname": "src.mistune.plugins.url.parse_url_link",
      "span": [
        15,
        28
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_url_link(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)\n    pos = m.end()\n    if state.in_link:\n        inline.process_text(text, state)\n        return pos\n    state.append_token(\n        {\n            \"type\": \"link\",\n            \"children\": [{\"type\": \"text\", \"raw\": text}],\n            \"attrs\": {\"url\": escape_url(text)},\n        }\n    )\n    return pos",
      "old_code": "def parse_url_link(inline: \"InlineParser\", m: Match[str], state: \"InlineState\") -> int:\n    text = m.group(0)\n    pos = m.end()\n    if state.in_link:\n        inline.process_text(text, state)\n        return pos\n    state.append_token({\n        'type': 'link',\n        'children': [{'type': 'text', 'raw': text}],\n        'attrs': {'url': escape_url(text)},\n    })\n    return pos"
    },
    {
      "path": "src/mistune/renderers/_list.py",
      "version": "new",
      "line": 9,
      "kind": "function",
      "qualname": "src.mistune.renderers._list.render_list",
      "span": [
        9,
        22
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_list(renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\") -> str:\n    attrs = token[\"attrs\"]\n    if attrs[\"ordered\"]:\n        children = _render_ordered_list(renderer, token, state)\n    else:\n        children = _render_unordered_list(renderer, token, state)\n\n    text = \"\".join(children)\n    parent = token.get(\"parent\")\n    if parent:\n        if parent[\"tight\"]:\n            return text\n        return text + \"\\n\"\n    return strip_end(text) + \"\\n\"",
      "old_code": "def render_list(\n    renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\"\n) -> str:\n    attrs = token[\"attrs\"]\n    if attrs[\"ordered\"]:\n        children = _render_ordered_list(renderer, token, state)\n    else:\n        children = _render_unordered_list(renderer, token, state)\n\n    text = ''.join(children)\n    parent = token.get('parent')\n    if parent:\n        if parent['tight']:\n            return text\n        return text + '\\n'\n    return strip_end(text) + '\\n'"
    },
    {
      "path": "src/mistune/renderers/_list.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "src.mistune.renderers._list._render_list_item",
      "span": [
        25,
        48
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _render_list_item(\n    renderer: \"BaseRenderer\",\n    parent: Dict[str, Any],\n    item: Dict[str, Any],\n    state: \"BlockState\",\n) -> str:\n    leading = cast(str, parent[\"leading\"])\n    text = \"\"\n    for tok in item[\"children\"]:\n        if tok[\"type\"] == \"list\":\n            tok[\"parent\"] = parent\n        elif tok[\"type\"] == \"blank_line\":\n            continue\n        text += renderer.render_token(tok, state)\n\n    lines = text.splitlines()\n    text = (lines[0] if lines else \"\") + \"\\n\"\n    prefix = \" \" * len(leading)\n    for line in lines[1:]:\n        if line:\n            text += prefix + line + \"\\n\"\n        else:\n            text += \"\\n\"\n    return leading + text",
      "old_code": "def _render_list_item(\n    renderer: \"BaseRenderer\",\n    parent: Dict[str, Any],\n    item: Dict[str, Any],\n    state: \"BlockState\",\n) -> str:\n    leading = cast(str, parent[\"leading\"])\n    text = \"\"\n    for tok in item[\"children\"]:\n        if tok[\"type\"] == \"list\":\n            tok[\"parent\"] = parent\n        elif tok[\"type\"] == \"blank_line\":\n            continue\n        text += renderer.render_token(tok, state)\n\n    lines = text.splitlines()\n    text = (lines[0] if lines else '') + '\\n'\n    prefix = ' ' * len(leading)\n    for line in lines[1:]:\n        if line:\n            text += prefix + line + '\\n'\n        else:\n            text += '\\n'\n    return leading + text"
    },
    {
      "path": "src/mistune/renderers/_list.py",
      "version": "new",
      "line": 51,
      "kind": "function",
      "qualname": "src.mistune.renderers._list._render_ordered_list",
      "span": [
        51,
        61
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _render_ordered_list(renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\") -> Iterable[str]:\n    attrs = token[\"attrs\"]\n    start = attrs.get(\"start\", 1)\n    for item in token[\"children\"]:\n        leading = str(start) + token[\"bullet\"] + \" \"\n        parent = {\n            \"leading\": leading,\n            \"tight\": token[\"tight\"],\n        }\n        yield _render_list_item(renderer, parent, item, state)\n        start += 1",
      "old_code": "def _render_ordered_list(\n    renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\"\n) -> Iterable[str]:\n    attrs = token[\"attrs\"]\n    start = attrs.get(\"start\", 1)\n    for item in token[\"children\"]:\n        leading = str(start) + token[\"bullet\"] + \" \"\n        parent = {\n            'leading': leading,\n            'tight': token['tight'],\n        }\n        yield _render_list_item(renderer, parent, item, state)\n        start += 1"
    },
    {
      "path": "src/mistune/renderers/_list.py",
      "version": "new",
      "line": 64,
      "kind": "function",
      "qualname": "src.mistune.renderers._list._render_unordered_list",
      "span": [
        64,
        70
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _render_unordered_list(renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\") -> Iterable[str]:\n    parent = {\n        \"leading\": token[\"bullet\"] + \" \",\n        \"tight\": token[\"tight\"],\n    }\n    for item in token[\"children\"]:\n        yield _render_list_item(renderer, parent, item, state)",
      "old_code": "def _render_unordered_list(\n    renderer: \"BaseRenderer\", token: Dict[str, Any], state: \"BlockState\"\n) -> Iterable[str]:\n    parent = {\n        'leading': token['bullet'] + ' ',\n        'tight': token['tight'],\n    }\n    for item in token['children']:\n        yield _render_list_item(renderer, parent, item, state)"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 13,
      "kind": "class",
      "qualname": "src.mistune.renderers.html.HTMLRenderer",
      "span": [
        7,
        153
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class HTMLRenderer(BaseRenderer):\n    \"\"\"A renderer for converting Markdown to HTML.\"\"\"\n\n    _escape: bool\n    NAME: ClassVar[Literal[\"html\"]] = \"html\"\n    HARMFUL_PROTOCOLS: ClassVar[Tuple[str, ...]] = (\n        \"javascript:\",\n        \"vbscript:\",\n        \"file:\",\n        \"data:\",\n    )\n    GOOD_DATA_PROTOCOLS: ClassVar[Tuple[str, ...]] = (\n        \"data:image/gif;\",\n        \"data:image/png;\",\n        \"data:image/jpeg;\",\n        \"data:image/webp;\",\n    )\n\n    def __init__(self, escape: bool = True, allow_harmful_protocols: Optional[bool] = None) -> None:\n        super(HTMLRenderer, self).__init__()\n        self._allow_harmful_protocols = allow_harmful_protocols\n        self._escape = escape\n\n    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        # backward compitable with v2\n        func = self._get_method(token[\"type\"])\n        attrs = token.get(\"attrs\")\n\n        if \"raw\" in token:\n            text = token[\"raw\"]\n        elif \"children\" in token:\n            text = self.render_tokens(token[\"children\"], state)\n        else:\n            if attrs:\n                return func(**attrs)\n            else:\n                return func()\n        if attrs:\n            return func(text, **attrs)\n        else:\n            return func(text)\n\n    def safe_url(self, url: str) -> str:\n        \"\"\"Ensure the given URL is safe. This method is used for rendering\n        links, images, and etc.\n        \"\"\"\n        if self._allow_harmful_protocols is True:\n            return escape_text(url)\n\n        _url = url.lower()\n        if self._allow_harmful_protocols and _url.startswith(tuple(self._allow_harmful_protocols)):\n            return escape_text(url)\n\n        if _url.startswith(self.HARMFUL_PROTOCOLS) and not _url.startswith(self.GOOD_DATA_PROTOCOLS):\n            return \"#harmful-link\"\n        return escape_text(url)\n\n    def text(self, text: str) -> str:\n        if self._escape:\n            return escape_text(text)\n        return safe_entity(text)\n\n    def emphasis(self, text: str) -> str:\n        return \"<em>\" + text + \"</em>\"\n\n    def strong(self, text: str) -> str:\n        return \"<strong>\" + text + \"</strong>\"\n\n    def link(self, text: str, url: str, title: Optional[str] = None) -> str:\n        s = '<a href=\"' + self.safe_url(url) + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + \">\" + text + \"</a>\"\n\n    def image(self, text: str, url: str, title: Optional[str] = None) -> str:\n        src = self.safe_url(url)\n        alt = escape_text(striptags(text))\n        s = '<img src=\"' + src + '\" alt=\"' + alt + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + \" />\"\n\n    def codespan(self, text: str) -> str:\n        return \"<code>\" + escape_text(text) + \"</code>\"\n\n    def linebreak(self) -> str:\n        return \"<br />\\n\"\n\n    def softbreak(self) -> str:\n        return \"\\n\"\n\n    def inline_html(self, html: str) -> str:\n        if self._escape:\n            return escape_text(html)\n        return html\n\n    def paragraph(self, text: str) -> str:\n        return \"<p>\" + text + \"</p>\\n\"\n\n    def heading(self, text: str, level: int, **attrs: Any) -> str:\n        tag = \"h\" + str(level)\n        html = \"<\" + tag\n        _id = attrs.get(\"id\")\n        if _id:\n            html += ' id=\"' + _id + '\"'\n        return html + \">\" + text + \"</\" + tag + \">\\n\"\n\n    def blank_line(self) -> str:\n        return \"\"\n\n    def thematic_break(self) -> str:\n        return \"<hr />\\n\"\n\n    def block_text(self, text: str) -> str:\n        return text\n\n    def block_code(self, code: str, info: Optional[str] = None) -> str:\n        html = \"<pre><code\"\n        if info is not None:\n            info = safe_entity(info.strip())\n        if info:\n            lang = info.split(None, 1)[0]\n            html += ' class=\"language-' + lang + '\"'\n        return html + \">\" + escape_text(code) + \"</code></pre>\\n\"\n\n    def block_quote(self, text: str) -> str:\n        return \"<blockquote>\\n\" + text + \"</blockquote>\\n\"\n\n    def block_html(self, html: str) -> str:\n        if self._escape:\n            return \"<p>\" + escape_text(html.strip()) + \"</p>\\n\"\n        return html + \"\\n\"\n\n    def block_error(self, text: str) -> str:\n        return '<div class=\"error\"><pre>' + text + \"</pre></div>\\n\"\n\n    def list(self, text: str, ordered: bool, **attrs: Any) -> str:\n        if ordered:\n            html = \"<ol\"\n            start = attrs.get(\"start\")\n            if start is not None:\n                html += ' start=\"' + str(start) + '\"'\n            return html + \">\\n\" + text + \"</ol>\\n\"\n        return \"<ul>\\n\" + text + \"</ul>\\n\"\n\n    def list_item(self, text: str) -> str:\n        return \"<li>\" + text + \"</li>\\n\"",
      "old_code": "class HTMLRenderer(BaseRenderer):\n    \"\"\"A renderer for converting Markdown to HTML.\"\"\"\n\n    _escape: bool\n    NAME: ClassVar[Literal[\"html\"]] = \"html\"\n    HARMFUL_PROTOCOLS: ClassVar[Tuple[str, ...]] = (\n        'javascript:',\n        'vbscript:',\n        'file:',\n        'data:',\n    )\n    GOOD_DATA_PROTOCOLS: ClassVar[Tuple[str, ...]] = (\n        'data:image/gif;',\n        'data:image/png;',\n        'data:image/jpeg;',\n        'data:image/webp;',\n    )\n\n    def __init__(\n        self, escape: bool = True, allow_harmful_protocols: Optional[bool] = None\n    ) -> None:\n        super(HTMLRenderer, self).__init__()\n        self._allow_harmful_protocols = allow_harmful_protocols\n        self._escape = escape\n\n    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        # backward compitable with v2\n        func = self._get_method(token['type'])\n        attrs = token.get('attrs')\n\n        if 'raw' in token:\n            text = token['raw']\n        elif 'children' in token:\n            text = self.render_tokens(token['children'], state)\n        else:\n            if attrs:\n                return func(**attrs)\n            else:\n                return func()\n        if attrs:\n            return func(text, **attrs)\n        else:\n            return func(text)\n\n    def safe_url(self, url: str) -> str:\n        \"\"\"Ensure the given URL is safe. This method is used for rendering\n        links, images, and etc.\n        \"\"\"\n        if self._allow_harmful_protocols is True:\n            return escape_text(url)\n\n        _url = url.lower()\n        if self._allow_harmful_protocols and \\\n            _url.startswith(tuple(self._allow_harmful_protocols)):\n            return escape_text(url)\n\n        if _url.startswith(self.HARMFUL_PROTOCOLS) and \\\n            not _url.startswith(self.GOOD_DATA_PROTOCOLS):\n            return '#harmful-link'\n        return escape_text(url)\n\n    def text(self, text: str) -> str:\n        if self._escape:\n            return escape_text(text)\n        return safe_entity(text)\n\n    def emphasis(self, text: str) -> str:\n        return '<em>' + text + '</em>'\n\n    def strong(self, text: str) -> str:\n        return '<strong>' + text + '</strong>'\n\n    def link(self, text: str, url: str, title: Optional[str] = None) -> str:\n        s = '<a href=\"' + self.safe_url(url) + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + '>' + text + '</a>'\n\n    def image(self, text: str, url: str, title: Optional[str] = None) -> str:\n        src = self.safe_url(url)\n        alt = escape_text(striptags(text))\n        s = '<img src=\"' + src + '\" alt=\"' + alt + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + ' />'\n\n    def codespan(self, text: str) -> str:\n        return '<code>' + escape_text(text) + '</code>'\n\n    def linebreak(self) -> str:\n        return '<br />\\n'\n\n    def softbreak(self) -> str:\n        return '\\n'\n\n    def inline_html(self, html: str) -> str:\n        if self._escape:\n            return escape_text(html)\n        return html\n\n    def paragraph(self, text: str) -> str:\n        return '<p>' + text + '</p>\\n'\n\n    def heading(self, text: str, level: int, **attrs: Any) -> str:\n        tag = 'h' + str(level)\n        html = '<' + tag\n        _id = attrs.get('id')\n        if _id:\n            html += ' id=\"' + _id + '\"'\n        return html + '>' + text + '</' + tag + '>\\n'\n\n    def blank_line(self) -> str:\n        return ''\n\n    def thematic_break(self) -> str:\n        return '<hr />\\n'\n\n    def block_text(self, text: str) -> str:\n        return text\n\n    def block_code(self, code: str, info: Optional[str] = None) -> str:\n        html = '<pre><code'\n        if info is not None:\n            info = safe_entity(info.strip())\n        if info:\n            lang = info.split(None, 1)[0]\n            html += ' class=\"language-' + lang + '\"'\n        return html + '>' + escape_text(code) + '</code></pre>\\n'\n\n    def block_quote(self, text: str) -> str:\n        return '<blockquote>\\n' + text + '</blockquote>\\n'\n\n    def block_html(self, html: str) -> str:\n        if self._escape:\n            return '<p>' + escape_text(html.strip()) + '</p>\\n'\n        return html + '\\n'\n\n    def block_error(self, text: str) -> str:\n        return '<div class=\"error\"><pre>' + text + '</pre></div>\\n'\n\n    def list(self, text: str, ordered: bool, **attrs: Any) -> str:\n        if ordered:\n            html = '<ol'\n            start = attrs.get('start')\n            if start is not None:\n                html += ' start=\"' + str(start) + '\"'\n            return html + '>\\n' + text + '</ol>\\n'\n        return '<ul>\\n' + text + '</ul>\\n'\n\n    def list_item(self, text: str) -> str:\n        return '<li>' + text + '</li>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 25,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.__init__",
      "span": [
        25,
        28
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, escape: bool = True, allow_harmful_protocols: Optional[bool] = None) -> None:\n        super(HTMLRenderer, self).__init__()\n        self._allow_harmful_protocols = allow_harmful_protocols\n        self._escape = escape",
      "old_code": "    def __init__(\n        self, escape: bool = True, allow_harmful_protocols: Optional[bool] = None\n    ) -> None:\n        super(HTMLRenderer, self).__init__()\n        self._allow_harmful_protocols = allow_harmful_protocols\n        self._escape = escape"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 32,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.render_token",
      "span": [
        30,
        47
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        # backward compitable with v2\n        func = self._get_method(token[\"type\"])\n        attrs = token.get(\"attrs\")\n\n        if \"raw\" in token:\n            text = token[\"raw\"]\n        elif \"children\" in token:\n            text = self.render_tokens(token[\"children\"], state)\n        else:\n            if attrs:\n                return func(**attrs)\n            else:\n                return func()\n        if attrs:\n            return func(text, **attrs)\n        else:\n            return func(text)",
      "old_code": "    def render_token(self, token: Dict[str, Any], state: BlockState) -> str:\n        # backward compitable with v2\n        func = self._get_method(token['type'])\n        attrs = token.get('attrs')\n\n        if 'raw' in token:\n            text = token['raw']\n        elif 'children' in token:\n            text = self.render_tokens(token['children'], state)\n        else:\n            if attrs:\n                return func(**attrs)\n            else:\n                return func()\n        if attrs:\n            return func(text, **attrs)\n        else:\n            return func(text)"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 57,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.safe_url",
      "span": [
        49,
        62
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def safe_url(self, url: str) -> str:\n        \"\"\"Ensure the given URL is safe. This method is used for rendering\n        links, images, and etc.\n        \"\"\"\n        if self._allow_harmful_protocols is True:\n            return escape_text(url)\n\n        _url = url.lower()\n        if self._allow_harmful_protocols and _url.startswith(tuple(self._allow_harmful_protocols)):\n            return escape_text(url)\n\n        if _url.startswith(self.HARMFUL_PROTOCOLS) and not _url.startswith(self.GOOD_DATA_PROTOCOLS):\n            return \"#harmful-link\"\n        return escape_text(url)",
      "old_code": "    def safe_url(self, url: str) -> str:\n        \"\"\"Ensure the given URL is safe. This method is used for rendering\n        links, images, and etc.\n        \"\"\"\n        if self._allow_harmful_protocols is True:\n            return escape_text(url)\n\n        _url = url.lower()\n        if self._allow_harmful_protocols and \\\n            _url.startswith(tuple(self._allow_harmful_protocols)):\n            return escape_text(url)\n\n        if _url.startswith(self.HARMFUL_PROTOCOLS) and \\\n            not _url.startswith(self.GOOD_DATA_PROTOCOLS):\n            return '#harmful-link'\n        return escape_text(url)"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 70,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.emphasis",
      "span": [
        69,
        70
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def emphasis(self, text: str) -> str:\n        return \"<em>\" + text + \"</em>\"",
      "old_code": "    def emphasis(self, text: str) -> str:\n        return '<em>' + text + '</em>'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 73,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.strong",
      "span": [
        72,
        73
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def strong(self, text: str) -> str:\n        return \"<strong>\" + text + \"</strong>\"",
      "old_code": "    def strong(self, text: str) -> str:\n        return '<strong>' + text + '</strong>'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 79,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.link",
      "span": [
        75,
        79
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def link(self, text: str, url: str, title: Optional[str] = None) -> str:\n        s = '<a href=\"' + self.safe_url(url) + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + \">\" + text + \"</a>\"",
      "old_code": "    def link(self, text: str, url: str, title: Optional[str] = None) -> str:\n        s = '<a href=\"' + self.safe_url(url) + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + '>' + text + '</a>'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 87,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.image",
      "span": [
        81,
        87
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def image(self, text: str, url: str, title: Optional[str] = None) -> str:\n        src = self.safe_url(url)\n        alt = escape_text(striptags(text))\n        s = '<img src=\"' + src + '\" alt=\"' + alt + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + \" />\"",
      "old_code": "    def image(self, text: str, url: str, title: Optional[str] = None) -> str:\n        src = self.safe_url(url)\n        alt = escape_text(striptags(text))\n        s = '<img src=\"' + src + '\" alt=\"' + alt + '\"'\n        if title:\n            s += ' title=\"' + safe_entity(title) + '\"'\n        return s + ' />'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 90,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.codespan",
      "span": [
        89,
        90
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def codespan(self, text: str) -> str:\n        return \"<code>\" + escape_text(text) + \"</code>\"",
      "old_code": "    def codespan(self, text: str) -> str:\n        return '<code>' + escape_text(text) + '</code>'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 93,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.linebreak",
      "span": [
        92,
        93
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def linebreak(self) -> str:\n        return \"<br />\\n\"",
      "old_code": "    def linebreak(self) -> str:\n        return '<br />\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 96,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.softbreak",
      "span": [
        95,
        96
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def softbreak(self) -> str:\n        return \"\\n\"",
      "old_code": "    def softbreak(self) -> str:\n        return '\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 104,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.paragraph",
      "span": [
        103,
        104
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def paragraph(self, text: str) -> str:\n        return \"<p>\" + text + \"</p>\\n\"",
      "old_code": "    def paragraph(self, text: str) -> str:\n        return '<p>' + text + '</p>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 107,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.heading",
      "span": [
        106,
        112
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def heading(self, text: str, level: int, **attrs: Any) -> str:\n        tag = \"h\" + str(level)\n        html = \"<\" + tag\n        _id = attrs.get(\"id\")\n        if _id:\n            html += ' id=\"' + _id + '\"'\n        return html + \">\" + text + \"</\" + tag + \">\\n\"",
      "old_code": "    def heading(self, text: str, level: int, **attrs: Any) -> str:\n        tag = 'h' + str(level)\n        html = '<' + tag\n        _id = attrs.get('id')\n        if _id:\n            html += ' id=\"' + _id + '\"'\n        return html + '>' + text + '</' + tag + '>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 115,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.blank_line",
      "span": [
        114,
        115
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def blank_line(self) -> str:\n        return \"\"",
      "old_code": "    def blank_line(self) -> str:\n        return ''"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 118,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.thematic_break",
      "span": [
        117,
        118
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def thematic_break(self) -> str:\n        return \"<hr />\\n\"",
      "old_code": "    def thematic_break(self) -> str:\n        return '<hr />\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 124,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.block_code",
      "span": [
        123,
        130
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_code(self, code: str, info: Optional[str] = None) -> str:\n        html = \"<pre><code\"\n        if info is not None:\n            info = safe_entity(info.strip())\n        if info:\n            lang = info.split(None, 1)[0]\n            html += ' class=\"language-' + lang + '\"'\n        return html + \">\" + escape_text(code) + \"</code></pre>\\n\"",
      "old_code": "    def block_code(self, code: str, info: Optional[str] = None) -> str:\n        html = '<pre><code'\n        if info is not None:\n            info = safe_entity(info.strip())\n        if info:\n            lang = info.split(None, 1)[0]\n            html += ' class=\"language-' + lang + '\"'\n        return html + '>' + escape_text(code) + '</code></pre>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 133,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.block_quote",
      "span": [
        132,
        133
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_quote(self, text: str) -> str:\n        return \"<blockquote>\\n\" + text + \"</blockquote>\\n\"",
      "old_code": "    def block_quote(self, text: str) -> str:\n        return '<blockquote>\\n' + text + '</blockquote>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 137,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.block_html",
      "span": [
        135,
        138
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_html(self, html: str) -> str:\n        if self._escape:\n            return \"<p>\" + escape_text(html.strip()) + \"</p>\\n\"\n        return html + \"\\n\"",
      "old_code": "    def block_html(self, html: str) -> str:\n        if self._escape:\n            return '<p>' + escape_text(html.strip()) + '</p>\\n'\n        return html + '\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 141,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.block_error",
      "span": [
        140,
        141
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_error(self, text: str) -> str:\n        return '<div class=\"error\"><pre>' + text + \"</pre></div>\\n\"",
      "old_code": "    def block_error(self, text: str) -> str:\n        return '<div class=\"error\"><pre>' + text + '</pre></div>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 145,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.list",
      "span": [
        143,
        150
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def list(self, text: str, ordered: bool, **attrs: Any) -> str:\n        if ordered:\n            html = \"<ol\"\n            start = attrs.get(\"start\")\n            if start is not None:\n                html += ' start=\"' + str(start) + '\"'\n            return html + \">\\n\" + text + \"</ol>\\n\"\n        return \"<ul>\\n\" + text + \"</ul>\\n\"",
      "old_code": "    def list(self, text: str, ordered: bool, **attrs: Any) -> str:\n        if ordered:\n            html = '<ol'\n            start = attrs.get('start')\n            if start is not None:\n                html += ' start=\"' + str(start) + '\"'\n            return html + '>\\n' + text + '</ol>\\n'\n        return '<ul>\\n' + text + '</ul>\\n'"
    },
    {
      "path": "src/mistune/renderers/html.py",
      "version": "new",
      "line": 153,
      "kind": "function",
      "qualname": "src.mistune.renderers.html.HTMLRenderer.list_item",
      "span": [
        152,
        153
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def list_item(self, text: str) -> str:\n        return \"<li>\" + text + \"</li>\\n\"",
      "old_code": "    def list_item(self, text: str) -> str:\n        return '<li>' + text + '</li>\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 9,
      "kind": "module",
      "qualname": "src.mistune.renderers.markdown",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 14,
      "kind": "class",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer",
      "span": [
        12,
        129
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class MarkdownRenderer(BaseRenderer):\n    \"\"\"A renderer to re-format Markdown text.\"\"\"\n\n    NAME = \"markdown\"\n\n    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += \"\\n\\n\".join(self.render_referrences(state)) + \"\\n\"\n        return strip_end(out)\n\n    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        ref_links = state.env[\"ref_links\"]\n        for key in ref_links:\n            attrs = ref_links[key]\n            text = \"[\" + attrs[\"label\"] + \"]: \" + attrs[\"url\"]\n            title = attrs.get(\"title\")\n            if title:\n                text += ' \"' + title + '\"'\n            yield text\n\n    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        return self.render_tokens(children, state)\n\n    def text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"])\n\n    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"*\" + self.render_children(token, state) + \"*\"\n\n    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"**\" + self.render_children(token, state) + \"**\"\n\n    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = \"[\" + text + \"]\"\n        if label:\n            return out + \"[\" + label + \"]\"\n\n        attrs = token[\"attrs\"]\n        url = attrs[\"url\"]\n        title = attrs.get(\"title\")\n        if text == url and not title:\n            return \"<\" + text + \">\"\n        elif \"mailto:\" + text == url and not title:\n            return \"<\" + text + \">\"\n\n        out += \"(\"\n        if \"(\" in url or \")\" in url:\n            out += \"<\" + url + \">\"\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + \")\"\n\n    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"!\" + self.link(token, state)\n\n    def codespan(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"`\" + cast(str, token[\"raw\"]) + \"`\"\n\n    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"  \\n\"\n\n    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\\n\"\n\n    def blank_line(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"\n\n    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"])\n\n    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = self.render_children(token, state)\n        return text + \"\\n\\n\"\n\n    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        level = cast(int, token[\"attrs\"][\"level\"])\n        marker = \"#\" * level\n        text = self.render_children(token, state)\n        return marker + \" \" + text + \"\\n\\n\"\n\n    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"***\\n\\n\"\n\n    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + \"\\n\"\n\n    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\", \"\"))\n        code = cast(str, token[\"raw\"])\n        if code and code[-1] != \"\\n\":\n            code += \"\\n\"\n\n        marker = token.get(\"marker\")\n        if not marker:\n            marker = _get_fenced_marker(code)\n        marker2 = cast(str, marker)\n        return marker2 + info + \"\\n\" + code + marker2 + \"\\n\\n\"\n\n    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), \"> \", lambda _: True)\n        text = text.rstrip(\"> \\n\")\n        return text + \"\\n\\n\"\n\n    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"]) + \"\\n\\n\"\n\n    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"\n\n    def list(self, token: Dict[str, Any], state: BlockState) -> str:\n        return render_list(self, token, state)",
      "old_code": "class MarkdownRenderer(BaseRenderer):\n    \"\"\"A renderer to re-format Markdown text.\"\"\"\n    NAME = 'markdown'\n\n    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += '\\n\\n'.join(self.render_referrences(state)) + '\\n'\n        return strip_end(out)\n\n    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        ref_links = state.env['ref_links']\n        for key in ref_links:\n            attrs = ref_links[key]\n            text = '[' + attrs['label'] + ']: ' + attrs['url']\n            title = attrs.get('title')\n            if title:\n                text += ' \"' + title + '\"'\n            yield text\n\n    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        return self.render_tokens(children, state)\n\n    def text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"])\n\n    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '*' + self.render_children(token, state) + '*'\n\n    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '**' + self.render_children(token, state) + '**'\n\n    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = '[' + text + ']'\n        if label:\n            return out + '[' + label + ']'\n\n        attrs = token['attrs']\n        url = attrs['url']\n        title = attrs.get('title')\n        if text == url and not title:\n            return '<' + text + '>'\n        elif 'mailto:' + text == url and not title:\n            return '<' + text + '>'\n\n        out += '('\n        if '(' in url or ')' in url:\n            out += '<' + url + '>'\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + ')'\n\n    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '!' + self.link(token, state)\n\n    def codespan(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"`\" + cast(str, token[\"raw\"]) + \"`\"\n\n    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '  \\n'\n\n    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '\\n'\n\n    def blank_line(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''\n\n    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"])\n\n    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = self.render_children(token, state)\n        return text + '\\n\\n'\n\n    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        level = cast(int, token[\"attrs\"][\"level\"])\n        marker = \"#\" * level\n        text = self.render_children(token, state)\n        return marker + ' ' + text + '\\n\\n'\n\n    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '***\\n\\n'\n\n    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + '\\n'\n\n    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\", \"\"))\n        code = cast(str, token[\"raw\"])\n        if code and code[-1] != \"\\n\":\n            code += \"\\n\"\n\n        marker = token.get('marker')\n        if not marker:\n            marker = _get_fenced_marker(code)\n        marker2 = cast(str, marker)\n        return marker2 + info + \"\\n\" + code + marker2 + \"\\n\\n\"\n\n    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), '> ', lambda _: True)\n        text = text.rstrip(\"> \\n\")\n        return text + '\\n\\n'\n\n    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        return cast(str, token[\"raw\"]) + \"\\n\\n\"\n\n    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''\n\n    def list(self, token: Dict[str, Any], state: BlockState) -> str:\n        return render_list(self, token, state)"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 20,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.__call__",
      "span": [
        17,
        21
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += \"\\n\\n\".join(self.render_referrences(state)) + \"\\n\"\n        return strip_end(out)",
      "old_code": "    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += '\\n\\n'.join(self.render_referrences(state)) + '\\n'\n        return strip_end(out)"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 24,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.render_referrences",
      "span": [
        23,
        31
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        ref_links = state.env[\"ref_links\"]\n        for key in ref_links:\n            attrs = ref_links[key]\n            text = \"[\" + attrs[\"label\"] + \"]: \" + attrs[\"url\"]\n            title = attrs.get(\"title\")\n            if title:\n                text += ' \"' + title + '\"'\n            yield text",
      "old_code": "    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        ref_links = state.env['ref_links']\n        for key in ref_links:\n            attrs = ref_links[key]\n            text = '[' + attrs['label'] + ']: ' + attrs['url']\n            title = attrs.get('title')\n            if title:\n                text += ' \"' + title + '\"'\n            yield text"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 34,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.render_children",
      "span": [
        33,
        35
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        return self.render_tokens(children, state)",
      "old_code": "    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        return self.render_tokens(children, state)"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.emphasis",
      "span": [
        40,
        41
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"*\" + self.render_children(token, state) + \"*\"",
      "old_code": "    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '*' + self.render_children(token, state) + '*'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 44,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.strong",
      "span": [
        43,
        44
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"**\" + self.render_children(token, state) + \"**\"",
      "old_code": "    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '**' + self.render_children(token, state) + '**'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 49,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.link",
      "span": [
        46,
        68
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = \"[\" + text + \"]\"\n        if label:\n            return out + \"[\" + label + \"]\"\n\n        attrs = token[\"attrs\"]\n        url = attrs[\"url\"]\n        title = attrs.get(\"title\")\n        if text == url and not title:\n            return \"<\" + text + \">\"\n        elif \"mailto:\" + text == url and not title:\n            return \"<\" + text + \">\"\n\n        out += \"(\"\n        if \"(\" in url or \")\" in url:\n            out += \"<\" + url + \">\"\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + \")\"",
      "old_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = '[' + text + ']'\n        if label:\n            return out + '[' + label + ']'\n\n        attrs = token['attrs']\n        url = attrs['url']\n        title = attrs.get('title')\n        if text == url and not title:\n            return '<' + text + '>'\n        elif 'mailto:' + text == url and not title:\n            return '<' + text + '>'\n\n        out += '('\n        if '(' in url or ')' in url:\n            out += '<' + url + '>'\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + ')'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 71,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.image",
      "span": [
        70,
        71
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"!\" + self.link(token, state)",
      "old_code": "    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '!' + self.link(token, state)"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 77,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.linebreak",
      "span": [
        76,
        77
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"  \\n\"",
      "old_code": "    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '  \\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 80,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.softbreak",
      "span": [
        79,
        80
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\\n\"",
      "old_code": "    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 83,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.blank_line",
      "span": [
        82,
        83
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def blank_line(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"",
      "old_code": "    def blank_line(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 90,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.paragraph",
      "span": [
        88,
        90
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = self.render_children(token, state)\n        return text + \"\\n\\n\"",
      "old_code": "    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = self.render_children(token, state)\n        return text + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 96,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.heading",
      "span": [
        92,
        96
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        level = cast(int, token[\"attrs\"][\"level\"])\n        marker = \"#\" * level\n        text = self.render_children(token, state)\n        return marker + \" \" + text + \"\\n\\n\"",
      "old_code": "    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        level = cast(int, token[\"attrs\"][\"level\"])\n        marker = \"#\" * level\n        text = self.render_children(token, state)\n        return marker + ' ' + text + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 99,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.thematic_break",
      "span": [
        98,
        99
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"***\\n\\n\"",
      "old_code": "    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '***\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 102,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.block_text",
      "span": [
        101,
        102
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + \"\\n\"",
      "old_code": "    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + '\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 111,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.block_code",
      "span": [
        104,
        115
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\", \"\"))\n        code = cast(str, token[\"raw\"])\n        if code and code[-1] != \"\\n\":\n            code += \"\\n\"\n\n        marker = token.get(\"marker\")\n        if not marker:\n            marker = _get_fenced_marker(code)\n        marker2 = cast(str, marker)\n        return marker2 + info + \"\\n\" + code + marker2 + \"\\n\\n\"",
      "old_code": "    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\", \"\"))\n        code = cast(str, token[\"raw\"])\n        if code and code[-1] != \"\\n\":\n            code += \"\\n\"\n\n        marker = token.get('marker')\n        if not marker:\n            marker = _get_fenced_marker(code)\n        marker2 = cast(str, marker)\n        return marker2 + info + \"\\n\" + code + marker2 + \"\\n\\n\""
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 118,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.block_quote",
      "span": [
        117,
        120
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), \"> \", lambda _: True)\n        text = text.rstrip(\"> \\n\")\n        return text + \"\\n\\n\"",
      "old_code": "    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), '> ', lambda _: True)\n        text = text.rstrip(\"> \\n\")\n        return text + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 126,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.block_error",
      "span": [
        125,
        126
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"",
      "old_code": "    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 135,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown._get_fenced_marker",
      "span": [
        132,
        150
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _get_fenced_marker(code: str) -> str:\n    found = fenced_re.findall(code)\n    if not found:\n        return \"```\"\n\n    ticks = []  # `\n    waves = []  # ~\n    for s in found:\n        if s[0] == \"`\":\n            ticks.append(len(s))\n        else:\n            waves.append(len(s))\n\n    if not ticks:\n        return \"```\"\n\n    if not waves:\n        return \"~~~\"\n    return \"`\" * (max(ticks) + 1)",
      "old_code": "def _get_fenced_marker(code: str) -> str:\n    found = fenced_re.findall(code)\n    if not found:\n        return '```'\n\n    ticks = []  # `\n    waves = []  # ~\n    for s in found:\n        if s[0] == '`':\n            ticks.append(len(s))\n        else:\n            waves.append(len(s))\n\n    if not ticks:\n        return '```'\n\n    if not waves:\n        return '~~~'\n    return '`' * (max(ticks) + 1)"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 11,
      "kind": "class",
      "qualname": "src.mistune.renderers.rst.RSTRenderer",
      "span": [
        9,
        149
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class RSTRenderer(BaseRenderer):\n    \"\"\"A renderer for converting Markdown to ReST.\"\"\"\n\n    NAME = \"rst\"\n\n    #: marker symbols for heading\n    HEADING_MARKERS = {\n        1: \"=\",\n        2: \"-\",\n        3: \"~\",\n        4: \"^\",\n        5: '\"',\n        6: \"'\",\n    }\n    INLINE_IMAGE_PREFIX = \"img-\"\n\n    def iter_tokens(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> Iterable[str]:\n        prev = None\n        for tok in tokens:\n            # ignore blank line\n            if tok[\"type\"] == \"blank_line\":\n                continue\n            tok[\"prev\"] = prev\n            prev = tok\n            yield self.render_token(tok, state)\n\n    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        state.env[\"inline_images\"] = []\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += \"\\n\\n\".join(self.render_referrences(state)) + \"\\n\"\n        return strip_end(out)\n\n    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        images = state.env[\"inline_images\"]\n        for index, token in enumerate(images):\n            attrs = token[\"attrs\"]\n            alt = self.render_children(token, state)\n            ident = self.INLINE_IMAGE_PREFIX + str(index)\n            yield \".. |\" + ident + \"| image:: \" + attrs[\"url\"] + \"\\n   :alt: \" + alt\n\n    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        return self.render_tokens(children, state)\n\n    def text(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = cast(str, token[\"raw\"])\n        return text.replace(\"|\", r\"\\|\")\n\n    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"*\" + self.render_children(token, state) + \"*\"\n\n    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"**\" + self.render_children(token, state) + \"**\"\n\n    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token[\"attrs\"]\n        text = self.render_children(token, state)\n        return \"`\" + text + \" <\" + cast(str, attrs[\"url\"]) + \">`__\"\n\n    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        refs: List[Dict[str, Any]] = state.env[\"inline_images\"]\n        index = len(refs)\n        refs.append(token)\n        return \"|\" + self.INLINE_IMAGE_PREFIX + str(index) + \"|\"\n\n    def codespan(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"``\" + cast(str, token[\"raw\"]) + \"``\"\n\n    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"<linebreak>\"\n\n    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \" \"\n\n    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        # rst does not support inline html\n        return \"\"\n\n    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        if len(children) == 1 and children[0][\"type\"] == \"image\":\n            image = children[0]\n            attrs = image[\"attrs\"]\n            title = cast(str, attrs.get(\"title\"))\n            alt = self.render_children(image, state)\n            text = \".. figure:: \" + cast(str, attrs[\"url\"])\n            if title:\n                text += \"\\n   :alt: \" + title\n            text += \"\\n\\n\" + indent(alt, \"   \")\n        else:\n            text = self.render_tokens(children, state)\n            lines = text.split(\"<linebreak>\")\n            if len(lines) > 1:\n                text = \"\\n\".join(\"| \" + line for line in lines)\n        return text + \"\\n\\n\"\n\n    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token[\"attrs\"]\n        text = self.render_children(token, state)\n        marker = self.HEADING_MARKERS[attrs[\"level\"]]\n        return text + \"\\n\" + marker * len(text) + \"\\n\\n\"\n\n    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"--------------\\n\\n\"\n\n    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + \"\\n\"\n\n    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\"))\n        code = indent(cast(str, token[\"raw\"]), \"   \")\n        if info:\n            lang = info.split()[0]\n            return \".. code:: \" + lang + \"\\n\\n\" + code + \"\\n\"\n        else:\n            return \"::\\n\\n\" + code + \"\\n\\n\"\n\n    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), \"   \")\n        prev = token[\"prev\"]\n        ignore_blocks = (\n            \"paragraph\",\n            \"thematic_break\",\n            \"linebreak\",\n            \"heading\",\n        )\n        if prev and prev[\"type\"] not in ignore_blocks:\n            text = \"..\\n\\n\" + text\n        return text\n\n    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        raw = token[\"raw\"]\n        return \".. raw:: html\\n\\n\" + indent(raw, \"   \") + \"\\n\\n\"\n\n    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"\n\n    def list(self, token: Dict[str, Any], state: BlockState) -> str:\n        return render_list(self, token, state)",
      "old_code": "class RSTRenderer(BaseRenderer):\n    \"\"\"A renderer for converting Markdown to ReST.\"\"\"\n    NAME = 'rst'\n\n    #: marker symbols for heading\n    HEADING_MARKERS = {\n      1: '=',\n      2: '-',\n      3: '~',\n      4: '^',\n      5: '\"',\n      6: \"'\",\n    }\n    INLINE_IMAGE_PREFIX = 'img-'\n\n    def iter_tokens(\n        self, tokens: Iterable[Dict[str, Any]], state: BlockState\n    ) -> Iterable[str]:\n        prev = None\n        for tok in tokens:\n            # ignore blank line\n            if tok['type'] == 'blank_line':\n                continue\n            tok['prev'] = prev\n            prev = tok\n            yield self.render_token(tok, state)\n\n    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        state.env['inline_images'] = []\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += '\\n\\n'.join(self.render_referrences(state)) + '\\n'\n        return strip_end(out)\n\n    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        images = state.env['inline_images']\n        for index, token in enumerate(images):\n            attrs = token['attrs']\n            alt = self.render_children(token, state)\n            ident = self.INLINE_IMAGE_PREFIX + str(index)\n            yield '.. |' + ident + '| image:: ' + attrs['url'] + '\\n   :alt: ' + alt\n\n    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        return self.render_tokens(children, state)\n\n    def text(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = cast(str, token[\"raw\"])\n        return text.replace(\"|\", r\"\\|\")\n\n    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '*' + self.render_children(token, state) + '*'\n\n    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '**' + self.render_children(token, state) + '**'\n\n    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token['attrs']\n        text = self.render_children(token, state)\n        return \"`\" + text + \" <\" + cast(str, attrs[\"url\"]) + \">`__\"\n\n    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        refs: List[Dict[str, Any]] = state.env[\"inline_images\"]\n        index = len(refs)\n        refs.append(token)\n        return '|' + self.INLINE_IMAGE_PREFIX + str(index) + '|'\n\n    def codespan(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"``\" + cast(str, token[\"raw\"]) + \"``\"\n\n    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '<linebreak>'\n\n    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ' '\n\n    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        # rst does not support inline html\n        return ''\n\n    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        if len(children) == 1 and children[0]['type'] == 'image':\n            image = children[0]\n            attrs = image[\"attrs\"]\n            title = cast(str, attrs.get(\"title\"))\n            alt = self.render_children(image, state)\n            text = \".. figure:: \" + cast(str, attrs[\"url\"])\n            if title:\n                text += '\\n   :alt: ' + title\n            text += '\\n\\n' + indent(alt, '   ')\n        else:\n            text = self.render_tokens(children, state)\n            lines = text.split('<linebreak>')\n            if len(lines) > 1:\n                text = '\\n'.join('| ' + line for line in lines)\n        return text + '\\n\\n'\n\n    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token['attrs']\n        text = self.render_children(token, state)\n        marker = self.HEADING_MARKERS[attrs['level']]\n        return text + '\\n' + marker * len(text) + '\\n\\n'\n\n    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '--------------\\n\\n'\n\n    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + '\\n'\n\n    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\"))\n        code = indent(cast(str, token[\"raw\"]), \"   \")\n        if info:\n            lang = info.split()[0]\n            return '.. code:: ' + lang + '\\n\\n' + code + '\\n'\n        else:\n            return '::\\n\\n' + code + '\\n\\n'\n\n    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), '   ')\n        prev = token['prev']\n        ignore_blocks = (\n            'paragraph',\n            'thematic_break',\n            'linebreak',\n            'heading',\n        )\n        if prev and prev['type'] not in ignore_blocks:\n            text = '..\\n\\n' + text\n        return text\n\n    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        raw = token['raw']\n        return '.. raw:: html\\n\\n' + indent(raw, '   ') + '\\n\\n'\n\n    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''\n\n    def list(self, token: Dict[str, Any], state: BlockState) -> str:\n        return render_list(self, token, state)"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 25,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.iter_tokens",
      "span": [
        25,
        33
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def iter_tokens(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> Iterable[str]:\n        prev = None\n        for tok in tokens:\n            # ignore blank line\n            if tok[\"type\"] == \"blank_line\":\n                continue\n            tok[\"prev\"] = prev\n            prev = tok\n            yield self.render_token(tok, state)",
      "old_code": "    def iter_tokens(\n        self, tokens: Iterable[Dict[str, Any]], state: BlockState\n    ) -> Iterable[str]:\n        prev = None\n        for tok in tokens:\n            # ignore blank line\n            if tok['type'] == 'blank_line':\n                continue\n            tok['prev'] = prev\n            prev = tok\n            yield self.render_token(tok, state)"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 36,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.__call__",
      "span": [
        35,
        40
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        state.env[\"inline_images\"] = []\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += \"\\n\\n\".join(self.render_referrences(state)) + \"\\n\"\n        return strip_end(out)",
      "old_code": "    def __call__(self, tokens: Iterable[Dict[str, Any]], state: BlockState) -> str:\n        state.env['inline_images'] = []\n        out = self.render_tokens(tokens, state)\n        # special handle for line breaks\n        out += '\\n\\n'.join(self.render_referrences(state)) + '\\n'\n        return strip_end(out)"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 43,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.render_referrences",
      "span": [
        42,
        48
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        images = state.env[\"inline_images\"]\n        for index, token in enumerate(images):\n            attrs = token[\"attrs\"]\n            alt = self.render_children(token, state)\n            ident = self.INLINE_IMAGE_PREFIX + str(index)\n            yield \".. |\" + ident + \"| image:: \" + attrs[\"url\"] + \"\\n   :alt: \" + alt",
      "old_code": "    def render_referrences(self, state: BlockState) -> Iterable[str]:\n        images = state.env['inline_images']\n        for index, token in enumerate(images):\n            attrs = token['attrs']\n            alt = self.render_children(token, state)\n            ident = self.INLINE_IMAGE_PREFIX + str(index)\n            yield '.. |' + ident + '| image:: ' + attrs['url'] + '\\n   :alt: ' + alt"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 51,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.render_children",
      "span": [
        50,
        52
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        return self.render_tokens(children, state)",
      "old_code": "    def render_children(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        return self.render_tokens(children, state)"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 59,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.emphasis",
      "span": [
        58,
        59
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"*\" + self.render_children(token, state) + \"*\"",
      "old_code": "    def emphasis(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '*' + self.render_children(token, state) + '*'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 62,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.strong",
      "span": [
        61,
        62
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"**\" + self.render_children(token, state) + \"**\"",
      "old_code": "    def strong(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '**' + self.render_children(token, state) + '**'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 65,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.link",
      "span": [
        64,
        67
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token[\"attrs\"]\n        text = self.render_children(token, state)\n        return \"`\" + text + \" <\" + cast(str, attrs[\"url\"]) + \">`__\"",
      "old_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token['attrs']\n        text = self.render_children(token, state)\n        return \"`\" + text + \" <\" + cast(str, attrs[\"url\"]) + \">`__\""
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 73,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.image",
      "span": [
        69,
        73
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        refs: List[Dict[str, Any]] = state.env[\"inline_images\"]\n        index = len(refs)\n        refs.append(token)\n        return \"|\" + self.INLINE_IMAGE_PREFIX + str(index) + \"|\"",
      "old_code": "    def image(self, token: Dict[str, Any], state: BlockState) -> str:\n        refs: List[Dict[str, Any]] = state.env[\"inline_images\"]\n        index = len(refs)\n        refs.append(token)\n        return '|' + self.INLINE_IMAGE_PREFIX + str(index) + '|'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 79,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.linebreak",
      "span": [
        78,
        79
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"<linebreak>\"",
      "old_code": "    def linebreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '<linebreak>'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 82,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.softbreak",
      "span": [
        81,
        82
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \" \"",
      "old_code": "    def softbreak(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ' '"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 86,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.inline_html",
      "span": [
        84,
        86
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        # rst does not support inline html\n        return \"\"",
      "old_code": "    def inline_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        # rst does not support inline html\n        return ''"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 89,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.paragraph",
      "span": [
        88,
        104
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token[\"children\"]\n        if len(children) == 1 and children[0][\"type\"] == \"image\":\n            image = children[0]\n            attrs = image[\"attrs\"]\n            title = cast(str, attrs.get(\"title\"))\n            alt = self.render_children(image, state)\n            text = \".. figure:: \" + cast(str, attrs[\"url\"])\n            if title:\n                text += \"\\n   :alt: \" + title\n            text += \"\\n\\n\" + indent(alt, \"   \")\n        else:\n            text = self.render_tokens(children, state)\n            lines = text.split(\"<linebreak>\")\n            if len(lines) > 1:\n                text = \"\\n\".join(\"| \" + line for line in lines)\n        return text + \"\\n\\n\"",
      "old_code": "    def paragraph(self, token: Dict[str, Any], state: BlockState) -> str:\n        children = token['children']\n        if len(children) == 1 and children[0]['type'] == 'image':\n            image = children[0]\n            attrs = image[\"attrs\"]\n            title = cast(str, attrs.get(\"title\"))\n            alt = self.render_children(image, state)\n            text = \".. figure:: \" + cast(str, attrs[\"url\"])\n            if title:\n                text += '\\n   :alt: ' + title\n            text += '\\n\\n' + indent(alt, '   ')\n        else:\n            text = self.render_tokens(children, state)\n            lines = text.split('<linebreak>')\n            if len(lines) > 1:\n                text = '\\n'.join('| ' + line for line in lines)\n        return text + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 107,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.heading",
      "span": [
        106,
        110
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token[\"attrs\"]\n        text = self.render_children(token, state)\n        marker = self.HEADING_MARKERS[attrs[\"level\"]]\n        return text + \"\\n\" + marker * len(text) + \"\\n\\n\"",
      "old_code": "    def heading(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token['attrs']\n        text = self.render_children(token, state)\n        marker = self.HEADING_MARKERS[attrs['level']]\n        return text + '\\n' + marker * len(text) + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 113,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.thematic_break",
      "span": [
        112,
        113
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"--------------\\n\\n\"",
      "old_code": "    def thematic_break(self, token: Dict[str, Any], state: BlockState) -> str:\n        return '--------------\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 116,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.block_text",
      "span": [
        115,
        116
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + \"\\n\"",
      "old_code": "    def block_text(self, token: Dict[str, Any], state: BlockState) -> str:\n        return self.render_children(token, state) + '\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 124,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.block_code",
      "span": [
        118,
        126
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\"))\n        code = indent(cast(str, token[\"raw\"]), \"   \")\n        if info:\n            lang = info.split()[0]\n            return \".. code:: \" + lang + \"\\n\\n\" + code + \"\\n\"\n        else:\n            return \"::\\n\\n\" + code + \"\\n\\n\"",
      "old_code": "    def block_code(self, token: Dict[str, Any], state: BlockState) -> str:\n        attrs = token.get(\"attrs\", {})\n        info = cast(str, attrs.get(\"info\"))\n        code = indent(cast(str, token[\"raw\"]), \"   \")\n        if info:\n            lang = info.split()[0]\n            return '.. code:: ' + lang + '\\n\\n' + code + '\\n'\n        else:\n            return '::\\n\\n' + code + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 129,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.block_quote",
      "span": [
        128,
        139
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), \"   \")\n        prev = token[\"prev\"]\n        ignore_blocks = (\n            \"paragraph\",\n            \"thematic_break\",\n            \"linebreak\",\n            \"heading\",\n        )\n        if prev and prev[\"type\"] not in ignore_blocks:\n            text = \"..\\n\\n\" + text\n        return text",
      "old_code": "    def block_quote(self, token: Dict[str, Any], state: BlockState) -> str:\n        text = indent(self.render_children(token, state), '   ')\n        prev = token['prev']\n        ignore_blocks = (\n            'paragraph',\n            'thematic_break',\n            'linebreak',\n            'heading',\n        )\n        if prev and prev['type'] not in ignore_blocks:\n            text = '..\\n\\n' + text\n        return text"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 142,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.block_html",
      "span": [
        141,
        143
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        raw = token[\"raw\"]\n        return \".. raw:: html\\n\\n\" + indent(raw, \"   \") + \"\\n\\n\"",
      "old_code": "    def block_html(self, token: Dict[str, Any], state: BlockState) -> str:\n        raw = token['raw']\n        return '.. raw:: html\\n\\n' + indent(raw, '   ') + '\\n\\n'"
    },
    {
      "path": "src/mistune/renderers/rst.py",
      "version": "new",
      "line": 146,
      "kind": "function",
      "qualname": "src.mistune.renderers.rst.RSTRenderer.block_error",
      "span": [
        145,
        146
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return \"\"",
      "old_code": "    def block_error(self, token: Dict[str, Any], state: BlockState) -> str:\n        return ''"
    },
    {
      "path": "src/mistune/toc.py",
      "version": "new",
      "line": 37,
      "kind": "function",
      "qualname": "src.mistune.toc.add_toc_hook.heading_id",
      "span": [
        36,
        37
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "        def heading_id(token: Dict[str, Any], index: int) -> str:\n            return \"toc_\" + str(index + 1)",
      "old_code": "        def heading_id(token: Dict[str, Any], index: int) -> str:\n            return 'toc_' + str(index + 1)"
    },
    {
      "path": "src/mistune/toc.py",
      "version": "new",
      "line": 43,
      "kind": "function",
      "qualname": "src.mistune.toc.add_toc_hook.toc_hook",
      "span": [
        39,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def toc_hook(md: \"Markdown\", state: \"BlockState\") -> None:\n        headings = []\n\n        for tok in state.tokens:\n            if tok[\"type\"] == \"heading\":\n                level = tok[\"attrs\"][\"level\"]\n                if min_level <= level <= max_level:\n                    headings.append(tok)\n\n        toc_items = []\n        for i, tok in enumerate(headings):\n            tok[\"attrs\"][\"id\"] = heading_id(tok, i)\n            toc_items.append(normalize_toc_item(md, tok))\n\n        # save items into state\n        state.env[\"toc_items\"] = toc_items",
      "old_code": "    def toc_hook(md: \"Markdown\", state: \"BlockState\") -> None:\n        headings = []\n\n        for tok in state.tokens:\n            if tok['type'] == 'heading':\n                level = tok['attrs']['level']\n                if min_level <= level <= max_level:\n                    headings.append(tok)\n\n        toc_items = []\n        for i, tok in enumerate(headings):\n            tok['attrs']['id'] = heading_id(tok, i)\n            toc_items.append(normalize_toc_item(md, tok))\n\n        # save items into state\n        state.env['toc_items'] = toc_items"
    },
    {
      "path": "src/mistune/toc.py",
      "version": "new",
      "line": 65,
      "kind": "function",
      "qualname": "src.mistune.toc.normalize_toc_item",
      "span": [
        59,
        66
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def normalize_toc_item(md: \"Markdown\", token: Dict[str, Any]) -> Tuple[int, str, str]:\n    text = token[\"text\"]\n    tokens = md.inline(text, {})\n    assert md.renderer is not None\n    html = md.renderer(tokens, BlockState())\n    text = striptags(html)\n    attrs = token[\"attrs\"]\n    return attrs[\"level\"], attrs[\"id\"], text",
      "old_code": "def normalize_toc_item(md: \"Markdown\", token: Dict[str, Any]) -> Tuple[int, str, str]:\n    text = token[\"text\"]\n    tokens = md.inline(text, {})\n    assert md.renderer is not None\n    html = md.renderer(tokens, BlockState())\n    text = striptags(html)\n    attrs = token['attrs']\n    return attrs['level'], attrs['id'], text"
    },
    {
      "path": "src/mistune/toc.py",
      "version": "new",
      "line": 87,
      "kind": "function",
      "qualname": "src.mistune.toc.render_toc_ul",
      "span": [
        69,
        126
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def render_toc_ul(toc: Iterable[Tuple[int, str, str]]) -> str:\n    \"\"\"Render a <ul> table of content HTML. The param \"toc\" should\n    be formatted into this structure::\n\n        [\n          (level, id, text),\n        ]\n\n    For example::\n\n        [\n          (1, 'toc-intro', 'Introduction'),\n          (2, 'toc-install', 'Install'),\n          (2, 'toc-upgrade', 'Upgrade'),\n          (1, 'toc-license', 'License'),\n        ]\n    \"\"\"\n    if not toc:\n        return \"\"\n\n    s = \"\"\n    levels: List[int] = []\n    for level, k, text in toc:\n        item = '<a href=\"#{}\">{}</a>'.format(k, text)\n        if not levels:\n            s += \"<li>\" + item\n            levels.append(level)\n        elif level == levels[-1]:\n            s += \"</li>\\n<li>\" + item\n        elif level > levels[-1]:\n            s += \"\\n<ul>\\n<li>\" + item\n            levels.append(level)\n        else:\n            levels.pop()\n            while levels:\n                last_level = levels.pop()\n                if level == last_level:\n                    s += \"</li>\\n</ul>\\n</li>\\n<li>\" + item\n                    levels.append(level)\n                    break\n                elif level > last_level:\n                    s += \"</li>\\n<li>\" + item\n                    levels.append(last_level)\n                    levels.append(level)\n                    break\n                else:\n                    s += \"</li>\\n</ul>\\n\"\n            else:\n                levels.append(level)\n                s += \"</li>\\n<li>\" + item\n\n    while len(levels) > 1:\n        s += \"</li>\\n</ul>\\n\"\n        levels.pop()\n\n    if not s:\n        return \"\"\n    return \"<ul>\\n\" + s + \"</li>\\n</ul>\\n\"",
      "old_code": "def render_toc_ul(toc: Iterable[Tuple[int, str, str]]) -> str:\n    \"\"\"Render a <ul> table of content HTML. The param \"toc\" should\n    be formatted into this structure::\n\n        [\n          (level, id, text),\n        ]\n\n    For example::\n\n        [\n          (1, 'toc-intro', 'Introduction'),\n          (2, 'toc-install', 'Install'),\n          (2, 'toc-upgrade', 'Upgrade'),\n          (1, 'toc-license', 'License'),\n        ]\n    \"\"\"\n    if not toc:\n        return ''\n\n    s = ''\n    levels: List[int] = []\n    for level, k, text in toc:\n        item = '<a href=\"#{}\">{}</a>'.format(k, text)\n        if not levels:\n            s += '<li>' + item\n            levels.append(level)\n        elif level == levels[-1]:\n            s += '</li>\\n<li>' + item\n        elif level > levels[-1]:\n            s += '\\n<ul>\\n<li>' + item\n            levels.append(level)\n        else:\n            levels.pop()\n            while levels:\n                last_level = levels.pop()\n                if level == last_level:\n                    s += '</li>\\n</ul>\\n</li>\\n<li>' + item\n                    levels.append(level)\n                    break\n                elif level > last_level:\n                    s += '</li>\\n<li>' + item\n                    levels.append(last_level)\n                    levels.append(level)\n                    break\n                else:\n                    s += '</li>\\n</ul>\\n'\n            else:\n                levels.append(level)\n                s += '</li>\\n<li>' + item\n\n    while len(levels) > 1:\n        s += '</li>\\n</ul>\\n'\n        levels.pop()\n\n    if not s:\n        return ''\n    return '<ul>\\n' + s + '</li>\\n</ul>\\n'"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 6,
      "kind": "module",
      "qualname": "src.mistune.util",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 12,
      "kind": "function",
      "qualname": "src.mistune.util.expand_leading_tab.repl",
      "span": [
        10,
        12
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def repl(m: Match[str]) -> str:\n        s = m.group(1)\n        return s + \" \" * (width - len(s))",
      "old_code": "    def repl(m: Match[str]) -> str:\n        s = m.group(1)\n        return s + ' ' * (width - len(s))"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 13,
      "kind": "function",
      "qualname": "src.mistune.util.expand_leading_tab",
      "span": [
        9,
        14
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def expand_leading_tab(text: str, width: int = 4) -> str:\n    def repl(m: Match[str]) -> str:\n        s = m.group(1)\n        return s + \" \" * (width - len(s))\n\n    return _expand_tab_re.sub(repl, text)",
      "old_code": "def expand_leading_tab(text: str, width: int = 4) -> str:\n    def repl(m: Match[str]) -> str:\n        s = m.group(1)\n        return s + ' ' * (width - len(s))\n    return _expand_tab_re.sub(repl, text)"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 36,
      "kind": "function",
      "qualname": "src.mistune.util.escape_url",
      "span": [
        33,
        40
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def escape_url(link: str) -> str:\n    \"\"\"Escape URL for safety.\"\"\"\n    safe = (\n        \":/?#@\"  # gen-delims - '[]' (rfc3986)\n        \"!$&()*+,;=\"  # sub-delims - \"'\" (rfc3986)\n        \"%\"  # leave already-encoded octets alone\n    )\n    return quote(unescape(link), safe=safe)",
      "old_code": "def escape_url(link: str) -> str:\n    \"\"\"Escape URL for safety.\"\"\"\n    safe = (\n        ':/?#@'           # gen-delims - '[]' (rfc3986)\n        '!$&()*+,;='      # sub-delims - \"'\" (rfc3986)\n        '%'               # leave already-encoded octets alone\n    )\n    return quote(unescape(link), safe=safe)"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 50,
      "kind": "function",
      "qualname": "src.mistune.util.unikey",
      "span": [
        48,
        51
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def unikey(s: str) -> str:\n    \"\"\"Generate a unique key for links and footnotes.\"\"\"\n    key = \" \".join(s.split()).strip()\n    return key.lower().upper()",
      "old_code": "def unikey(s: str) -> str:\n    \"\"\"Generate a unique key for links and footnotes.\"\"\"\n    key = ' '.join(s.split()).strip()\n    return key.lower().upper()"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 66,
      "kind": "function",
      "qualname": "src.mistune.util.unescape",
      "span": [
        61,
        68
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def unescape(s: str) -> str:\n    \"\"\"\n    Copy from `html.unescape`, but `_charref` is different. CommonMark\n    does not accept entity references without a trailing semicolon\n    \"\"\"\n    if \"&\" not in s:\n        return s\n    return _charref_re.sub(_replace_charref, s)",
      "old_code": "def unescape(s: str) -> str:\n    \"\"\"\n    Copy from `html.unescape`, but `_charref` is different. CommonMark\n    does not accept entity references without a trailing semicolon\n    \"\"\"\n    if '&' not in s:\n        return s\n    return _charref_re.sub(_replace_charref, s)"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 75,
      "kind": "function",
      "qualname": "src.mistune.util.striptags",
      "span": [
        74,
        75
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def striptags(s: str) -> str:\n    return _striptags_re.sub(\"\", s)",
      "old_code": "def striptags(s: str) -> str:\n    return _striptags_re.sub('', s)"
    },
    {
      "path": "src/mistune/util.py",
      "version": "new",
      "line": 82,
      "kind": "function",
      "qualname": "src.mistune.util.strip_end",
      "span": [
        81,
        82
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def strip_end(src: str) -> str:\n    return _strip_end_re.sub(\"\\n\", src)",
      "old_code": "def strip_end(src: str) -> str:\n    return _strip_end_re.sub('\\n', src)"
    },
    {
      "path": "tests/__init__.py",
      "version": "new",
      "line": 12,
      "kind": "function",
      "qualname": "tests.__init__.BaseTestCase.load_fixtures.attach_case.method",
      "span": [
        12,
        13
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "            def method(self: \"BaseTestCase\") -> None:\n                self.assert_case(n, text, html)",
      "old_code": "            def method(self: 'BaseTestCase') -> None:\n                self.assert_case(n, text, html)"
    },
    {
      "path": "tests/__init__.py",
      "version": "new",
      "line": 15,
      "kind": "function",
      "qualname": "tests.__init__.BaseTestCase.load_fixtures.attach_case",
      "span": [
        11,
        18
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "        def attach_case(n: str, text: str, html: str) -> None:\n            def method(self: \"BaseTestCase\") -> None:\n                self.assert_case(n, text, html)\n\n            name = \"test_{}\".format(n)\n            method.__name__ = name\n            method.__doc__ = \"Run fixture {} - {}\".format(case_file, n)\n            setattr(cls, name, method)",
      "old_code": "        def attach_case(n: str, text: str, html: str) -> None:\n            def method(self: 'BaseTestCase') -> None:\n                self.assert_case(n, text, html)\n\n            name = 'test_{}'.format(n)\n            method.__name__ = name\n            method.__doc__ = 'Run fixture {} - {}'.format(case_file, n)\n            setattr(cls, name, method)"
    },
    {
      "path": "tests/__init__.py",
      "version": "new",
      "line": 28,
      "kind": "class",
      "qualname": "tests.__init__.BaseTestCase",
      "span": [
        8,
        34
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "class BaseTestCase(TestCase):\n    @classmethod\n    def load_fixtures(cls, case_file: str) -> None:\n        def attach_case(n: str, text: str, html: str) -> None:\n            def method(self: \"BaseTestCase\") -> None:\n                self.assert_case(n, text, html)\n\n            name = \"test_{}\".format(n)\n            method.__name__ = name\n            method.__doc__ = \"Run fixture {} - {}\".format(case_file, n)\n            setattr(cls, name, method)\n\n        for n, text, html in fixtures.load_examples(case_file):\n            if cls.ignore_case(n):\n                continue\n            attach_case(n, text, html)\n\n    @classmethod\n    def ignore_case(cls, name: str) -> bool:\n        return False\n\n    @abstractmethod\n    def parse(self, text: str) -> str: ...\n\n    def assert_case(self, name: str, text: str, html: str) -> None:\n        result = self.parse(text)\n        self.assertEqual(result, html)",
      "old_code": "class BaseTestCase(TestCase):\n    @classmethod\n    def load_fixtures(cls, case_file: str) -> None:\n        def attach_case(n: str, text: str, html: str) -> None:\n            def method(self: 'BaseTestCase') -> None:\n                self.assert_case(n, text, html)\n\n            name = 'test_{}'.format(n)\n            method.__name__ = name\n            method.__doc__ = 'Run fixture {} - {}'.format(case_file, n)\n            setattr(cls, name, method)\n\n        for n, text, html in fixtures.load_examples(case_file):\n            if cls.ignore_case(n):\n                continue\n            attach_case(n, text, html)\n\n    @classmethod\n    def ignore_case(cls, name: str) -> bool:\n        return False\n    \n    @abstractmethod\n    def parse(self, text: str) -> str: ...\n\n    def assert_case(self, name: str, text: str, html: str) -> None:\n        result = self.parse(text)\n        self.assertEqual(result, html)"
    },
    {
      "path": "tests/__init__.py",
      "version": "new",
      "line": 38,
      "kind": "function",
      "qualname": "tests.__init__.normalize_html",
      "span": [
        37,
        40
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def normalize_html(html: str) -> str:\n    html = re.sub(r\">\\n+\", \">\", html)\n    html = re.sub(r\"\\n+<\", \"<\", html)\n    return html.strip()",
      "old_code": "def normalize_html(html: str) -> str:\n    html = re.sub(r'>\\n+', '>', html)\n    html = re.sub(r'\\n+<', '<', html)\n    return html.strip()"
    },
    {
      "path": "tests/fixtures/__init__.py",
      "version": "new",
      "line": 9,
      "kind": "module",
      "qualname": "tests.fixtures.__init__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/fixtures/__init__.py",
      "version": "new",
      "line": 17,
      "kind": "function",
      "qualname": "tests.fixtures.__init__.load_ast",
      "span": [
        16,
        18
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def load_ast(filename: str) -> Any:\n    with open(os.path.join(ROOT, \"ast\", filename)) as f:\n        return json.load(f)",
      "old_code": "def load_ast(filename: str) -> Any:\n    with open(os.path.join(ROOT, 'ast', filename)) as f:\n        return json.load(f)"
    },
    {
      "path": "tests/fixtures/__init__.py",
      "version": "new",
      "line": 27,
      "kind": "function",
      "qualname": "tests.fixtures.__init__.load_examples",
      "span": [
        26,
        37
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def load_examples(filename: str) -> Iterable[Tuple[str, str, str]]:\n    if filename.endswith(\".json\"):\n        data = load_json(filename)\n        for item in data:\n            section = item[\"section\"].lower().replace(\" \", \"_\")\n            n = \"%s_%03d\" % (section, item[\"example\"])\n            yield n, item[\"markdown\"], item[\"html\"]\n    else:\n        with open(os.path.join(ROOT, filename), \"rb\") as f:\n            content = f.read()\n            s = content.decode(\"utf-8\")\n            yield from parse_examples(s)",
      "old_code": "def load_examples(filename: str) -> Iterable[Tuple[str, str, str]]:\n    if filename.endswith('.json'):\n        data = load_json(filename)\n        for item in data:\n            section = item['section'].lower().replace(' ', '_')\n            n = '%s_%03d' % (section, item['example'])\n            yield n, item['markdown'], item['html']\n    else:\n        with open(os.path.join(ROOT, filename), 'rb') as f:\n            content = f.read()\n            s = content.decode('utf-8')\n            yield from parse_examples(s)"
    },
    {
      "path": "tests/fixtures/__init__.py",
      "version": "new",
      "line": 48,
      "kind": "function",
      "qualname": "tests.fixtures.__init__.parse_examples",
      "span": [
        40,
        55
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def parse_examples(text: str) -> Iterable[Tuple[str, str, str]]:\n    data = EXAMPLE_PATTERN.findall(text)\n\n    section = None\n    count = 0\n    for md, html, title in data:\n        if title:\n            count = 0\n            section = title.lower().replace(\" \", \"_\")\n\n        if md and html:\n            count += 1\n            n = \"%s_%03d\" % (section, count)\n            md = md.replace(\"\\u2192\", \"\\t\")\n            html = html.replace(\"\\u2192\", \"\\t\")\n            yield n, md, html",
      "old_code": "def parse_examples(text: str) -> Iterable[Tuple[str, str, str]]:\n    data = EXAMPLE_PATTERN.findall(text)\n\n    section = None\n    count = 0\n    for md, html, title in data:\n        if title:\n            count = 0\n            section = title.lower().replace(' ', '_')\n\n        if md and html:\n            count += 1\n            n = '%s_%03d' % (section, count)\n            md = md.replace(u'\\u2192', '\\t')\n            html = html.replace(u'\\u2192', '\\t')\n            yield n, md, html"
    },
    {
      "path": "tests/test_commonmark.py",
      "version": "new",
      "line": 6,
      "kind": "module",
      "qualname": "tests.test_commonmark",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 27,
      "kind": "function",
      "qualname": "tests.test_directives.load_directive_test",
      "span": [
        16,
        28
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def load_directive_test(filename, directive, cls):\n    class TestDirective(BaseTestCase):\n        @staticmethod\n        def parse(text):\n            md = create_markdown(\n                escape=False,\n                plugins=[cls([directive])],\n            )\n            html = md(text)\n            return html\n\n    TestDirective.load_fixtures(filename + \".txt\")\n    globals()[\"TestDirective_\" + filename] = TestDirective",
      "old_code": "def load_directive_test(filename, directive, cls):\n    class TestDirective(BaseTestCase):\n        @staticmethod\n        def parse(text):\n            md = create_markdown(\n                escape=False,\n                plugins=[cls([directive])],\n            )\n            html = md(text)\n            return html\n\n    TestDirective.load_fixtures(filename + '.txt')\n    globals()[\"TestDirective_\" + filename] = TestDirective"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 31,
      "kind": "module",
      "qualname": "tests.test_directives",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "tests.test_directives.CustomizeTableOfContents.generate_heading_id",
      "span": [
        40,
        41
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def generate_heading_id(self, token, i):\n        return \"t-\" + str(i + 1)",
      "old_code": "    def generate_heading_id(self, token, i):\n        return 't-' + str(i + 1)"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 52,
      "kind": "function",
      "qualname": "tests.test_directives.TestCustomizeToc.test_rst_toc",
      "span": [
        45,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_rst_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                RSTDirective([CustomizeTableOfContents()]),\n            ],\n        )\n        html = md(\"# h1\\n\\n.. toc::\\n\")\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)",
      "old_code": "    def test_rst_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                RSTDirective([CustomizeTableOfContents()]),\n            ],\n        )\n        html = md('# h1\\n\\n.. toc::\\n')\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 63,
      "kind": "function",
      "qualname": "tests.test_directives.TestCustomizeToc.test_fenced_toc",
      "span": [
        56,
        65
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_fenced_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                FencedDirective([CustomizeTableOfContents()]),\n            ],\n        )\n        html = md(\"# h1\\n\\n```{toc}\\n```\\n\")\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)",
      "old_code": "    def test_fenced_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                FencedDirective([CustomizeTableOfContents()]),\n            ],\n        )\n        html = md('# h1\\n\\n```{toc}\\n```\\n')\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 71,
      "kind": "function",
      "qualname": "tests.test_directives.TestCustomizeToc.test_colon_fenced_toc",
      "span": [
        67,
        76
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_colon_fenced_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                FencedDirective([CustomizeTableOfContents()], \":\"),\n            ],\n        )\n        html = md(\"# h1\\n\\n:::{toc}\\n:::\\n\")\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)",
      "old_code": "    def test_colon_fenced_toc(self):\n        md = create_markdown(\n            escape=False,\n            plugins=[\n                FencedDirective([CustomizeTableOfContents()], ':'),\n            ],\n        )\n        html = md('# h1\\n\\n:::{toc}\\n:::\\n')\n        self.assertIn('<h1 id=\"t-1\">h1</h1>', html)\n        self.assertIn('<a href=\"#t-1\">h1</a>', html)"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 83,
      "kind": "function",
      "qualname": "tests.test_directives.TestDirectiveInclude.test_html_include",
      "span": [
        82,
        88
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_html_include(self):\n        html = self.md.read(os.path.join(ROOT, \"include/text.md\"))[0]\n        self.assertIn(\"Could not include self\", html)\n        self.assertIn(\"Could not find file\", html)\n        self.assertIn(\"<div>include html</div>\", html)\n        self.assertIn(\"<blockquote>\", html)\n        self.assertIn(\"# Table of Contents\", html)",
      "old_code": "    def test_html_include(self):\n        html = self.md.read(os.path.join(ROOT, 'include/text.md'))[0]\n        self.assertIn('Could not include self', html)\n        self.assertIn('Could not find file', html)\n        self.assertIn('<div>include html</div>', html)\n        self.assertIn('<blockquote>', html)\n        self.assertIn('# Table of Contents', html)"
    },
    {
      "path": "tests/test_directives.py",
      "version": "new",
      "line": 91,
      "kind": "function",
      "qualname": "tests.test_directives.TestDirectiveInclude.test_include_missing_source",
      "span": [
        90,
        93
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_include_missing_source(self):\n        s = \".. include:: foo.txt\"\n        html = self.md(s)\n        self.assertIn(\"Missing source file\", html)",
      "old_code": "    def test_include_missing_source(self):\n        s = '.. include:: foo.txt'\n        html = self.md(s)\n        self.assertIn('Missing source file', html)"
    },
    {
      "path": "tests/test_hooks.py",
      "version": "new",
      "line": 13,
      "kind": "function",
      "qualname": "tests.test_hooks.TestTocHook.parse",
      "span": [
        9,
        14
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def parse(text):\n        md = create_markdown(escape=False)\n        add_toc_hook(md)\n        html, state = md.parse(text)\n        result = html + render_toc_ul(state.env[\"toc_items\"])\n        return result",
      "old_code": "    def parse(text):\n        md = create_markdown(escape=False)\n        add_toc_hook(md)\n        html, state = md.parse(text)\n        result = html + render_toc_ul(state.env['toc_items'])\n        return result"
    },
    {
      "path": "tests/test_hooks.py",
      "version": "new",
      "line": 18,
      "kind": "function",
      "qualname": "tests.test_hooks.TestTocHook.test_customize_heading_id_func.heading_id",
      "span": [
        17,
        18
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "        def heading_id(token, i):\n            return \"t-\" + str(i + 1)",
      "old_code": "        def heading_id(token, i):\n            return 't-' + str(i + 1)"
    },
    {
      "path": "tests/test_hooks.py",
      "version": "new",
      "line": 22,
      "kind": "function",
      "qualname": "tests.test_hooks.TestTocHook.test_customize_heading_id_func",
      "span": [
        16,
        23
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_customize_heading_id_func(self):\n        def heading_id(token, i):\n            return \"t-\" + str(i + 1)\n\n        md = create_markdown(escape=False)\n        add_toc_hook(md, heading_id=heading_id)\n        html = md(\"# h1\")\n        self.assertEqual(html, '<h1 id=\"t-1\">h1</h1>\\n')",
      "old_code": "    def test_customize_heading_id_func(self):\n        def heading_id(token, i):\n            return 't-' + str(i + 1)\n\n        md = create_markdown(escape=False)\n        add_toc_hook(md, heading_id=heading_id)\n        html = md('# h1')\n        self.assertEqual(html, '<h1 id=\"t-1\">h1</h1>\\n')"
    },
    {
      "path": "tests/test_hooks.py",
      "version": "new",
      "line": 26,
      "kind": "function",
      "qualname": "tests.test_hooks.TestTocHook.test_render_empty_toc",
      "span": [
        25,
        27
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_render_empty_toc(self):\n        self.assertEqual(render_toc_ul([]), \"\")\n        self.assertEqual(render_toc_ul(filter(lambda _: False, [])), \"\")",
      "old_code": "    def test_render_empty_toc(self):\n        self.assertEqual(render_toc_ul([]), '')\n        self.assertEqual(render_toc_ul(filter(lambda _: False, [])), '')"
    },
    {
      "path": "tests/test_hooks.py",
      "version": "new",
      "line": 29,
      "kind": "module",
      "qualname": "tests.test_hooks",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 7,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_none",
      "span": [
        6,
        7
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_none(self):\n        self.assertEqual(mistune.html(None), \"\")",
      "old_code": "    def test_none(self):\n        self.assertEqual(mistune.html(None), '')"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 11,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_before_parse_hooks._add_name",
      "span": [
        10,
        11
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "        def _add_name(md, state):\n            state.env[\"name\"] = \"test\"",
      "old_code": "        def _add_name(md, state):\n            state.env['name'] = 'test'"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 16,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_before_parse_hooks",
      "span": [
        9,
        17
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_before_parse_hooks(self):\n        def _add_name(md, state):\n            state.env[\"name\"] = \"test\"\n\n        md = mistune.create_markdown()\n        md.before_parse_hooks.append(_add_name)\n        state = md.block.state_cls()\n        md.parse(\"\", state)\n        self.assertEqual(state.env[\"name\"], \"test\")",
      "old_code": "    def test_before_parse_hooks(self):\n        def _add_name(md, state):\n            state.env['name'] = 'test'\n\n        md = mistune.create_markdown()\n        md.before_parse_hooks.append(_add_name)\n        state = md.block.state_cls()\n        md.parse('', state)\n        self.assertEqual(state.env['name'], 'test')"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 21,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_hard_wrap",
      "span": [
        19,
        27
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_hard_wrap(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md(\"foo\\nbar\")\n        expected = \"<p>foo<br />\\nbar</p>\"\n        self.assertEqual(result.strip(), expected)\n\n        md = mistune.create_markdown(escape=False, hard_wrap=True, plugins=[\"speedup\"])\n        result = md(\"foo\\nbar\")\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_hard_wrap(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md('foo\\nbar')\n        expected = '<p>foo<br />\\nbar</p>'\n        self.assertEqual(result.strip(), expected)\n\n        md = mistune.create_markdown(\n            escape=False, hard_wrap=True, plugins=['speedup'])\n        result = md('foo\\nbar')\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 31,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_escape_html",
      "span": [
        29,
        37
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_escape_html(self):\n        md = mistune.create_markdown(escape=True)\n        result = md(\"<div>1</div>\")\n        expected = \"<p>&lt;div&gt;1&lt;/div&gt;</p>\"\n        self.assertEqual(result.strip(), expected)\n\n        result = md(\"<em>1</em>\")\n        expected = \"<p>&lt;em&gt;1&lt;/em&gt;</p>\"\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_escape_html(self):\n        md = mistune.create_markdown(escape=True)\n        result = md('<div>1</div>')\n        expected = '<p>&lt;div&gt;1&lt;/div&gt;</p>'\n        self.assertEqual(result.strip(), expected)\n\n        result = md('<em>1</em>')\n        expected = '<p>&lt;em&gt;1&lt;/em&gt;</p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 40,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_harmful_links",
      "span": [
        39,
        42
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_harmful_links(self):\n        result = mistune.html(\"[h](javAscript:alert)\")\n        expected = '<p><a href=\"#harmful-link\">h</a></p>'\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_harmful_links(self):\n        result = mistune.html('[h](javAscript:alert)')\n        expected = '<p><a href=\"#harmful-link\">h</a></p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 45,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_ref_link",
      "span": [
        44,
        47
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ref_link(self):\n        result = mistune.html(\"[link][h]\\n\\n[h]: /foo\")\n        expected = '<p><a href=\"/foo\">link</a></p>'\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_ref_link(self):\n        result = mistune.html('[link][h]\\n\\n[h]: /foo')\n        expected = '<p><a href=\"/foo\">link</a></p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 52,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_allow_harmful_protocols",
      "span": [
        49,
        54
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_allow_harmful_protocols(self):\n        renderer = mistune.HTMLRenderer(allow_harmful_protocols=True)\n        md = mistune.Markdown(renderer)\n        result = md(\"[h](javascript:alert)\")\n        expected = '<p><a href=\"javascript:alert\">h</a></p>'\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_allow_harmful_protocols(self):\n        renderer = mistune.HTMLRenderer(allow_harmful_protocols=True)\n        md = mistune.Markdown(renderer)\n        result = md('[h](javascript:alert)')\n        expected = '<p><a href=\"javascript:alert\">h</a></p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 57,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_allow_data_protocols",
      "span": [
        56,
        61
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_allow_data_protocols(self):\n        renderer = mistune.HTMLRenderer(allow_harmful_protocols=[\"data:\"])\n        md = mistune.Markdown(renderer)\n        result = md(\"[h](data:alert)\")\n        expected = '<p><a href=\"data:alert\">h</a></p>'\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_allow_data_protocols(self):\n        renderer = mistune.HTMLRenderer(allow_harmful_protocols=['data:'])\n        md = mistune.Markdown(renderer)\n        result = md('[h](data:alert)')\n        expected = '<p><a href=\"data:alert\">h</a></p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 65,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_use_plugin",
      "span": [
        63,
        67
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_use_plugin(self):\n        from mistune.plugins.url import url\n\n        md = mistune.Markdown(mistune.HTMLRenderer())\n        md.use(url)",
      "old_code": "    def test_use_plugin(self):\n        from mistune.plugins.url import url\n        md = mistune.Markdown(mistune.HTMLRenderer())\n        md.use(url)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 70,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_markdown_func",
      "span": [
        69,
        76
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_markdown_func(self):\n        result = mistune.markdown(\"**b**\")\n        expected = \"<p><strong>b</strong></p>\\n\"\n        self.assertEqual(result, expected)\n\n        # trigger to use cached parser\n        result = mistune.markdown(\"**b**\")\n        self.assertEqual(result, expected)",
      "old_code": "    def test_markdown_func(self):\n        result = mistune.markdown('**b**')\n        expected = '<p><strong>b</strong></p>\\n'\n        self.assertEqual(result, expected)\n\n        # trigger to use cached parser\n        result = mistune.markdown('**b**')\n        self.assertEqual(result, expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 84,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_ast_output",
      "span": [
        78,
        105
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ast_output(self):\n        md = mistune.create_markdown(escape=False, renderer=None)\n        text = '# h1\\n\\nfoo **bar**\\n\\n`&<>\"`'\n        result = md(text)\n        expected = [\n            {\n                \"type\": \"heading\",\n                \"children\": [{\"type\": \"text\", \"raw\": \"h1\"}],\n                \"attrs\": {\"level\": 1},\n                \"style\": \"atx\",\n            },\n            {\"type\": \"blank_line\"},\n            {\n                \"type\": \"paragraph\",\n                \"children\": [\n                    {\"type\": \"text\", \"raw\": \"foo \"},\n                    {\"type\": \"strong\", \"children\": [{\"type\": \"text\", \"raw\": \"bar\"}]},\n                ],\n            },\n            {\"type\": \"blank_line\"},\n            {\n                \"type\": \"paragraph\",\n                \"children\": [\n                    {\"type\": \"codespan\", \"raw\": '&<>\"'},\n                ],\n            },\n        ]\n        self.assertEqual(result, expected)",
      "old_code": "    def test_ast_output(self):\n        md = mistune.create_markdown(escape=False, renderer=None)\n        text = '# h1\\n\\nfoo **bar**\\n\\n`&<>\"`'\n        result = md(text)\n        expected = [\n            {\n                'type': 'heading',\n                'children': [{'type': 'text', 'raw': 'h1'}],\n                'attrs': {'level': 1},\n                'style': 'atx',\n            },\n            {'type': 'blank_line'},\n            {\n                'type': 'paragraph',\n                'children': [\n                    {'type': 'text', 'raw': 'foo '},\n                    {'type': 'strong', 'children': [{'type': 'text', 'raw': 'bar'}]}\n                ]\n            },\n            {'type': 'blank_line'},\n            {\n                'type': 'paragraph',\n                'children': [\n                    {'type': 'codespan', 'raw': '&<>\"'},\n                ]\n            },\n        ]\n        self.assertEqual(result, expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 110,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_ast_url",
      "span": [
        107,
        125
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ast_url(self):\n        md = mistune.create_markdown(escape=False, renderer=None)\n        label = 'hi &<>\"'\n        url = \"https://example.com/foo?a=1&b=2\"\n        text = \"[{}]({})\".format(label, url)\n        result = md(text)\n        expected = [\n            {\n                \"type\": \"paragraph\",\n                \"children\": [\n                    {\n                        \"type\": \"link\",\n                        \"children\": [{\"type\": \"text\", \"raw\": label}],\n                        \"attrs\": {\"url\": url},\n                    },\n                ],\n            },\n        ]\n        self.assertEqual(result, expected)",
      "old_code": "    def test_ast_url(self):\n        md = mistune.create_markdown(escape=False, renderer=None)\n        label = 'hi &<>\"'\n        url = 'https://example.com/foo?a=1&b=2'\n        text = '[{}]({})'.format(label, url)\n        result = md(text)\n        expected = [\n            {\n                'type': 'paragraph',\n                'children': [\n                    {\n                        'type': 'link',\n                        'children': [{'type': 'text', 'raw': label}],\n                        'attrs': {'url': url},\n                    },\n                ],\n            },\n        ]\n        self.assertEqual(result, expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 129,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_emsp",
      "span": [
        127,
        131
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_emsp(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md(\"\\u2003\\u2003foo\\nbar\\n\\n\\u2003\\u2003foobar\")\n        expected = \"<p>\\u2003\\u2003foo<br />\\nbar</p>\\n<p>\\u2003\\u2003foobar</p>\"\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_emsp(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md('\\u2003\\u2003foo\\nbar\\n\\n\\u2003\\u2003foobar')\n        expected = '<p>\\u2003\\u2003foo<br />\\nbar</p>\\n<p>\\u2003\\u2003foobar</p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_misc.py",
      "version": "new",
      "line": 135,
      "kind": "function",
      "qualname": "tests.test_misc.TestMiscCases.test_html_tag_text_following_list",
      "span": [
        133,
        137
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_html_tag_text_following_list(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md(\"foo\\n- bar\\n\\ntable\")\n        expected = \"<p>foo</p>\\n<ul>\\n<li>bar</li>\\n</ul>\\n<p>table</p>\"\n        self.assertEqual(result.strip(), expected)",
      "old_code": "    def test_html_tag_text_following_list(self):\n        md = mistune.create_markdown(escape=False, hard_wrap=True)\n        result = md('foo\\n- bar\\n\\ntable')\n        expected = '<p>foo</p>\\n<ul>\\n<li>bar</li>\\n</ul>\\n<p>table</p>'\n        self.assertEqual(result.strip(), expected)"
    },
    {
      "path": "tests/test_plugins.py",
      "version": "new",
      "line": 9,
      "kind": "function",
      "qualname": "tests.test_plugins.load_plugin",
      "span": [
        7,
        20
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def load_plugin(plugin_name):\n    md1 = create_markdown(escape=False, plugins=[plugin_name])\n    md2 = create_markdown(escape=False, plugins=[plugin_name, \"speedup\"])\n\n    class TestPlugin1(BaseTestCase):\n        parse = md1\n\n    class TestPlugin2(BaseTestCase):\n        parse = md2\n\n    TestPlugin1.load_fixtures(plugin_name + \".txt\")\n    TestPlugin2.load_fixtures(plugin_name + \".txt\")\n    globals()[\"TestPlugin1_\" + plugin_name] = TestPlugin1\n    globals()[\"TestPlugin2_\" + plugin_name] = TestPlugin2",
      "old_code": "def load_plugin(plugin_name):\n    md1 = create_markdown(escape=False, plugins=[plugin_name])\n    md2 = create_markdown(escape=False, plugins=[plugin_name, 'speedup'])\n\n    class TestPlugin1(BaseTestCase):\n        parse = md1\n\n    class TestPlugin2(BaseTestCase):\n        parse = md2\n\n    TestPlugin1.load_fixtures(plugin_name + \".txt\")\n    TestPlugin2.load_fixtures(plugin_name + \".txt\")\n    globals()[\"TestPlugin1_\" + plugin_name] = TestPlugin1\n    globals()[\"TestPlugin2_\" + plugin_name] = TestPlugin2"
    },
    {
      "path": "tests/test_plugins.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "tests.test_plugins.TestExtraPlugins.test_table_in_list",
      "span": [
        40,
        45
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_table_in_list(self):\n        text = \"\"\"- Cell | Cell\\n  ---- | ----\\n   1  |  2\\n\"\"\"\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=[\"table\", table_in_list])\n        self.assertNotIn(\"<table>\", md1(text))\n        self.assertIn(\"<table>\", md2(text))",
      "old_code": "    def test_table_in_list(self):\n        text = '''- Cell | Cell\\n  ---- | ----\\n   1  |  2\\n'''\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=['table', table_in_list])\n        self.assertNotIn('<table>', md1(text))\n        self.assertIn('<table>', md2(text))"
    },
    {
      "path": "tests/test_plugins.py",
      "version": "new",
      "line": 48,
      "kind": "function",
      "qualname": "tests.test_plugins.TestExtraPlugins.test_table_in_quote",
      "span": [
        47,
        52
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_table_in_quote(self):\n        text = \"\"\"> Cell | Cell\\n> ---- | ----\\n>  1  |  2\\n\"\"\"\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=[\"table\", table_in_quote])\n        self.assertNotIn(\"<table>\", md1(text))\n        self.assertIn(\"<table>\", md2(text))",
      "old_code": "    def test_table_in_quote(self):\n        text = '''> Cell | Cell\\n> ---- | ----\\n>  1  |  2\\n'''\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=['table', table_in_quote])\n        self.assertNotIn('<table>', md1(text))\n        self.assertIn('<table>', md2(text))"
    },
    {
      "path": "tests/test_plugins.py",
      "version": "new",
      "line": 55,
      "kind": "function",
      "qualname": "tests.test_plugins.TestExtraPlugins.test_math_in_list",
      "span": [
        54,
        59
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_math_in_list(self):\n        text = \"\"\"- $$\\n  foo\\n  $$\\n\"\"\"\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=[\"math\", math_in_list])\n        self.assertNotIn('class=\"math\"', md1(text))\n        self.assertIn('class=\"math\"', md2(text))",
      "old_code": "    def test_math_in_list(self):\n        text = '''- $$\\n  foo\\n  $$\\n'''\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=['math', math_in_list])\n        self.assertNotIn('class=\"math\"', md1(text))\n        self.assertIn('class=\"math\"', md2(text))"
    },
    {
      "path": "tests/test_plugins.py",
      "version": "new",
      "line": 62,
      "kind": "function",
      "qualname": "tests.test_plugins.TestExtraPlugins.test_math_in_quote",
      "span": [
        61,
        66
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_math_in_quote(self):\n        text = \"\"\"> $$\\n> foo\\n> $$\\n\"\"\"\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=[\"math\", math_in_quote])\n        self.assertNotIn('class=\"math\"', md1(text))\n        self.assertIn('class=\"math\"', md2(text))",
      "old_code": "    def test_math_in_quote(self):\n        text = '''> $$\\n> foo\\n> $$\\n'''\n        md1 = create_markdown(escape=False)\n        md2 = create_markdown(escape=False, plugins=['math', math_in_quote])\n        self.assertNotIn('class=\"math\"', md1(text))\n        self.assertIn('class=\"math\"', md2(text))"
    },
    {
      "path": "tests/test_renderers.py",
      "version": "new",
      "line": 12,
      "kind": "function",
      "qualname": "tests.test_renderers.load_renderer",
      "span": [
        7,
        13
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def load_renderer(renderer):\n    class TestRenderer(BaseTestCase):\n        parse = create_markdown(renderer=renderer)\n\n    name = renderer.NAME\n    TestRenderer.load_fixtures(\"renderer_\" + name + \".txt\")\n    globals()[\"TestRenderer\" + name.title()] = TestRenderer",
      "old_code": "def load_renderer(renderer):\n    class TestRenderer(BaseTestCase):\n        parse = create_markdown(renderer=renderer)\n\n    name = renderer.NAME\n    TestRenderer.load_fixtures('renderer_' + name + '.txt')\n    globals()[\"TestRenderer\" + name.title()] = TestRenderer"
    },
    {
      "path": "tests/test_syntax.py",
      "version": "new",
      "line": 11,
      "kind": "module",
      "qualname": "tests.test_syntax",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-10T15:02:16"
}