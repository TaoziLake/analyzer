{
  "commit": "ea3ecaf",
  "parent": "45e4de61b8897fe5b0458d5ebe3d3cc7bde408d2",
  "repo": "D:\\locbench\\mistune",
  "num_files_in_diff": 1,
  "num_py_files_in_diff": 1,
  "num_seeds": 1,
  "seeds": [
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 101,
      "kind": "function",
      "qualname": "src.mistune.list_parser._parse_list_item",
      "span": [
        88,
        195
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: Tuple[str, str, str],\n    token: Dict[str, Any],\n    state: \"BlockState\",\n    rules: List[str],\n) -> Optional[Tuple[str, str, str]]:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    list_item_breaks = [\n        \"thematic_break\",\n        \"fenced_code\",\n        \"atx_heading\",\n        \"block_quote\",\n        \"block_html\",\n        \"list\",\n    ]\n    if 'fenced_directive' in block.specification:\n        list_item_breaks.insert(1, \"fenced_directive\")\n\n    pairs = [\n        (name, block.specification[name])\n        for name in list_item_breaks\n    ]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace(\"3\", _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, (\"list_item\", item_pattern))\n    regex = \"|\".join(r\"(?P<%s>(?<=\\n)%s)\" % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = \"\"\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = \" \" * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += \"\\n\"\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == \"list_item\":\n                if prev_blank_line:\n                    token[\"tight\"] = False\n                next_group = (m.group(\"listitem_1\"), m.group(\"listitem_2\"), m.group(\"listitem_3\"))\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == \"list\":\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token[\"_tok_index\"] = tok_index\n                token[\"_end_pos\"] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token[\"tight\"] and _is_loose_list(child.tokens):\n        token[\"tight\"] = False\n\n    token[\"children\"].append(\n        {\n            \"type\": \"list_item\",\n            \"children\": child.tokens,\n        }\n    )\n    if next_group:\n        return next_group\n\n    return None",
      "old_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: Tuple[str, str, str],\n    token: Dict[str, Any],\n    state: \"BlockState\",\n    rules: List[str],\n) -> Optional[Tuple[str, str, str]]:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    pairs = [\n        (\"thematic_break\", block.specification[\"thematic_break\"]),\n        (\"fenced_code\", block.specification[\"fenced_code\"]),\n        (\"atx_heading\", block.specification[\"atx_heading\"]),\n        (\"block_quote\", block.specification[\"block_quote\"]),\n        (\"block_html\", block.specification[\"block_html\"]),\n        (\"list\", block.specification[\"list\"]),\n    ]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace(\"3\", _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, (\"list_item\", item_pattern))\n    regex = \"|\".join(r\"(?P<%s>(?<=\\n)%s)\" % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = \"\"\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = \" \" * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += \"\\n\"\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == \"list_item\":\n                if prev_blank_line:\n                    token[\"tight\"] = False\n                next_group = (m.group(\"listitem_1\"), m.group(\"listitem_2\"), m.group(\"listitem_3\"))\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == \"list\":\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token[\"_tok_index\"] = tok_index\n                token[\"_end_pos\"] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token[\"tight\"] and _is_loose_list(child.tokens):\n        token[\"tight\"] = False\n\n    token[\"children\"].append(\n        {\n            \"type\": \"list_item\",\n            \"children\": child.tokens,\n        }\n    )\n    if next_group:\n        return next_group\n\n    return None"
    }
  ],
  "generated_at": "2026-02-10T14:58:49"
}