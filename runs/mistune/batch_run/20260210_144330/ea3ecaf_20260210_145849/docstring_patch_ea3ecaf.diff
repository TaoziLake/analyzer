--- a/src/mistune/list_parser.py
+++ b/src/mistune/list_parser.py
@@ -18,7 +18,23 @@
 
 
 def parse_list(block: "BlockParser", m: Match[str], state: "BlockState") -> int:
-    """Parse tokens for ordered and unordered list."""
+    """def parse_list(block: "BlockParser", m: Match[str], state: "BlockState") -> int:
+        """Parse tokens for ordered and unordered lists, including support for fenced directives within list items.
+
+        Args:
+            block: Block parser instance containing list parsing rules and configuration
+            m: Regex match object containing list components (marker, content, etc.)
+            state: Current block parsing state with cursor position and depth tracking
+
+        Returns:
+            Updated cursor position after list parsing completes
+
+        Raises:
+            May propagate errors from list item parsing operations
+
+        Changelog:
+            ea3ecaf: Updated list item parsing to support fenced directives as list item terminators. List items can now contain fenced code blocks and other directive-based elements, which will properly terminate list item continuation when encountered. This affects list parsing behavior when directive-containing blocks appear within lists.
+    """
     text = m.group("list_3")
     if not text.strip():
         # Example 285
@@ -93,6 +109,25 @@
     state: "BlockState",
     rules: List[str],
 ) -> Optional[Tuple[str, str, str]]:
+    """Function to parse a list item block in markdown, handling indentation, nested elements, and tight/loose list detection.
+
+    Args:
+        block: BlockParser instance containing parsing rules and methods
+        bullet: String representing the list bullet character(s)
+        groups: Tuple containing (spaces, marker, text) from list item match
+        token: Dictionary containing current list token state
+        state: BlockState tracking parsing position and tokens
+        rules: List of active block parsing rules
+
+    Returns:
+        Optional tuple of (spaces, marker, text) for next list item if continuation found, else None
+
+    Raises:
+        May raise exceptions during regex matching or token processing
+
+    Changelog:
+        ea3ecaf: Added support for fenced_directive in list item breaks. Modified pairs list construction to dynamically include block.specification elements. Now checks for 'fenced_directive' in block.specification and inserts it at position 1 if present, affecting which elements can break a list item. Maintains previous behavior for leading_width <3 replacement logic.
+    """
     spaces, marker, text = groups
 
     leading_width = len(spaces) + len(marker)

--- a/src/mistune/block_parser.py
+++ b/src/mistune/block_parser.py
@@ -383,7 +383,19 @@
         return state.cursor
 
     def parse_list(self, m: Match[str], state: BlockState) -> int:
-        """Parse tokens for ordered and unordered list."""
+        """def parse_list(self, m: Match[str], state: BlockState) -> int:
+            """Parse tokens for ordered and unordered list.
+
+            Args:
+                m: Regular expression match object containing list delimiter information
+                state: Current block parsing state including position and nesting level
+
+            Returns:
+                int: Number of characters consumed from the input
+
+            Changelog:
+                ea3ecaf: Improved handling of fenced directives within list items. Lists now correctly terminate list items when encountering code blocks or custom directives inside lists, preventing incorrect merging of content. This maintains compatibility with extended markdown syntax while preserving the existing function signature and core list parsing behavior.
+        """
         return parse_list(self, m, state)
 
     def parse_block_html(self, m: Match[str], state: BlockState) -> Optional[int]:
