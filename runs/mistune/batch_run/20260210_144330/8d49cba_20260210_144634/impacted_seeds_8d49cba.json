{
  "commit": "8d49cba",
  "parent": "7e0eb658e70e27e409cbf61f49a0907731e17acf",
  "repo": "D:\\locbench\\mistune",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 7,
  "seeds": [
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 3,
      "kind": "module",
      "qualname": "src.mistune.list_parser",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 35,
      "kind": "function",
      "qualname": "src.mistune.list_parser.parse_list",
      "span": [
        22,
        76
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def parse_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n    text = m.group(\"list_3\")\n    if not text.strip():\n        # Example 285\n        # an empty list item cannot interrupt a paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n    marker = m.group(\"list_2\")\n    ordered = len(marker) > 1\n    depth = state.depth()\n    token: dict[str, Any] = {\n        \"type\": \"list\",\n        \"children\": [],\n        \"tight\": True,\n        \"bullet\": marker[-1],\n        \"attrs\": {\n            \"depth\": depth,\n            \"ordered\": ordered,\n        },\n    }\n    if ordered:\n        start = int(marker[:-1])\n        if start != 1:\n            # Example 304\n            # we allow only lists starting with 1 to interrupt paragraphs\n            end_pos = state.append_paragraph()\n            if end_pos:\n                return end_pos\n            token[\"attrs\"][\"start\"] = start\n\n    state.cursor = m.end() + 1\n    groups: Optional[tuple[str, str, str]] = (m.group(\"list_1\"), marker, text)\n\n    if depth >= block.max_nested_level - 1:\n        rules = list(block.list_rules)\n        rules.remove(\"list\")\n    else:\n        rules = block.list_rules\n\n    bullet = _get_list_bullet(marker[-1])\n    while groups:\n        groups = _parse_list_item(block, bullet, groups, token, state, rules)\n\n    end_pos = token.pop(\"_end_pos\", None)\n    _transform_tight_list(token)\n    if end_pos:\n        index = token.pop(\"_tok_index\")\n        state.tokens.insert(index, token)\n        return end_pos  # type: ignore[no-any-return]\n\n    state.append_token(token)\n    return state.cursor",
      "old_code": "def parse_list(block: \"BlockParser\", m: Match[str], state: \"BlockState\") -> int:\n    \"\"\"Parse tokens for ordered and unordered list.\"\"\"\n    text = m.group(\"list_3\")\n    if not text.strip():\n        # Example 285\n        # an empty list item cannot interrupt a paragraph\n        end_pos = state.append_paragraph()\n        if end_pos:\n            return end_pos\n\n    marker = m.group(\"list_2\")\n    ordered = len(marker) > 1\n    depth = state.depth()\n    token: Dict[str, Any] = {\n        \"type\": \"list\",\n        \"children\": [],\n        \"tight\": True,\n        \"bullet\": marker[-1],\n        \"attrs\": {\n            \"depth\": depth,\n            \"ordered\": ordered,\n        },\n    }\n    if ordered:\n        start = int(marker[:-1])\n        if start != 1:\n            # Example 304\n            # we allow only lists starting with 1 to interrupt paragraphs\n            end_pos = state.append_paragraph()\n            if end_pos:\n                return end_pos\n            token[\"attrs\"][\"start\"] = start\n\n    state.cursor = m.end() + 1\n    groups: Optional[Tuple[str, str, str]] = (m.group(\"list_1\"), marker, text)\n\n    if depth >= block.max_nested_level - 1:\n        rules = list(block.list_rules)\n        rules.remove(\"list\")\n    else:\n        rules = block.list_rules\n\n    bullet = _get_list_bullet(marker[-1])\n    while groups:\n        groups = _parse_list_item(block, bullet, groups, token, state, rules)\n\n    end_pos = token.pop(\"_end_pos\", None)\n    _transform_tight_list(token)\n    if end_pos:\n        index = token.pop(\"_tok_index\")\n        state.tokens.insert(index, token)\n        return end_pos\n\n    state.append_token(token)\n    return state.cursor"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 79,
      "kind": "function",
      "qualname": "src.mistune.list_parser._transform_tight_list",
      "span": [
        79,
        87
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _transform_tight_list(token: dict[str, Any]) -> None:\n    if token[\"tight\"]:\n        # reset tight list item\n        for list_item in token[\"children\"]:\n            for tok in list_item[\"children\"]:\n                if tok[\"type\"] == \"paragraph\":\n                    tok[\"type\"] = \"block_text\"\n                elif tok[\"type\"] == \"list\":\n                    _transform_tight_list(tok)",
      "old_code": "def _transform_tight_list(token: Dict[str, Any]) -> None:\n    if token[\"tight\"]:\n        # reset tight list item\n        for list_item in token[\"children\"]:\n            for tok in list_item[\"children\"]:\n                if tok[\"type\"] == \"paragraph\":\n                    tok[\"type\"] = \"block_text\"\n                elif tok[\"type\"] == \"list\":\n                    _transform_tight_list(tok)"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 93,
      "kind": "function",
      "qualname": "src.mistune.list_parser._parse_list_item",
      "span": [
        90,
        194
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: tuple[str, str, str],\n    token: dict[str, Any],\n    state: \"BlockState\",\n    rules: list[str],\n) -> tuple[str, str, str] | None:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    list_item_breaks = [\n        \"thematic_break\",\n        \"fenced_code\",\n        \"atx_heading\",\n        \"block_quote\",\n        \"block_html\",\n        \"list\",\n    ]\n    if \"fenced_directive\" in block.specification:\n        list_item_breaks.insert(1, \"fenced_directive\")\n\n    pairs = [(name, block.specification[name]) for name in list_item_breaks]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace(\"3\", _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, (\"list_item\", item_pattern))\n    regex = \"|\".join(r\"(?P<%s>(?<=\\n)%s)\" % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = \"\"\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = \" \" * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += \"\\n\"\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == \"list_item\":\n                if prev_blank_line:\n                    token[\"tight\"] = False\n                next_group = (m.group(\"listitem_1\"), m.group(\"listitem_2\"), m.group(\"listitem_3\"))\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == \"list\":\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token[\"_tok_index\"] = tok_index\n                token[\"_end_pos\"] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token[\"tight\"] and _is_loose_list(child.tokens):\n        token[\"tight\"] = False\n\n    token[\"children\"].append(\n        {\n            \"type\": \"list_item\",\n            \"children\": child.tokens,\n        }\n    )\n    if next_group:\n        return next_group\n\n    return None",
      "old_code": "def _parse_list_item(\n    block: \"BlockParser\",\n    bullet: str,\n    groups: Tuple[str, str, str],\n    token: Dict[str, Any],\n    state: \"BlockState\",\n    rules: List[str],\n) -> Optional[Tuple[str, str, str]]:\n    spaces, marker, text = groups\n\n    leading_width = len(spaces) + len(marker)\n    text, continue_width = _compile_continue_width(text, leading_width)\n    item_pattern = _compile_list_item_pattern(bullet, leading_width)\n    list_item_breaks = [\n        \"thematic_break\",\n        \"fenced_code\",\n        \"atx_heading\",\n        \"block_quote\",\n        \"block_html\",\n        \"list\",\n    ]\n    if \"fenced_directive\" in block.specification:\n        list_item_breaks.insert(1, \"fenced_directive\")\n\n    pairs = [(name, block.specification[name]) for name in list_item_breaks]\n    if leading_width < 3:\n        _repl_w = str(leading_width)\n        pairs = [(n, p.replace(\"3\", _repl_w, 1)) for n, p in pairs]\n\n    pairs.insert(1, (\"list_item\", item_pattern))\n    regex = \"|\".join(r\"(?P<%s>(?<=\\n)%s)\" % pair for pair in pairs)\n    sc = re.compile(regex, re.M)\n\n    src = \"\"\n    next_group = None\n    prev_blank_line = False\n    pos = state.cursor\n\n    continue_space = \" \" * continue_width\n    while pos < state.cursor_max:\n        pos = state.find_line_end()\n        line = state.get_text(pos)\n        if block.BLANK_LINE.match(line):\n            src += \"\\n\"\n            prev_blank_line = True\n            state.cursor = pos\n            continue\n\n        line = expand_leading_tab(line)\n        if line.startswith(continue_space):\n            if prev_blank_line and not text and not src.strip():\n                # Example 280\n                # A list item can begin with at most one blank line\n                break\n\n            src += line\n            prev_blank_line = False\n            state.cursor = pos\n            continue\n\n        m = sc.match(state.src, state.cursor)\n        if m:\n            tok_type = m.lastgroup\n            if tok_type == \"list_item\":\n                if prev_blank_line:\n                    token[\"tight\"] = False\n                next_group = (m.group(\"listitem_1\"), m.group(\"listitem_2\"), m.group(\"listitem_3\"))\n                state.cursor = m.end() + 1\n                break\n\n            if tok_type == \"list\":\n                break\n\n            tok_index = len(state.tokens)\n            end_pos = block.parse_method(m, state)\n            if end_pos:\n                token[\"_tok_index\"] = tok_index\n                token[\"_end_pos\"] = end_pos\n                break\n\n        if prev_blank_line and not line.startswith(continue_space):\n            # not a continue line, and previous line is blank\n            break\n\n        src += line\n        state.cursor = pos\n\n    text += _clean_list_item_text(src, continue_width)\n    child = state.child_state(strip_end(text))\n\n    block.parse(child, rules)\n\n    if token[\"tight\"] and _is_loose_list(child.tokens):\n        token[\"tight\"] = False\n\n    token[\"children\"].append(\n        {\n            \"type\": \"list_item\",\n            \"children\": child.tokens,\n        }\n    )\n    if next_group:\n        return next_group\n\n    return None"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 221,
      "kind": "function",
      "qualname": "src.mistune.list_parser._compile_continue_width",
      "span": [
        221,
        239
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _compile_continue_width(text: str, leading_width: int) -> tuple[str, int]:\n    text = expand_leading_tab(text, 3)\n    text = expand_tab(text)\n\n    m2 = _LINE_HAS_TEXT.match(text)\n    if m2:\n        # indent code, startswith 5 spaces\n        if text.startswith(\"     \"):\n            space_width = 1\n        else:\n            space_width = len(m2.group(1))\n\n        text = text[space_width:] + \"\\n\"\n    else:\n        space_width = 1\n        text = \"\"\n\n    continue_width = leading_width + space_width\n    return text, continue_width",
      "old_code": "def _compile_continue_width(text: str, leading_width: int) -> Tuple[str, int]:\n    text = expand_leading_tab(text, 3)\n    text = expand_tab(text)\n\n    m2 = _LINE_HAS_TEXT.match(text)\n    if m2:\n        # indent code, startswith 5 spaces\n        if text.startswith(\"     \"):\n            space_width = 1\n        else:\n            space_width = len(m2.group(1))\n\n        text = text[space_width:] + \"\\n\"\n    else:\n        space_width = 1\n        text = \"\"\n\n    continue_width = leading_width + space_width\n    return text, continue_width"
    },
    {
      "path": "src/mistune/list_parser.py",
      "version": "new",
      "line": 260,
      "kind": "function",
      "qualname": "src.mistune.list_parser._is_loose_list",
      "span": [
        260,
        269
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _is_loose_list(tokens: Iterable[dict[str, Any]]) -> bool:\n    paragraph_count = 0\n    for tok in tokens:\n        if tok[\"type\"] == \"blank_line\":\n            return True\n        if tok[\"type\"] == \"paragraph\":\n            paragraph_count += 1\n            if paragraph_count > 1:\n                return True\n    return False",
      "old_code": "def _is_loose_list(tokens: Iterable[Dict[str, Any]]) -> bool:\n    paragraph_count = 0\n    for tok in tokens:\n        if tok[\"type\"] == \"blank_line\":\n            return True\n        if tok[\"type\"] == \"paragraph\":\n            paragraph_count += 1\n            if paragraph_count > 1:\n                return True\n    return False"
    },
    {
      "path": "src/mistune/renderers/markdown.py",
      "version": "new",
      "line": 54,
      "kind": "function",
      "qualname": "src.mistune.renderers.markdown.MarkdownRenderer.link",
      "span": [
        46,
        68
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = \"[\" + text + \"]\"\n        if label:\n            return out + \"[\" + label + \"]\"\n\n        attrs = token[\"attrs\"]\n        url: str = attrs[\"url\"]\n        title = attrs.get(\"title\")\n        if text == url and not title:\n            return \"<\" + text + \">\"\n        elif \"mailto:\" + text == url and not title:\n            return \"<\" + text + \">\"\n\n        out += \"(\"\n        if \"(\" in url or \")\" in url:\n            out += \"<\" + url + \">\"\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + \")\"",
      "old_code": "    def link(self, token: Dict[str, Any], state: BlockState) -> str:\n        label = cast(str, token.get(\"label\"))\n        text = self.render_children(token, state)\n        out = \"[\" + text + \"]\"\n        if label:\n            return out + \"[\" + label + \"]\"\n\n        attrs = token[\"attrs\"]\n        url = attrs[\"url\"]\n        title = attrs.get(\"title\")\n        if text == url and not title:\n            return \"<\" + text + \">\"\n        elif \"mailto:\" + text == url and not title:\n            return \"<\" + text + \">\"\n\n        out += \"(\"\n        if \"(\" in url or \")\" in url:\n            out += \"<\" + url + \">\"\n        else:\n            out += url\n        if title:\n            out += ' \"' + title + '\"'\n        return out + \")\""
    }
  ],
  "generated_at": "2026-02-10T14:46:35"
}