{
  "commit": "e96e6716",
  "parent": "632fd880f8107032282b157ae511c204384bf734",
  "repo": "D:\\locbench\\peewee",
  "num_files_in_diff": 1,
  "num_py_files_in_diff": 1,
  "num_seeds": 18,
  "seeds": [
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 2,
      "kind": "module",
      "qualname": "playhouse.cysqlite_ext",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 18,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.__status__",
      "span": [
        18,
        22
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def __status__(flag, return_highwater=False):\n    def getter(self):\n        result = cysqlite.status(flag)\n        return result[1] if return_highwater else result\n    return property(getter)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 19,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.__status__.getter",
      "span": [
        19,
        21
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def getter(self):\n        result = cysqlite.status(flag)\n        return result[1] if return_highwater else result",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 24,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.__dbstatus__",
      "span": [
        24,
        37
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def __dbstatus__(flag, return_highwater=False, return_current=False):\n    \"\"\"\n    Expose a sqlite3_dbstatus() call for a particular flag as a property of\n    the Database instance. Unlike sqlite3_status(), the dbstatus properties\n    pertain to the current connection.\n    \"\"\"\n    def getter(self):\n        if self._state.conn is None:\n            raise ImproperlyConfigured('database connection not opened.')\n        result = sqlite_get_db_status(self._state.conn, flag)\n        if return_current:\n            return result[0]\n        return result[1] if return_highwater else result\n    return property(getter)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 30,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.__dbstatus__.getter",
      "span": [
        30,
        36
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def getter(self):\n        if self._state.conn is None:\n            raise ImproperlyConfigured('database connection not opened.')\n        result = sqlite_get_db_status(self._state.conn, flag)\n        if return_current:\n            return result[0]\n        return result[1] if return_highwater else result",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 41,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.__init__",
      "span": [
        41,
        57
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, database, rank_functions=True, regexp_function=False,\n                 *args, **kwargs):\n        super(CySqliteDatabase, self).__init__(database, *args, **kwargs)\n\n        self._commit_hook = None\n        self._rollback_hook = None\n        self._update_hook = None\n        self._authorizer = None\n        self._trace = None\n        self._progress = None\n\n        if rank_functions:\n            self.register_function(cysqlite.rank_bm25, 'fts_bm25')\n            self.register_function(cysqlite.rank_lucene, 'fts_lucene')\n\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 58,
      "kind": "class",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase",
      "span": [
        40,
        219
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class CySqliteDatabase(SqliteDatabase):\n    def __init__(self, database, rank_functions=True, regexp_function=False,\n                 *args, **kwargs):\n        super(CySqliteDatabase, self).__init__(database, *args, **kwargs)\n\n        self._commit_hook = None\n        self._rollback_hook = None\n        self._update_hook = None\n        self._authorizer = None\n        self._trace = None\n        self._progress = None\n\n        if rank_functions:\n            self.register_function(cysqlite.rank_bm25, 'fts_bm25')\n            self.register_function(cysqlite.rank_lucene, 'fts_lucene')\n\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)\n\n    def _connect(self):\n        if cysqlite is None:\n            raise ImproperlyConfigured('cysqlite is not installed.')\n        conn = cysqlite.Connection(self.database, timeout=self._timeout,\n                                   extensions=True, **self.connect_params)\n        try:\n            self._add_conn_hooks(conn)\n        except Exception:\n            conn.close()\n            raise\n        return conn\n\n    def _add_conn_hooks(self, conn):\n        if self._commit_hook is not None:\n            conn.commit_hook(self._commit_hook)\n        if self._rollback_hook is not None:\n            conn.rollback_hook(self._rollback_hook)\n        if self._update_hook is not None:\n            conn.update_hook(self._update_hook)\n        if self._authorizer is not None:\n            conn.authorizer(self._authorizer)\n        if self._trace is not None:\n            conn.trace(*self._trace)\n        if self._progress is not None:\n            conn.progress(*self._progress)\n        super(CySqliteDatabase, self)._add_conn_hooks(conn)\n\n    def _set_pragmas(self, conn):\n        for pragma, value in self._pragmas:\n            conn.pragma(pragma, value)\n\n    def _attach_databases(self, conn):\n        for name, db in self._attached.items():\n            conn.attach(db, name)\n\n    def _load_aggregates(self, conn):\n        for name, (klass, num_params) in self._aggregates.items():\n            conn.create_aggregate(klass, name, num_params)\n\n    def _load_collations(self, conn):\n        for name, fn in self._collations.items():\n            conn.create_collation(fn, name)\n\n    def _load_functions(self, conn):\n        for name, (fn, num_params, deterministic) in self._functions.items():\n            conn.create_function(fn, name, num_params, deterministic)\n\n    def _load_window_functions(self, conn):\n        for name, (klass, num_params) in self._window_functions.items():\n            conn.create_window_function(klass, name, num_params)\n\n    def on_commit(self, fn):\n        self._commit_hook = fn\n        if not self.is_closed():\n            conn.commit_hook(fn)\n        return fn\n\n    def on_rollback(self, fn):\n        self._rollback_hook = fn\n        if not self.is_closed():\n            conn.rollback_hook(fn)\n        return fn\n\n    def on_update(self, fn):\n        self._update_hook = fn\n        if not self.is_closed():\n            conn.update_hook(fn)\n        return fn\n\n    def authorizer(self, fn):\n        self._authorizer = fn\n        if not self.is_closed():\n            conn.authorizer(fn)\n        return fn\n\n    def trace(self, fn, mask=2):\n        if fn is None:\n            self._trace = None\n        else:\n            self._trace = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._trace\n            conn.authorizer(*args)\n        return fn\n\n    def progress(self, fn, n=1):\n        if fn is None:\n            self._progress = None\n        else:\n            self._progress = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._progress\n            conn.progress(*args)\n        return fn\n\n    def begin(self, lock_type='deferred'):\n        with __exception_wrapper__:\n            self.connection().begin(lock_type)\n\n    def commit(self):\n        with __exception_wrapper__:\n            self.connection().commit()\n\n    def rollback(self):\n        with __exception_wrapper__:\n            self.connection().rollback()\n\n    @property\n    def autocommit(self):\n        return self.connection().autocommit()\n\n    def backup(self, destination, pages=None, name=None, progress=None,\n               src_name=None):\n\n        if isinstance(destination, CySqliteDatabase):\n            conn = destination.connection()\n        elif isinstance(destination, cysqlite.Connection):\n            conn = destination\n        elif isinstance(destination, (str, Path)):\n            return self.backup_to_file(str(destination), pages, name,\n                                       progress, src_name)\n\n        return self.connection().backup(conn, pages, name, progress, src_name)\n\n    def backup_to_file(self, filename, pages=None, name=None, progress=None,\n                       src_name=None):\n        return self.connection().backup_to_file(filename, pages, name,\n                                                progress, src_name)\n\n    # Status properties.\n    memory_used = __status__(cysqlite.C_SQLITE_STATUS_MEMORY_USED)\n    malloc_size = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_SIZE, True)\n    malloc_count = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_COUNT)\n    pagecache_used = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_USED)\n    pagecache_overflow = __status__(\n        cysqlite.C_SQLITE_STATUS_PAGECACHE_OVERFLOW)\n    pagecache_size = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_SIZE, True)\n    scratch_used = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_USED)\n    scratch_overflow = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_OVERFLOW)\n    scratch_size = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_SIZE, True)\n\n    # Connection status properties.\n    lookaside_used = __dbstatus__(cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_USED)\n    lookaside_hit = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_HIT, True)\n    lookaside_miss = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE, True)\n    lookaside_miss_full = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL, True)\n    cache_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_USED, False, True)\n    schema_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_SCHEMA_USED, False, True)\n    statement_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_STMT_USED, False, True)\n    cache_hit = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_HIT, False, True)\n    cache_miss = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_MISS, False, True)\n    cache_write = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_WRITE, False, True)",
      "old_code": "class CySqliteDatabase(SqliteDatabase):\n    def _connect(self):\n        if cysqlite is None:\n            raise ImproperlyConfigured('cysqlite is not installed.')\n        conn = cysqlite.Connection(self.database, timeout=self._timeout,\n                                   extensions=True, **self.connect_params)\n        try:\n            self._add_conn_hooks(conn)\n        except Exception:\n            conn.close()\n            raise\n        return conn\n\n    def _set_pragmas(self, conn):\n        for pragma, value in self._pragmas:\n            conn.pragma(pragma, value)\n\n    def _attach_databases(self, conn):\n        for name, db in self._attached.items():\n            conn.attach(db, name)\n\n    def _load_aggregates(self, conn):\n        for name, (klass, num_params) in self._aggregates.items():\n            conn.create_aggregate(klass, name, num_params)\n\n    def _load_collations(self, conn):\n        for name, fn in self._collations.items():\n            conn.create_collation(fn, name)\n\n    def _load_functions(self, conn):\n        for name, (fn, num_params, deterministic) in self._functions.items():\n            conn.create_function(fn, name, num_params, deterministic)\n\n    def _load_window_functions(self, conn):\n        for name, (klass, num_params) in self._window_functions.items():\n            conn.create_window_function(klass, name, num_params)\n\n    def begin(self, lock_type='deferred'):\n        with __exception_wrapper__:\n            self.connection().begin(lock_type)\n\n    def commit(self):\n        with __exception_wrapper__:\n            self.connection().commit()\n\n    def rollback(self):\n        with __exception_wrapper__:\n            self.connection().rollback()"
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 71,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase._add_conn_hooks",
      "span": [
        71,
        84
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _add_conn_hooks(self, conn):\n        if self._commit_hook is not None:\n            conn.commit_hook(self._commit_hook)\n        if self._rollback_hook is not None:\n            conn.rollback_hook(self._rollback_hook)\n        if self._update_hook is not None:\n            conn.update_hook(self._update_hook)\n        if self._authorizer is not None:\n            conn.authorizer(self._authorizer)\n        if self._trace is not None:\n            conn.trace(*self._trace)\n        if self._progress is not None:\n            conn.progress(*self._progress)\n        super(CySqliteDatabase, self)._add_conn_hooks(conn)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 110,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.on_commit",
      "span": [
        110,
        114
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def on_commit(self, fn):\n        self._commit_hook = fn\n        if not self.is_closed():\n            conn.commit_hook(fn)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 116,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.on_rollback",
      "span": [
        116,
        120
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def on_rollback(self, fn):\n        self._rollback_hook = fn\n        if not self.is_closed():\n            conn.rollback_hook(fn)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 122,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.on_update",
      "span": [
        122,
        126
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def on_update(self, fn):\n        self._update_hook = fn\n        if not self.is_closed():\n            conn.update_hook(fn)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 128,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.authorizer",
      "span": [
        128,
        132
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def authorizer(self, fn):\n        self._authorizer = fn\n        if not self.is_closed():\n            conn.authorizer(fn)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 134,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.trace",
      "span": [
        134,
        142
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def trace(self, fn, mask=2):\n        if fn is None:\n            self._trace = None\n        else:\n            self._trace = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._trace\n            conn.authorizer(*args)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 144,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.progress",
      "span": [
        144,
        152
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def progress(self, fn, n=1):\n        if fn is None:\n            self._progress = None\n        else:\n            self._progress = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._progress\n            conn.progress(*args)\n        return fn",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 167,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.autocommit",
      "span": [
        167,
        168
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def autocommit(self):\n        return self.connection().autocommit()",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 170,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.backup",
      "span": [
        170,
        181
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def backup(self, destination, pages=None, name=None, progress=None,\n               src_name=None):\n\n        if isinstance(destination, CySqliteDatabase):\n            conn = destination.connection()\n        elif isinstance(destination, cysqlite.Connection):\n            conn = destination\n        elif isinstance(destination, (str, Path)):\n            return self.backup_to_file(str(destination), pages, name,\n                                       progress, src_name)\n\n        return self.connection().backup(conn, pages, name, progress, src_name)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 183,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase.backup_to_file",
      "span": [
        183,
        186
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def backup_to_file(self, filename, pages=None, name=None, progress=None,\n                       src_name=None):\n        return self.connection().backup_to_file(filename, pages, name,\n                                                progress, src_name)",
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 224,
      "kind": "function",
      "qualname": "playhouse.cysqlite_ext._sqlite_regexp",
      "span": [
        224,
        225
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _sqlite_regexp(regex, value):\n    return re.search(regex, value) is not None",
      "old_code": null
    }
  ],
  "generated_at": "2026-02-11T11:15:13"
}