{
  "commit": "f5755cb5",
  "parent": "8f771e4d9e8ee1eee1c0e391b47638d9e58dacef",
  "repo": "D:\\locbench\\peewee",
  "num_files_in_diff": 5,
  "num_py_files_in_diff": 2,
  "num_seeds": 16,
  "seeds": [
    {
      "path": "playhouse/sqlite_ext.py",
      "version": "new",
      "line": 1063,
      "kind": "function",
      "qualname": "playhouse.sqlite_ext.SqliteExtDatabase.__init__",
      "span": [
        1061,
        1090
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def __init__(self, database, c_extensions=None, rank_functions=True,\n                 hash_functions=False, regexp_function=False,\n                 json_contains=False, *args, **kwargs):\n        super(SqliteExtDatabase, self).__init__(database, *args, **kwargs)\n        self._row_factory = None\n\n        if c_extensions and not CYTHON_SQLITE_EXTENSIONS:\n            raise ImproperlyConfigured('SqliteExtDatabase initialized with '\n                                       'C extensions, but shared library was '\n                                       'not found!')\n        prefer_c = CYTHON_SQLITE_EXTENSIONS and (c_extensions is not False)\n        if rank_functions:\n            if prefer_c:\n                register_rank_functions(self)\n            else:\n                self.register_function(bm25, 'fts_bm25')\n                self.register_function(rank, 'fts_rank')\n                self.register_function(bm25, 'fts_bm25f')  # Fall back to bm25.\n                self.register_function(bm25, 'fts_lucene')\n        if hash_functions:\n            if not prefer_c:\n                raise ValueError('C extension required to register hash '\n                                 'functions.')\n            register_hash_functions(self)\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)\n        if json_contains:\n            self.register_function(_json_contains, 'json_contains')\n\n        self._c_extensions = prefer_c",
      "old_code": "    def __init__(self, database, c_extensions=None, rank_functions=True,\n                 hash_functions=False, regexp_function=False,\n                 bloomfilter=False, json_contains=False, *args, **kwargs):\n        super(SqliteExtDatabase, self).__init__(database, *args, **kwargs)\n        self._row_factory = None\n\n        if c_extensions and not CYTHON_SQLITE_EXTENSIONS:\n            raise ImproperlyConfigured('SqliteExtDatabase initialized with '\n                                       'C extensions, but shared library was '\n                                       'not found!')\n        prefer_c = CYTHON_SQLITE_EXTENSIONS and (c_extensions is not False)\n        if rank_functions:\n            if prefer_c:\n                register_rank_functions(self)\n            else:\n                self.register_function(bm25, 'fts_bm25')\n                self.register_function(rank, 'fts_rank')\n                self.register_function(bm25, 'fts_bm25f')  # Fall back to bm25.\n                self.register_function(bm25, 'fts_lucene')\n        if hash_functions:\n            if not prefer_c:\n                raise ValueError('C extension required to register hash '\n                                 'functions.')\n            register_hash_functions(self)\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)\n        if bloomfilter:\n            if not prefer_c:\n                raise ValueError('C extension required to use bloomfilter.')\n            register_bloomfilter(self)\n        if json_contains:\n            self.register_function(_json_contains, 'json_contains')\n\n        self._c_extensions = prefer_c"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 8,
      "kind": "module",
      "qualname": "tests.csqlite_ext",
      "span": null,
      "reason": "diff_old_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 352,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration",
      "span": [
        352,
        430
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "class TestBloomFilterIntegration(CDatabaseTestCase):\n    database = CSqliteExtDatabase(':memory:', bloomfilter=True)\n\n    def setUp(self):\n        super(TestBloomFilterIntegration, self).setUp()\n        self.execute('create table register (data TEXT);')\n\n    def populate(self):\n        accum = []\n        with self.database.atomic():\n            for i in 'abcdefghijklmnopqrstuvwxyz':\n                keys = [i * j for j in range(1, 10)]\n                accum.extend(keys)\n                self.execute('insert into register (data) values %s' %\n                             ', '.join(['(?)'] * len(keys)),\n                             *keys)\n\n        curs = self.execute('select * from register '\n                            'order by data limit 5 offset 6')\n        self.assertEqual([key for key, in curs.fetchall()],\n                         ['aaaaaaa', 'aaaaaaaa', 'aaaaaaaaa', 'b', 'bb'])\n        return accum\n\n    def test_bloomfilter(self):\n        all_keys = self.populate()\n\n        curs = self.execute('select bloomfilter(data, ?) from register',\n                            1024 * 128)\n        buf, = curs.fetchone()\n        self.assertEqual(len(buf), 1024 * 128)\n        for key in all_keys:\n            curs = self.execute('select bloomfilter_contains(?, ?)',\n                                key, buf)\n            self.assertEqual(curs.fetchone()[0], 1)\n\n        for key in all_keys:\n            key += '-test'\n            curs = self.execute('select bloomfilter_contains(?, ?)',\n                                key, buf)\n            self.assertEqual(curs.fetchone()[0], 0)\n\n    @skip_unless(sys.version_info[0] >= 3, 'requires python 3')\n    def test_bf_stored(self):\n        class Base(TestModel):\n            class Meta:\n                database = self.database\n        class BF(Base):\n            data = BlobField()\n        class Reg(Base):\n            key = TextField()\n            value = TextField()\n\n        self.database.create_tables([Reg, BF])\n        with self.database.atomic():\n            for i in range(100):\n                Reg.insert(key='k%03d' % i, value='v%064d' % i).execute()\n\n            agg = (Reg\n                   .select(fn.bloomfilter(Reg.value))\n                   .where(Reg.key.endswith('0')))\n            n = BF.insert(data=agg).execute()\n\n        query = (Reg\n                 .select()\n                 .join(BF, on=(fn.bloomfilter_contains(Reg.value, BF.data)))\n                 .order_by(Reg.key))\n        self.assertTrue(all(r.value.endswith('0') for r in query))\n        self.assertEqual(len(query), 10)\n\n        # Perform update, adding the values that end with \"1\" now.\n        for i in range(1, 100, 10):\n            BF.update(data=fn.bloomfilter_add('v%064d' % i, BF.data)).execute()\n\n        query = (Reg\n                 .select()\n                 .join(BF, on=(fn.bloomfilter_contains(Reg.value, BF.data)))\n                 .order_by(Reg.key))\n        self.assertTrue(all(r.value.endswith(('0', '1')) for r in query))\n        self.assertEqual(len(query), 20)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 355,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.setUp",
      "span": [
        355,
        357
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def setUp(self):\n        super(TestBloomFilterIntegration, self).setUp()\n        self.execute('create table register (data TEXT);')"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 359,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.populate",
      "span": [
        359,
        373
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def populate(self):\n        accum = []\n        with self.database.atomic():\n            for i in 'abcdefghijklmnopqrstuvwxyz':\n                keys = [i * j for j in range(1, 10)]\n                accum.extend(keys)\n                self.execute('insert into register (data) values %s' %\n                             ', '.join(['(?)'] * len(keys)),\n                             *keys)\n\n        curs = self.execute('select * from register '\n                            'order by data limit 5 offset 6')\n        self.assertEqual([key for key, in curs.fetchall()],\n                         ['aaaaaaa', 'aaaaaaaa', 'aaaaaaaaa', 'b', 'bb'])\n        return accum"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 375,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bloomfilter",
      "span": [
        375,
        391
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def test_bloomfilter(self):\n        all_keys = self.populate()\n\n        curs = self.execute('select bloomfilter(data, ?) from register',\n                            1024 * 128)\n        buf, = curs.fetchone()\n        self.assertEqual(len(buf), 1024 * 128)\n        for key in all_keys:\n            curs = self.execute('select bloomfilter_contains(?, ?)',\n                                key, buf)\n            self.assertEqual(curs.fetchone()[0], 1)\n\n        for key in all_keys:\n            key += '-test'\n            curs = self.execute('select bloomfilter_contains(?, ?)',\n                                key, buf)\n            self.assertEqual(curs.fetchone()[0], 0)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 394,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bf_stored",
      "span": [
        394,
        430
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def test_bf_stored(self):\n        class Base(TestModel):\n            class Meta:\n                database = self.database\n        class BF(Base):\n            data = BlobField()\n        class Reg(Base):\n            key = TextField()\n            value = TextField()\n\n        self.database.create_tables([Reg, BF])\n        with self.database.atomic():\n            for i in range(100):\n                Reg.insert(key='k%03d' % i, value='v%064d' % i).execute()\n\n            agg = (Reg\n                   .select(fn.bloomfilter(Reg.value))\n                   .where(Reg.key.endswith('0')))\n            n = BF.insert(data=agg).execute()\n\n        query = (Reg\n                 .select()\n                 .join(BF, on=(fn.bloomfilter_contains(Reg.value, BF.data)))\n                 .order_by(Reg.key))\n        self.assertTrue(all(r.value.endswith('0') for r in query))\n        self.assertEqual(len(query), 10)\n\n        # Perform update, adding the values that end with \"1\" now.\n        for i in range(1, 100, 10):\n            BF.update(data=fn.bloomfilter_add('v%064d' % i, BF.data)).execute()\n\n        query = (Reg\n                 .select()\n                 .join(BF, on=(fn.bloomfilter_contains(Reg.value, BF.data)))\n                 .order_by(Reg.key))\n        self.assertTrue(all(r.value.endswith(('0', '1')) for r in query))\n        self.assertEqual(len(query), 20)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 395,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bf_stored.Base",
      "span": [
        395,
        397
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "        class Base(TestModel):\n            class Meta:\n                database = self.database"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 396,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bf_stored.Base.Meta",
      "span": [
        396,
        397
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "            class Meta:\n                database = self.database"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 398,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bf_stored.BF",
      "span": [
        398,
        399
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "        class BF(Base):\n            data = BlobField()"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 400,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilterIntegration.test_bf_stored.Reg",
      "span": [
        400,
        402
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "        class Reg(Base):\n            key = TextField()\n            value = TextField()"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 433,
      "kind": "class",
      "qualname": "tests.csqlite_ext.TestBloomFilter",
      "span": [
        433,
        499
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "class TestBloomFilter(BaseTestCase):\n    n = 1024\n\n    def setUp(self):\n        super(TestBloomFilter, self).setUp()\n        self.bf = BloomFilter(self.n)\n\n    def test_bloomfilter(self):\n        keys = ('charlie', 'huey', 'mickey', 'zaizee', 'nuggie', 'foo', 'bar',\n                'baz')\n        self.bf.add(*keys)\n        for key in keys:\n            self.assertTrue(key in self.bf)\n\n        for key in keys:\n            self.assertFalse(key + '-x' in self.bf)\n            self.assertFalse(key + '-y' in self.bf)\n            self.assertFalse(key + ' ' in self.bf)\n\n    def test_bloomfilter_buffer(self):\n        self.assertEqual(len(self.bf), self.n)\n\n        # Buffer is all zeroes when uninitialized.\n        buf = self.bf.to_buffer()\n        self.assertEqual(len(buf), self.n)\n        self.assertEqual(buf, b'\\x00' * self.n)\n\n        keys = ('alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta')\n        self.bf.add(*keys)\n\n        for key in keys:\n            self.assertTrue(key in self.bf)\n            self.assertFalse(key + '-x' in self.bf)\n\n        # Convert to buffer and then populate a 2nd bloom-filter.\n        buf = self.bf.to_buffer()\n        new_bf = BloomFilter.from_buffer(buf)\n        for key in keys:\n            self.assertTrue(key in new_bf)\n            self.assertFalse(key + '-x' in new_bf)\n\n        # Ensure that the two underlying bloom-filter buffers are equal.\n        self.assertEqual(len(new_bf), self.n)\n        new_buf = new_bf.to_buffer()\n        self.assertEqual(buf, new_buf)\n\n    def test_bloomfilter_functions(self):\n        bf = BloomFilter()\n        for i in range(1000):\n            bf.add('k%04d' % i)\n\n        buf = bf.to_buffer()\n        for i in range(1000):\n            self.assertTrue(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        for i in range(1000, 3000):\n            self.assertFalse(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        # Add 1000-2000 now and verify the bloom filter is updated.\n        for i in range(1000, 2000):\n            buf = peewee_bloomfilter_add('k%04d' % i, buf)\n        for i in range(2000):\n            self.assertTrue(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        # These still are not present.\n        for i in range(2000, 4000):\n            self.assertFalse(peewee_bloomfilter_contains('k%04d' % i, buf))"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 436,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilter.setUp",
      "span": [
        436,
        438
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def setUp(self):\n        super(TestBloomFilter, self).setUp()\n        self.bf = BloomFilter(self.n)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 440,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilter.test_bloomfilter",
      "span": [
        440,
        450
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def test_bloomfilter(self):\n        keys = ('charlie', 'huey', 'mickey', 'zaizee', 'nuggie', 'foo', 'bar',\n                'baz')\n        self.bf.add(*keys)\n        for key in keys:\n            self.assertTrue(key in self.bf)\n\n        for key in keys:\n            self.assertFalse(key + '-x' in self.bf)\n            self.assertFalse(key + '-y' in self.bf)\n            self.assertFalse(key + ' ' in self.bf)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 452,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilter.test_bloomfilter_buffer",
      "span": [
        452,
        477
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def test_bloomfilter_buffer(self):\n        self.assertEqual(len(self.bf), self.n)\n\n        # Buffer is all zeroes when uninitialized.\n        buf = self.bf.to_buffer()\n        self.assertEqual(len(buf), self.n)\n        self.assertEqual(buf, b'\\x00' * self.n)\n\n        keys = ('alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta')\n        self.bf.add(*keys)\n\n        for key in keys:\n            self.assertTrue(key in self.bf)\n            self.assertFalse(key + '-x' in self.bf)\n\n        # Convert to buffer and then populate a 2nd bloom-filter.\n        buf = self.bf.to_buffer()\n        new_bf = BloomFilter.from_buffer(buf)\n        for key in keys:\n            self.assertTrue(key in new_bf)\n            self.assertFalse(key + '-x' in new_bf)\n\n        # Ensure that the two underlying bloom-filter buffers are equal.\n        self.assertEqual(len(new_bf), self.n)\n        new_buf = new_bf.to_buffer()\n        self.assertEqual(buf, new_buf)"
    },
    {
      "path": "tests/csqlite_ext.py",
      "version": "old",
      "line": 479,
      "kind": "function",
      "qualname": "tests.csqlite_ext.TestBloomFilter.test_bloomfilter_functions",
      "span": [
        479,
        499
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "    def test_bloomfilter_functions(self):\n        bf = BloomFilter()\n        for i in range(1000):\n            bf.add('k%04d' % i)\n\n        buf = bf.to_buffer()\n        for i in range(1000):\n            self.assertTrue(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        for i in range(1000, 3000):\n            self.assertFalse(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        # Add 1000-2000 now and verify the bloom filter is updated.\n        for i in range(1000, 2000):\n            buf = peewee_bloomfilter_add('k%04d' % i, buf)\n        for i in range(2000):\n            self.assertTrue(peewee_bloomfilter_contains('k%04d' % i, buf))\n\n        # These still are not present.\n        for i in range(2000, 4000):\n            self.assertFalse(peewee_bloomfilter_contains('k%04d' % i, buf))"
    }
  ],
  "generated_at": "2026-02-11T10:56:45"
}