{
  "commit": "ab3157ce",
  "parent": "f5755cb50e817a401ea5f577d8639e7024401a9e",
  "repo": "D:\\locbench\\peewee",
  "num_files_in_diff": 1,
  "num_py_files_in_diff": 1,
  "num_seeds": 2,
  "seeds": [
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 27,
      "kind": "module",
      "qualname": "playhouse.cysqlite_ext",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "playhouse/cysqlite_ext.py",
      "version": "new",
      "line": 205,
      "kind": "class",
      "qualname": "playhouse.cysqlite_ext.CySqliteDatabase",
      "span": [
        55,
        236
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class CySqliteDatabase(SqliteDatabase):\n    def __init__(self, database, rank_functions=True, regexp_function=False,\n                 *args, **kwargs):\n        super(CySqliteDatabase, self).__init__(database, *args, **kwargs)\n\n        self._commit_hook = None\n        self._rollback_hook = None\n        self._update_hook = None\n        self._authorizer = None\n        self._trace = None\n        self._progress = None\n\n        if rank_functions:\n            self.register_function(cysqlite.rank_bm25, 'fts_bm25')\n            self.register_function(cysqlite.rank_lucene, 'fts_lucene')\n            self.register_function(rank, 'fts_rank')\n\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)\n\n    def _connect(self):\n        if cysqlite is None:\n            raise ImproperlyConfigured('cysqlite is not installed.')\n        conn = cysqlite.Connection(self.database, timeout=self._timeout,\n                                   extensions=True, **self.connect_params)\n        try:\n            self._add_conn_hooks(conn)\n        except Exception:\n            conn.close()\n            raise\n        return conn\n\n    def _add_conn_hooks(self, conn):\n        if self._commit_hook is not None:\n            conn.commit_hook(self._commit_hook)\n        if self._rollback_hook is not None:\n            conn.rollback_hook(self._rollback_hook)\n        if self._update_hook is not None:\n            conn.update_hook(self._update_hook)\n        if self._authorizer is not None:\n            conn.authorizer(self._authorizer)\n        if self._trace is not None:\n            conn.trace(*self._trace)\n        if self._progress is not None:\n            conn.progress(*self._progress)\n        super(CySqliteDatabase, self)._add_conn_hooks(conn)\n\n    def _set_pragmas(self, conn):\n        for pragma, value in self._pragmas:\n            conn.pragma(pragma, value)\n\n    def _attach_databases(self, conn):\n        for name, db in self._attached.items():\n            conn.attach(db, name)\n\n    def _load_aggregates(self, conn):\n        for name, (klass, num_params) in self._aggregates.items():\n            conn.create_aggregate(klass, name, num_params)\n\n    def _load_collations(self, conn):\n        for name, fn in self._collations.items():\n            conn.create_collation(fn, name)\n\n    def _load_functions(self, conn):\n        for name, (fn, num_params, deterministic) in self._functions.items():\n            conn.create_function(fn, name, num_params, deterministic)\n\n    def _load_window_functions(self, conn):\n        for name, (klass, num_params) in self._window_functions.items():\n            conn.create_window_function(klass, name, num_params)\n\n    def on_commit(self, fn):\n        self._commit_hook = fn\n        if not self.is_closed():\n            conn.commit_hook(fn)\n        return fn\n\n    def on_rollback(self, fn):\n        self._rollback_hook = fn\n        if not self.is_closed():\n            conn.rollback_hook(fn)\n        return fn\n\n    def on_update(self, fn):\n        self._update_hook = fn\n        if not self.is_closed():\n            conn.update_hook(fn)\n        return fn\n\n    def authorizer(self, fn):\n        self._authorizer = fn\n        if not self.is_closed():\n            conn.authorizer(fn)\n        return fn\n\n    def trace(self, fn, mask=2):\n        if fn is None:\n            self._trace = None\n        else:\n            self._trace = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._trace\n            conn.authorizer(*args)\n        return fn\n\n    def progress(self, fn, n=1):\n        if fn is None:\n            self._progress = None\n        else:\n            self._progress = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._progress\n            conn.progress(*args)\n        return fn\n\n    def begin(self, lock_type='deferred'):\n        with __exception_wrapper__:\n            self.connection().begin(lock_type)\n\n    def commit(self):\n        with __exception_wrapper__:\n            self.connection().commit()\n\n    def rollback(self):\n        with __exception_wrapper__:\n            self.connection().rollback()\n\n    @property\n    def autocommit(self):\n        return self.connection().autocommit()\n\n    def backup(self, destination, pages=None, name=None, progress=None,\n               src_name=None):\n\n        if isinstance(destination, CySqliteDatabase):\n            conn = destination.connection()\n        elif isinstance(destination, cysqlite.Connection):\n            conn = destination\n        elif isinstance(destination, (str, Path)):\n            return self.backup_to_file(str(destination), pages, name,\n                                       progress, src_name)\n\n        return self.connection().backup(conn, pages, name, progress, src_name)\n\n    def backup_to_file(self, filename, pages=None, name=None, progress=None,\n                       src_name=None):\n        return self.connection().backup_to_file(filename, pages, name,\n                                                progress, src_name)\n\n    # Status properties.\n    if cysqlite is not None:\n        memory_used = __status__(cysqlite.C_SQLITE_STATUS_MEMORY_USED)\n        malloc_size = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_SIZE, True)\n        malloc_count = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_COUNT)\n        pagecache_used = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_USED)\n        pagecache_overflow = __status__(\n            cysqlite.C_SQLITE_STATUS_PAGECACHE_OVERFLOW)\n        pagecache_size = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_SIZE, True)\n        scratch_used = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_USED)\n        scratch_overflow = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_OVERFLOW)\n        scratch_size = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_SIZE, True)\n\n        # Connection status properties.\n        lookaside_used = __dbstatus__(cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_USED)\n        lookaside_hit = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_HIT, True)\n        lookaside_miss = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE, True)\n        lookaside_miss_full = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL, True)\n        cache_used = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_CACHE_USED, False, True)\n        schema_used = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_SCHEMA_USED, False, True)\n        statement_used = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_STMT_USED, False, True)\n        cache_hit = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_CACHE_HIT, False, True)\n        cache_miss = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_CACHE_MISS, False, True)\n        cache_write = __dbstatus__(\n            cysqlite.C_SQLITE_DBSTATUS_CACHE_WRITE, False, True)",
      "old_code": "class CySqliteDatabase(SqliteDatabase):\n    def __init__(self, database, rank_functions=True, regexp_function=False,\n                 *args, **kwargs):\n        super(CySqliteDatabase, self).__init__(database, *args, **kwargs)\n\n        self._commit_hook = None\n        self._rollback_hook = None\n        self._update_hook = None\n        self._authorizer = None\n        self._trace = None\n        self._progress = None\n\n        if rank_functions:\n            self.register_function(cysqlite.rank_bm25, 'fts_bm25')\n            self.register_function(cysqlite.rank_lucene, 'fts_lucene')\n            self.register_function(rank, 'fts_rank')\n\n        if regexp_function:\n            self.register_function(_sqlite_regexp, 'regexp', 2)\n\n    def _connect(self):\n        if cysqlite is None:\n            raise ImproperlyConfigured('cysqlite is not installed.')\n        conn = cysqlite.Connection(self.database, timeout=self._timeout,\n                                   extensions=True, **self.connect_params)\n        try:\n            self._add_conn_hooks(conn)\n        except Exception:\n            conn.close()\n            raise\n        return conn\n\n    def _add_conn_hooks(self, conn):\n        if self._commit_hook is not None:\n            conn.commit_hook(self._commit_hook)\n        if self._rollback_hook is not None:\n            conn.rollback_hook(self._rollback_hook)\n        if self._update_hook is not None:\n            conn.update_hook(self._update_hook)\n        if self._authorizer is not None:\n            conn.authorizer(self._authorizer)\n        if self._trace is not None:\n            conn.trace(*self._trace)\n        if self._progress is not None:\n            conn.progress(*self._progress)\n        super(CySqliteDatabase, self)._add_conn_hooks(conn)\n\n    def _set_pragmas(self, conn):\n        for pragma, value in self._pragmas:\n            conn.pragma(pragma, value)\n\n    def _attach_databases(self, conn):\n        for name, db in self._attached.items():\n            conn.attach(db, name)\n\n    def _load_aggregates(self, conn):\n        for name, (klass, num_params) in self._aggregates.items():\n            conn.create_aggregate(klass, name, num_params)\n\n    def _load_collations(self, conn):\n        for name, fn in self._collations.items():\n            conn.create_collation(fn, name)\n\n    def _load_functions(self, conn):\n        for name, (fn, num_params, deterministic) in self._functions.items():\n            conn.create_function(fn, name, num_params, deterministic)\n\n    def _load_window_functions(self, conn):\n        for name, (klass, num_params) in self._window_functions.items():\n            conn.create_window_function(klass, name, num_params)\n\n    def on_commit(self, fn):\n        self._commit_hook = fn\n        if not self.is_closed():\n            conn.commit_hook(fn)\n        return fn\n\n    def on_rollback(self, fn):\n        self._rollback_hook = fn\n        if not self.is_closed():\n            conn.rollback_hook(fn)\n        return fn\n\n    def on_update(self, fn):\n        self._update_hook = fn\n        if not self.is_closed():\n            conn.update_hook(fn)\n        return fn\n\n    def authorizer(self, fn):\n        self._authorizer = fn\n        if not self.is_closed():\n            conn.authorizer(fn)\n        return fn\n\n    def trace(self, fn, mask=2):\n        if fn is None:\n            self._trace = None\n        else:\n            self._trace = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._trace\n            conn.authorizer(*args)\n        return fn\n\n    def progress(self, fn, n=1):\n        if fn is None:\n            self._progress = None\n        else:\n            self._progress = (fn, mask)\n        if not self.is_closed():\n            args = (None,) if fn is None else self._progress\n            conn.progress(*args)\n        return fn\n\n    def begin(self, lock_type='deferred'):\n        with __exception_wrapper__:\n            self.connection().begin(lock_type)\n\n    def commit(self):\n        with __exception_wrapper__:\n            self.connection().commit()\n\n    def rollback(self):\n        with __exception_wrapper__:\n            self.connection().rollback()\n\n    @property\n    def autocommit(self):\n        return self.connection().autocommit()\n\n    def backup(self, destination, pages=None, name=None, progress=None,\n               src_name=None):\n\n        if isinstance(destination, CySqliteDatabase):\n            conn = destination.connection()\n        elif isinstance(destination, cysqlite.Connection):\n            conn = destination\n        elif isinstance(destination, (str, Path)):\n            return self.backup_to_file(str(destination), pages, name,\n                                       progress, src_name)\n\n        return self.connection().backup(conn, pages, name, progress, src_name)\n\n    def backup_to_file(self, filename, pages=None, name=None, progress=None,\n                       src_name=None):\n        return self.connection().backup_to_file(filename, pages, name,\n                                                progress, src_name)\n\n    # Status properties.\n    memory_used = __status__(cysqlite.C_SQLITE_STATUS_MEMORY_USED)\n    malloc_size = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_SIZE, True)\n    malloc_count = __status__(cysqlite.C_SQLITE_STATUS_MALLOC_COUNT)\n    pagecache_used = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_USED)\n    pagecache_overflow = __status__(\n        cysqlite.C_SQLITE_STATUS_PAGECACHE_OVERFLOW)\n    pagecache_size = __status__(cysqlite.C_SQLITE_STATUS_PAGECACHE_SIZE, True)\n    scratch_used = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_USED)\n    scratch_overflow = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_OVERFLOW)\n    scratch_size = __status__(cysqlite.C_SQLITE_STATUS_SCRATCH_SIZE, True)\n\n    # Connection status properties.\n    lookaside_used = __dbstatus__(cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_USED)\n    lookaside_hit = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_HIT, True)\n    lookaside_miss = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE, True)\n    lookaside_miss_full = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL, True)\n    cache_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_USED, False, True)\n    schema_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_SCHEMA_USED, False, True)\n    statement_used = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_STMT_USED, False, True)\n    cache_hit = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_HIT, False, True)\n    cache_miss = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_MISS, False, True)\n    cache_write = __dbstatus__(\n        cysqlite.C_SQLITE_DBSTATUS_CACHE_WRITE, False, True)"
    }
  ],
  "generated_at": "2026-02-11T10:52:46"
}