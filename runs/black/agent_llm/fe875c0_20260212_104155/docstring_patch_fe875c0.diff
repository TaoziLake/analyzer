--- a/src/black/__init__.py
+++ b/src/black/__init__.py
@@ -837,12 +837,25 @@
     *,
     lines: Collection[tuple[int, int]] = (),
 ) -> None:
-    """
-    Reformat and print out `content` without spawning child processes.
+    """Reformat and print out `content` without spawning child processes.
     Similar to `reformat_one`, but for string content.
 
-    `fast`, `write_back`, and `mode` options are passed to
-    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
+    Args:
+        content: The code string to be reformatted.
+        fast: If True, skip temporary file writes for faster execution.
+        write_back: How to handle writing reformatted code (NO, YES, DIFF).
+        mode: Configuration object controlling formatting behavior.
+        report: Statistics tracker for formatting results.
+        lines: Collection of (start, end) line ranges to reformat (default: all lines).
+
+    Returns:
+        None. Output is written to stdout and/or captured in the report.
+
+    Changelog:
+        fe875c0: Updates to `format_stdin_to_stdout` now propagate to this function.
+        Changes in line processing behavior or return value semantics from the upstream
+        function may affect which portions of code get reformatted and whether changes
+        are reported through the `report` object.
     """
     path = Path("<string>")
     try:
@@ -873,8 +886,23 @@
 ) -> None:
     """Reformat a single file under `src` without spawning child processes.
 
-    `fast`, `write_back`, and `mode` options are passed to
-    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
+    Args:
+        src: Path to the file to reformat. Use "-" for stdin.
+        fast: If True, skip some checks for faster formatting.
+        write_back: How to handle writing reformatted code (OVERWRITE, DIFF, etc).
+        mode: Configuration object controlling formatting behavior.
+        report: Report object to track formatting results.
+        lines: Collection of (start, end) line numbers to reformat.
+        no_cache: If True, skip cache checks for this file.
+
+    Returns:
+        None
+
+    Raises:
+        Exception: Any error during file processing is caught and reported via the `report` object.
+
+    Changelog:
+        fe875c0: Preserves CR-only line endings from input files when writing reformatted output through format_file_in_place. This may change line terminator style in reformatted files depending on input content and Mode configuration, potentially affecting diff outputs and encoding behavior.
     """
     try:
         changed = Changed.NO
@@ -934,8 +962,28 @@
     """Format file under `src` path. Return True if changed.
 
     If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted
-    code to the file.
-    `mode` and `fast` options are passed to :func:`format_file_contents`.
+    code to the file. `mode` and `fast` options are passed to both :func:`decode_bytes` (for decoding) and :func:`format_file_contents` (for formatting).
+
+    Args:
+        src: Path to the file to format
+        fast: If True, skip some validation steps
+        mode: Configuration object for formatting and decoding
+        write_back: How to handle output (NO, DIFF, COLOR_DIFF, YES)
+        lock: Optional lock for multiprocessing
+        lines: Specific line ranges to format (1-based inclusive)
+
+    Returns:
+        True if file was modified, False otherwise
+
+    Raises:
+        ValueError: If file is an invalid Jupyter notebook
+
+    Changelog:
+        fe875c0: Updated to use decode_bytes with CR-only newline support and encoding overrides.
+        The function now preserves CR-only line endings from input files when writing reformatted output.
+        Encoding detection can now be overridden via Mode configuration (though not directly exposed in this function's parameters).
+        Diff output and file writing behavior now correctly handles standalone CR line terminators.
+    )
     """
     if src.suffix == ".pyi":
         mode = replace(mode, is_pyi=True)
@@ -1000,11 +1048,25 @@
 ) -> bool:
     """Format file on stdin. Return True if changed.
 
-    If content is None, it's read from sys.stdin.
-
-    If `write_back` is YES, write reformatted code back to stdout. If it is DIFF,
-    write a diff to stdout. The `mode` argument is passed to
-    :func:`format_file_contents`.
+    Args:
+        fast: If True, skip some checks for faster formatting.
+        content: Optional string content to format. If None, read from stdin.
+        write_back: Write mode for output (NO, YES, DIFF, COLOR_DIFF).
+        mode: Configuration object for formatting.
+        lines: Collection of line ranges to format.
+
+    Returns:
+        True if content was changed, False otherwise.
+
+    Raises:
+        NothingChanged: When no changes were made during formatting.
+
+    Changelog:
+        fe875c0: Updated newline handling from decode_bytes to support CR-only line endings.
+        The function now preserves CR-only newlines from input when writing output back
+        (previously only LF and CRLF were handled). Encoding detection from stdin is now
+        more robust, though encoding overrides are not exposed through this function's API.
+    )
     """
     then = datetime.now(timezone.utc)
 
@@ -1049,11 +1111,21 @@
     mode: Mode,
     lines: Collection[tuple[int, int]] = (),
 ) -> None:
-    """Perform stability and equivalence checks.
-
-    Raise AssertionError if source and destination contents are not
-    equivalent, or if a second pass of the formatter would format the
-    content differently.
+    """Perform stability and equivalence checks between source and destination contents.
+
+    Raise AssertionError if source and destination contents are not equivalent, or if a second formatting pass would produce different output. The stability check now enforces UTF-8 encoding during reformatting regardless of source file encoding declarations, which may reveal previously hidden formatting inconsistencies.
+
+    Args:
+        src_contents: Original source code string
+        dst_contents: Reformatted source code string
+        mode: Mode object controlling formatting behavior
+        lines: Optional collection of line number pairs to limit formatting
+
+    Raises:
+        AssertionError: When contents differ or stability check fails
+
+    Changelog:
+        fe875c0: Stability checks now enforce UTF-8 decoding during reformatting, potentially causing new assertion failures for non-UTF-8 encoded files. The second formatting pass will use UTF-8 regardless of source file encoding declarations, which may expose hidden formatting inconsistencies or create false positives in stability verification.
     """
     assert_equivalent(src_contents, dst_contents)
     assert_stable(src_contents, dst_contents, mode=mode, lines=lines)
@@ -1220,6 +1292,19 @@
 ) -> str:
     # Use the encoding overwrite since the src_contents may contain a different
     # magic encoding comment than utf-8
+    """Format a string of Python source code once according to the specified mode.
+
+    Args:
+        src_contents: The source code to format as a string.
+        mode: Configuration object controlling formatting behavior.
+        lines: Optional collection of line ranges to leave unchanged.
+
+    Returns:
+        The formatted source code as a string.
+
+    Changelog:
+        fe875c0: Added encoding_overwrite="utf-8" parameter to decode_bytes call to enforce UTF-8 decoding regardless of source file encoding declarations. This ensures consistent behavior even when source files contain non-UTF-8 encoding comments.
+    """
     normalized_contents, _, newline_type = decode_bytes(
         src_contents.encode("utf-8"), mode, encoding_overwrite="utf-8"
     )
@@ -1288,6 +1373,24 @@
 
     Use the keyword only encoding_overwrite argument if the bytes are encoded
     differently to their possible encoding magic comment.
+
+    Args:
+        src: bytes to decode
+        mode: black.Mode instance controlling formatting behavior
+        encoding_overwrite: Optional string specifying a specific encoding to use
+            instead of the detected encoding. Defaults to None.
+
+    Returns:
+        A tuple containing:
+        - Decoded file content as string
+        - Actual encoding used
+        - Detected newline character(s) (CRLF, LF, or CR)
+
+    Changelog:
+        fe875c0: Added keyword-only encoding_overwrite parameter to override detected
+        encoding. Updated newline detection to support CR-only line endings.
+        Modified encoding logic to prioritize encoding_overwrite when provided.
+        Added explicit CR handling in newline detection.
     """
     srcbuf = io.BytesIO(src)
 
@@ -1602,7 +1705,23 @@
 def assert_stable(
     src: str, dst: str, mode: Mode, *, lines: Collection[tuple[int, int]] = ()
 ) -> None:
-    """Raise AssertionError if `dst` reformats differently the second time."""
+    """Raise AssertionError if `dst` reformats differently the second time.
+
+    Args:
+        src: Original source code string
+        dst: Formatted source code string to verify
+        mode: Mode object controlling formatting behavior
+        lines: Optional collection of line ranges (start, end) to format. Currently disables stability check due to diff algorithm limitations.
+
+    Returns:
+        None
+
+    Raises:
+        AssertionError: If reformatting `dst` produces different output, indicating unstable formatting behavior
+
+    Changelog:
+        fe875c0: Upstream UTF-8 decoding enforcement in _format_str_once may affect stability checks when processing non-UTF-8 encoded sources. The second formatting pass now consistently uses UTF-8 regardless of source encoding declarations, which could expose new formatting inconsistencies or trigger false positives in stability verification.
+    """
     if lines:
         # Formatting specified lines requires `adjusted_lines` to map original lines
         # to the formatted lines before re-formatting the previously formatted result.
