--- a/scripts/release_tests.py
+++ b/scripts/release_tests.py
@@ -14,10 +14,34 @@
     """Used to mock the date to test generating next calver function"""
 
     def today(*args: Any, **kwargs: Any) -> "FakeDateTime":  # noqa: B902
+        """FakeDateTime.today returns a new FakeDateTime instance.
+
+        Args:
+            *args: Variable length argument list (unused).
+            **kwargs: Arbitrary keyword arguments (unused).
+
+        Returns:
+            FakeDateTime: A new instance of FakeDateTime.
+
+        Changelog:
+            58c5ac8: Added B902 noqa directive to suppress flake8 error regarding type annotations for *args/**kwargs in the today() method. No functional changes to parameters or return value.
+        """
         return FakeDateTime()
 
     # Add leading 0 on purpose to ensure we remove it
     def strftime(*args: Any, **kwargs: Any) -> str:  # noqa: B902
+        """FakeDateTime.strftime returns a fixed string "69.01" regardless of input parameters.
+
+        Args:
+            *args: Variable length argument list (ignored).
+            **kwargs: Arbitrary keyword arguments (ignored).
+
+        Returns:
+            str: The constant string "69.01".
+
+        Changelog:
+            58c5ac8: Added B902 warning code to noqa comment to suppress specific linting errors related to variadic arguments.
+        """
         return "69.01"
 
 

--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -1117,9 +1117,25 @@
 def _prefer_split_rhs_oop_over_rhs(
     rhs_oop: RHSResult, rhs: RHSResult, mode: Mode
 ) -> bool:
-    """
-    Returns whether we should prefer the result from a split omitting optional parens
-    (rhs_oop) over the original (rhs).
+    """def _prefer_split_rhs_oop_over_rhs(
+        rhs_oop: RHSResult, rhs: RHSResult, mode: Mode
+    ) -> bool:
+        """
+        Returns whether we should prefer the result from a split omitting optional parens
+        (rhs_oop) over the original (rhs).
+        
+        Args:
+            rhs_oop: RHSResult from split omitting optional parens
+            rhs: Original RHSResult with optional parens
+            mode: Black configuration mode object
+        
+        Returns:
+            True if rhs_oop should be preferred over rhs, False otherwise
+        
+        Changelog:
+            58c5ac8: No functional changes to this function. The upstream change to
+            is_line_short_enough() was purely stylistic (removed complexity warning),
+            with no impact on parameters, return values, or behavior observed by this caller.
     """
     # contains unsplittable type ignore
     if (
@@ -1477,11 +1493,21 @@
 ) -> None:
     """Make existing optional parentheses invisible or create new ones.
 
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    `parens_after` is a set of string leaf values immediately after which parens should be put.
+
+    Standardizes on visible parentheses for single-element tuples, and keeps existing visible parentheses for other tuples and generator expressions.
+
+    Args:
+        node (Node): The node to process
+        parens_after (set[str]): Set of string values after which parentheses should be added
+        mode (Mode): Formatting mode
+        features (Collection[Feature]): Enabled features
+
+    Raises:
+        None
+
+    Changelog:
+        58c5ac8: Removed noqa: C901 comment from function definition line. No functional changes to parameters, logic, or return values. The change only affects linting by removing a line-length ignore directive.
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if pc.value in FMT_OFF:
@@ -2002,6 +2028,24 @@
     *,
     line_str: str = "",
 ) -> list[Line]:
+    """Runs a transformer on a line, applying transformations and handling special cases like recursion and optional parentheses.
+
+    Args:
+        line: The input Line object to transform.
+        transform: Transformer function to apply.
+        mode: Formatting mode configuration.
+        features: Collection of active formatting features.
+        line_str: Optional precomputed string representation of the line.
+
+    Returns:
+        List of transformed Line objects after applying all transformations.
+
+    Raises:
+        CannotTransform: If the transformer returns an unchanged result.
+
+    Changelog:
+        58c5ac8: Updated upstream dependency src.black.lines.is_line_short_enough (removed complexity warning). No functional impact on this function - behavior, parameters, and return values remain unchanged. The change only affects internal complexity analysis in the upstream function.
+    """
     if not line_str:
         line_str = line_to_string(line)
     result: list[Line] = []

--- a/src/black/lines.py
+++ b/src/black/lines.py
@@ -55,12 +55,19 @@
     ) -> None:
         """Add a new `leaf` to the end of the line.
 
-        Unless `preformatted` is True, the `leaf` will receive a new consistent
-        whitespace prefix and metadata applied by :class:`BracketTracker`.
-        Trailing commas are maybe removed, unpacked for loop variables are
-        demoted from being delimiters.
-
-        Inline comments are put aside.
+        Args:
+            leaf: The Leaf node to append to the line.
+            preformatted: If True, preserves the leaf's existing prefix. If False, applies new whitespace formatting.
+            track_bracket: If True, tracks bracket context for the appended leaf.
+
+        Returns:
+            None
+
+        Raises:
+            No exceptions are raised under normal operation.
+
+        Changelog:
+            58c5ac8: Upstream cleanup of `whitespace()` function (no behavior change). This function's behavior remains identical, as the called whitespace utility retained its functional interface despite improved code quality compliance. No parameter or return value impacts observed.
         """
         has_value = (
             leaf.type in BRACKETS
@@ -94,8 +101,18 @@
     def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
         """Like :func:`append()` but disallow invalid standalone comment structure.
 
-        Raises ValueError when any `leaf` is appended after a standalone comment
-        or when a standalone comment is not the first leaf on the line.
+        Args:
+            leaf: Leaf node to append to the line.
+            preformatted: If True, skips whitespace formatting for this leaf.
+
+        Raises:
+            ValueError: When appending to standalone comments, or when adding standalone
+                comments to a non-empty line.
+
+        Changelog:
+            58c5ac8: No behavioral changes. Upstream modification to Line.append only removed
+            a complexity ignore directive without altering its functionality. This function's
+            behavior, parameters, and return values remain unchanged.
         """
         if (
             self.bracket_tracker.depth == 0
@@ -550,6 +567,18 @@
 
         This is for separating `def`, `async def` and `class` with extra empty
         lines (two on module-level).
+
+        Args:
+            current_line (Line): The current line being processed to determine empty line spacing.
+
+        Returns:
+            LinesBlock: A LinesBlock instance containing calculated spacing (before/after),
+            form feed status, and references to previous blocks/lines.
+
+        Changelog:
+            58c5ac8: Upstream addition of _maybe_empty_lines docstring improves internal clarity but
+            does not affect this function's behavior. No changes to parameters, return values, or
+            spacing logic observed by callers.
         """
         form_feed = (
             current_line.depth == 0
@@ -617,6 +646,19 @@
         return True
 
     def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:
+        """Determine the number of empty lines to insert before and after a line based on context.
+
+        Args:
+            current_line (Line): The current line being processed
+
+        Returns:
+            tuple[int, int]: A pair (before, after) where:
+                - before: Number of empty lines to insert before the line (0-2)
+                - after: Number of empty lines to insert after the line (typically 0)
+
+        Changelog:
+            58c5ac8: Added docstring to document function behavior, parameters, and return values. No functional changes were made to the code.
+        """
         max_allowed = 1
         if current_line.depth == 0:
             max_allowed = 1 if self.mode.is_pyi else 2
@@ -712,6 +754,22 @@
     def _maybe_empty_lines_for_class_or_def(
         self, current_line: Line, before: int, user_had_newline: bool
     ) -> tuple[int, int]:
+        """Function determining empty lines before a class or function definition based on context.
+
+        Args:
+            current_line: Line object representing the current line being processed
+            before: Integer count of lines before current line
+            user_had_newline: Boolean indicating if user originally included a newline
+
+        Returns:
+            Tuple of two integers representing (pre_newlines, post_newlines) to insert
+
+        Raises:
+            AssertionError: If previous_line is None (internal state error)
+
+        Changelog:
+            58c5ac8: Removed 'noqa: C901' complexity warning suppression. The function's logic remains unchanged, but will now trigger flake8 complexity checks. No impact on runtime behavior or return values.
+        """
         assert self.previous_line is not None
 
         if self.previous_line.is_decorator:
@@ -827,6 +885,22 @@
     For multiline strings, looks at the context around `line` to determine
     if it should be inlined or split up.
     Uses the provided `line_str` rendering, if any, otherwise computes a new one.
+
+    Args:
+        line: The Line object to check
+        mode: Mode object controlling formatting behavior
+        line_str: Optional precomputed string representation of the line
+
+    Returns:
+        bool: True if line is short enough, False otherwise
+
+    Raises:
+        No exceptions explicitly raised
+
+    Changelog:
+        58c5ac8: Removed `noqa: C901` complexity warning from function definition.
+        No functional changes - code logic and behavior remain identical.
+        This commit only modifies linting directives without affecting runtime behavior.
     """
     if not line_str:
         line_str = line_to_string(line)

--- a/src/black/nodes.py
+++ b/src/black/nodes.py
@@ -182,6 +182,19 @@
 
     `complex_subscript` signals whether the given leaf is part of a subscription
     which has non-trivial arguments, like arithmetic expressions or function calls.
+
+    Args:
+        leaf: Leaf node to determine whitespace for
+        complex_subscript: Whether the leaf is in a subscription with non-trivial arguments
+        mode: Formatting mode configuration
+
+    Returns:
+        str: Whitespace prefix (NO, SPACE, or DOUBLESPACE)
+
+    Changelog:
+        58c5ac8: Removed `# noqa: C901` complexity ignore directive from function definition.
+        Function logic remains unchanged, but this indicates improved code quality
+        compliance or updated linting configuration.
     """
     NO: Final[str] = ""
     SPACE: Final[str] = " "

--- a/src/black/parsing.py
+++ b/src/black/parsing.py
@@ -167,19 +167,62 @@
 
 
 def stringify_ast(node: ast.AST) -> Iterator[str]:
-    """Simple visitor generating strings to compare ASTs by content."""
+    """def stringify_ast(node: ast.AST) -> Iterator[str]:
+        """Simple visitor generating strings to compare ASTs by content.
+
+        Args:
+            node: AST node to be stringified.
+
+        Returns:
+            Iterator[str]: Strings representing the AST content for comparison.
+
+        Changelog:
+            58c5ac8: No functional changes. The upstream modification to _stringify_ast only removed a linting exception comment, preserving identical AST traversal logic and output. Callers observe no differences in behavior, parameters, or return values.
+        """
+        return _stringify_ast(node, [])
+    """
     return _stringify_ast(node, [])
 
 
 def _stringify_ast_with_new_parent(
     node: ast.AST, parent_stack: list[ast.AST], new_parent: ast.AST
 ) -> Iterator[str]:
+    """Stringify an AST node by temporarily appending a new parent to the parent stack.
+
+    Args:
+        node: The AST node to stringify.
+        parent_stack: Stack tracking parent nodes in the AST hierarchy.
+        new_parent: The new parent node to temporarily add to the stack.
+
+    Returns:
+        An iterator of strings representing the stringified AST node.
+
+    Changelog:
+        58c5ac8: No functional changes to this function. The upstream modification to
+        _stringify_ast only removed a linting exception comment and did not affect
+        AST traversal logic or stringification output. Parent stack handling remains
+        unchanged.
+    """
     parent_stack.append(new_parent)
     yield from _stringify_ast(node, parent_stack)
     parent_stack.pop()
 
 
 def _stringify_ast(node: ast.AST, parent_stack: list[ast.AST]) -> Iterator[str]:
+    """_src.black.parsing._stringify_ast(node: ast.AST, parent_stack: list[ast.AST]) -> Iterator[str]_
+
+    Converts an AST node to its string representation with indentation based on parent hierarchy.
+
+    Args:
+        node: AST node to convert to string representation.
+        parent_stack: Stack of ancestor nodes used for indentation and context tracking.
+
+    Returns:
+        Iterator yielding formatted lines of the AST node's string representation.
+
+    Changelog:
+        58c5ac8: Removed noqa: F402 lint suppression from sorted(node._fields) line. This was a cleanup of a stale type-checking suppression comment while maintaining identical functionality for AST traversal and stringification.
+    """
     if (
         isinstance(node, ast.Constant)
         and isinstance(node.value, str)

--- a/scripts/release.py
+++ b/scripts/release.py
@@ -166,7 +166,19 @@
         return sorted(get_git_tags(), key=lambda k: tuple_calver(k))[-1]
 
     def get_next_version(self) -> str:
-        """Workout the year and month + version number we need to move to"""
+        """def get_next_version(self) -> str:
+            """Workout the year and month + version number we need to move to.
+
+            Returns:
+                str: Version string in format "YY.MM.N" where YY=year, MM=month without leading zero, N=incremented version number
+
+            Raises:
+                IndexError: If git tag parsing fails due to unexpected format
+                ValueError: If version number conversion to integer fails
+
+            Changelog:
+                58c5ac8: Upstream change to FakeDateTime.strftime only affects test code linting - no runtime impact on version calculation. This function continues to use standard datetime.strftime with no behavioral changes.
+        """
         base_calver = datetime.today().strftime("%y.%m")
         calver_parts = base_calver.split(".")
         base_calver = f"{calver_parts[0]}.{int(calver_parts[1])}"  # Remove leading 0
