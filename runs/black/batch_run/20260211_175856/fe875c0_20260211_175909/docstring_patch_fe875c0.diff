--- a/src/black/__init__.py
+++ b/src/black/__init__.py
@@ -837,12 +837,15 @@
     *,
     lines: Collection[tuple[int, int]] = (),
 ) -> None:
-    """
-    Reformat and print out `content` without spawning child processes.
-    Similar to `reformat_one`, but for string content.
-
-    `fast`, `write_back`, and `mode` options are passed to
-    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
+    """TODO: docstring
+
+    Args:
+        content:
+        fast:
+        write_back:
+        mode:
+        report:
+        lines:
     """
     path = Path("<string>")
     try:
@@ -871,10 +874,16 @@
     lines: Collection[tuple[int, int]] = (),
     no_cache: bool = False,
 ) -> None:
-    """Reformat a single file under `src` without spawning child processes.
-
-    `fast`, `write_back`, and `mode` options are passed to
-    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
+    """TODO: docstring
+
+    Args:
+        src:
+        fast:
+        write_back:
+        mode:
+        report:
+        lines:
+        no_cache:
     """
     try:
         changed = Changed.NO
@@ -931,11 +940,15 @@
     *,
     lines: Collection[tuple[int, int]] = (),
 ) -> bool:
-    """Format file under `src` path. Return True if changed.
-
-    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted
-    code to the file.
-    `mode` and `fast` options are passed to :func:`format_file_contents`.
+    """TODO: docstring
+
+    Args:
+        src:
+        fast:
+        mode:
+        write_back:
+        lock:
+        lines:
     """
     if src.suffix == ".pyi":
         mode = replace(mode, is_pyi=True)
@@ -998,13 +1011,14 @@
     mode: Mode,
     lines: Collection[tuple[int, int]] = (),
 ) -> bool:
-    """Format file on stdin. Return True if changed.
-
-    If content is None, it's read from sys.stdin.
-
-    If `write_back` is YES, write reformatted code back to stdout. If it is DIFF,
-    write a diff to stdout. The `mode` argument is passed to
-    :func:`format_file_contents`.
+    """TODO: docstring
+
+    Args:
+        fast:
+        content:
+        write_back:
+        mode:
+        lines:
     """
     then = datetime.now(timezone.utc)
 
@@ -1049,11 +1063,13 @@
     mode: Mode,
     lines: Collection[tuple[int, int]] = (),
 ) -> None:
-    """Perform stability and equivalence checks.
-
-    Raise AssertionError if source and destination contents are not
-    equivalent, or if a second pass of the formatter would format the
-    content differently.
+    """TODO: docstring
+
+    Args:
+        src_contents:
+        dst_contents:
+        mode:
+        lines:
     """
     assert_equivalent(src_contents, dst_contents)
     assert_stable(src_contents, dst_contents, mode=mode, lines=lines)
@@ -1220,6 +1236,13 @@
 ) -> str:
     # Use the encoding overwrite since the src_contents may contain a different
     # magic encoding comment than utf-8
+    """TODO: docstring
+
+    Args:
+        src_contents:
+        mode:
+        lines:
+    """
     normalized_contents, _, newline_type = decode_bytes(
         src_contents.encode("utf-8"), mode, encoding_overwrite="utf-8"
     )
@@ -1281,13 +1304,12 @@
 def decode_bytes(
     src: bytes, mode: Mode, *, encoding_overwrite: str | None = None
 ) -> tuple[FileContent, Encoding, NewLine]:
-    """Return a tuple of (decoded_contents, encoding, newline).
-
-    `newline` is either CRLF, LF, or CR, but `decoded_contents` is decoded with
-    universal newlines (i.e. only contains LF).
-
-    Use the keyword only encoding_overwrite argument if the bytes are encoded
-    differently to their possible encoding magic comment.
+    """TODO: docstring
+
+    Args:
+        src:
+        mode:
+        encoding_overwrite:
     """
     srcbuf = io.BytesIO(src)
 
@@ -1602,7 +1624,14 @@
 def assert_stable(
     src: str, dst: str, mode: Mode, *, lines: Collection[tuple[int, int]] = ()
 ) -> None:
-    """Raise AssertionError if `dst` reformats differently the second time."""
+    """TODO: docstring
+
+    Args:
+        src:
+        dst:
+        mode:
+        lines:
+    """
     if lines:
         # Formatting specified lines requires `adjusted_lines` to map original lines
         # to the formatted lines before re-formatting the previously formatted result.
