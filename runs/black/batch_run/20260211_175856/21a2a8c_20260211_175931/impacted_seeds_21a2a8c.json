{
  "commit": "21a2a8c",
  "parent": "e3146cea4245fcee29d007cb45d9faaf63271586",
  "repo": "/Users/syhe/2026/black",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 9,
  "seeds": [
    {
      "path": "src/black/concurrency.py",
      "version": "new",
      "line": 162,
      "kind": "async_function",
      "qualname": "src.black.concurrency.schedule_formatting",
      "span": [
        131,
        210
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "async def schedule_formatting(\n    sources: set[Path],\n    fast: bool,\n    write_back: WriteBack,\n    mode: Mode,\n    report: Report,\n    loop: asyncio.AbstractEventLoop,\n    executor: Executor,\n    no_cache: bool = False,\n) -> None:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `write_back`, `fast`, and `mode` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    cache = None if no_cache else Cache.read(mode)\n    if cache is not None and write_back not in (\n        WriteBack.DIFF,\n        WriteBack.COLOR_DIFF,\n    ):\n        sources, cached = cache.filtered_cached(sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    manager = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        # For diff output, we need locks to ensure we don't interleave output\n        # from different processes.\n        manager = Manager()\n        lock = manager.Lock()\n\n    try:\n        tasks = {\n            asyncio.ensure_future(\n                loop.run_in_executor(\n                    executor, format_file_in_place, src, fast, mode, write_back, lock\n                )\n            ): src\n            for src in sorted(sources)\n        }\n        pending = tasks.keys()\n        try:\n            loop.add_signal_handler(signal.SIGINT, cancel, pending)\n            loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n        except NotImplementedError:\n            # There are no good alternatives for these on Windows.\n            pass\n        while pending:\n            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n            for task in done:\n                src = tasks.pop(task)\n                if task.cancelled():\n                    cancelled.append(task)\n                elif exc := task.exception():\n                    if report.verbose:\n                        traceback.print_exception(type(exc), exc, exc.__traceback__)\n                    report.failed(src, str(exc))\n                else:\n                    changed = Changed.YES if task.result() else Changed.NO\n                    # If the file was written back or was successfully checked as\n                    # well-formatted, store this information in the cache.\n                    if write_back is WriteBack.YES or (\n                        write_back is WriteBack.CHECK and changed is Changed.NO\n                    ):\n                        sources_to_cache.append(src)\n                    report.done(src, changed)\n        if cancelled:\n            await asyncio.gather(*cancelled, return_exceptions=True)\n        if sources_to_cache and not no_cache and cache is not None:\n            cache.write(sources_to_cache)\n    finally:\n        if manager is not None:\n            manager.shutdown()",
      "old_code": "async def schedule_formatting(\n    sources: set[Path],\n    fast: bool,\n    write_back: WriteBack,\n    mode: Mode,\n    report: Report,\n    loop: asyncio.AbstractEventLoop,\n    executor: Executor,\n    no_cache: bool = False,\n) -> None:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `write_back`, `fast`, and `mode` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    cache = None if no_cache else Cache.read(mode)\n    if cache is not None and write_back not in (\n        WriteBack.DIFF,\n        WriteBack.COLOR_DIFF,\n    ):\n        sources, cached = cache.filtered_cached(sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        # For diff output, we need locks to ensure we don't interleave output\n        # from different processes.\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        # There are no good alternatives for these on Windows.\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif exc := task.exception():\n                if report.verbose:\n                    traceback.print_exception(type(exc), exc, exc.__traceback__)\n                report.failed(src, str(exc))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                # If the file was written back or was successfully checked as\n                # well-formatted, store this information in the cache.\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache and not no_cache and cache is not None:\n        cache.write(sources_to_cache)"
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 1,
      "kind": "module",
      "qualname": "tests.test_concurrency_manager_shutdown",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 13,
      "kind": "class",
      "qualname": "tests.test_concurrency_manager_shutdown.FakeManager",
      "span": [
        13,
        23
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "class FakeManager:\n    shutdown_called: bool\n\n    def __init__(self) -> None:\n        self.shutdown_called = False\n\n    def Lock(self) -> object:\n        return object()\n\n    def shutdown(self) -> None:\n        self.shutdown_called = True",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 16,
      "kind": "function",
      "qualname": "tests.test_concurrency_manager_shutdown.FakeManager.__init__",
      "span": [
        16,
        17
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def __init__(self) -> None:\n        self.shutdown_called = False",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 19,
      "kind": "function",
      "qualname": "tests.test_concurrency_manager_shutdown.FakeManager.Lock",
      "span": [
        19,
        20
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def Lock(self) -> object:\n        return object()",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 22,
      "kind": "function",
      "qualname": "tests.test_concurrency_manager_shutdown.FakeManager.shutdown",
      "span": [
        22,
        23
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def shutdown(self) -> None:\n        self.shutdown_called = True",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 26,
      "kind": "function",
      "qualname": "tests.test_concurrency_manager_shutdown.test_manager_shutdown_called_for_diff",
      "span": [
        26,
        66
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def test_manager_shutdown_called_for_diff(monkeypatch: Any, tmp_path: Path) -> None:\n    \"\"\"\n    schedule_formatting() creates multiprocessing.Manager() for DIFF/COLOR_DIFF\n    and must shut it down deterministically.\n    \"\"\"\n    fake_manager = FakeManager()\n\n    monkeypatch.setattr(concurrency, \"Manager\", lambda: fake_manager)\n\n    def fake_format_file_in_place(\n        src: Path,\n        fast: bool,\n        mode: Mode,\n        write_back: WriteBack,\n        lock: Optional[object],\n    ) -> bool:\n        assert lock is not None\n        return False\n\n    monkeypatch.setattr(concurrency, \"format_file_in_place\", fake_format_file_in_place)\n\n    src = tmp_path / \"a.py\"\n    src.write_text(\"x=1\\n\", encoding=\"utf8\")\n\n    async def run() -> None:\n        loop = asyncio.get_running_loop()\n        with ThreadPoolExecutor(max_workers=1) as executor:\n            await concurrency.schedule_formatting(\n                sources={src},\n                fast=False,\n                write_back=WriteBack.DIFF,\n                mode=Mode(),\n                report=Report(),\n                loop=loop,\n                executor=executor,\n                no_cache=True,\n            )\n\n    asyncio.run(run())\n\n    assert fake_manager.shutdown_called is True",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 35,
      "kind": "function",
      "qualname": "tests.test_concurrency_manager_shutdown.test_manager_shutdown_called_for_diff.fake_format_file_in_place",
      "span": [
        35,
        43
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def fake_format_file_in_place(\n        src: Path,\n        fast: bool,\n        mode: Mode,\n        write_back: WriteBack,\n        lock: Optional[object],\n    ) -> bool:\n        assert lock is not None\n        return False",
      "old_code": null
    },
    {
      "path": "tests/test_concurrency_manager_shutdown.py",
      "version": "new",
      "line": 50,
      "kind": "async_function",
      "qualname": "tests.test_concurrency_manager_shutdown.test_manager_shutdown_called_for_diff.run",
      "span": [
        50,
        62
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    async def run() -> None:\n        loop = asyncio.get_running_loop()\n        with ThreadPoolExecutor(max_workers=1) as executor:\n            await concurrency.schedule_formatting(\n                sources={src},\n                fast=False,\n                write_back=WriteBack.DIFF,\n                mode=Mode(),\n                report=Report(),\n                loop=loop,\n                executor=executor,\n                no_cache=True,\n            )",
      "old_code": null
    }
  ],
  "generated_at": "2026-02-11T17:59:31"
}