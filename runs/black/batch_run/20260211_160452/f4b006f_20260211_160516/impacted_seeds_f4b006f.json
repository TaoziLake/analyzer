{
  "commit": "f4b006f",
  "parent": "115dbcf3f2593b88909faee31404b83d6dcc5ff7",
  "repo": "/Users/syhe/2026/black",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 2,
  "seeds": [
    {
      "path": "src/black/lines.py",
      "version": "new",
      "line": 951,
      "kind": "function",
      "qualname": "src.black.lines.can_omit_invisible_parens",
      "span": [
        939,
        1071
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def can_omit_invisible_parens(\n    rhs: RHSResult,\n    line_length: int,\n) -> bool:\n    \"\"\"Does `rhs.body` have a shape safe to reformat without optional parens around it?\n\n    Returns True for only a subset of potentially nice looking formattings but\n    the point is to not return false positives that end up producing lines that\n    are too long.\n    \"\"\"\n    line = rhs.body\n\n    # We can't omit parens if doing so would result in a type: ignore comment\n    # sharing a line with other comments, as that breaks type: ignore parsing.\n    # Check if the opening bracket (last leaf of head) has comments that would merge\n    # with comments from the first line of the body.\n    if rhs.head.leaves:\n        opening_bracket = rhs.head.leaves[-1]\n        head_comments = rhs.head.comments.get(id(opening_bracket), [])\n\n        # If there are comments on the opening bracket line, check if any would\n        # conflict with type: ignore comments in the body\n        if head_comments:\n            has_type_ignore_in_head = any(\n                is_type_ignore_comment(comment, mode=rhs.head.mode)\n                for comment in head_comments\n            )\n            has_other_comment_in_head = any(\n                not is_type_ignore_comment(comment, mode=rhs.head.mode)\n                for comment in head_comments\n            )\n\n            # Check for comments in the body that would potentially end up on the\n            # same line as the head comments when parens are removed\n            has_type_ignore_in_body = False\n            has_other_comment_in_body = False\n            for leaf in rhs.body.leaves:\n                for comment in rhs.body.comments.get(id(leaf), []):\n                    if is_type_ignore_comment(comment, mode=rhs.body.mode):\n                        has_type_ignore_in_body = True\n                    else:\n                        has_other_comment_in_body = True\n\n            # Preserve parens if we have both type: ignore and other comments that\n            # could end up on the same line\n            if (has_type_ignore_in_head and has_other_comment_in_body) or (\n                has_other_comment_in_head and has_type_ignore_in_body\n            ):\n                return False\n\n    # We need optional parens in order to split standalone comments to their own lines\n    # if there are no nested parens around the standalone comments\n    closing_bracket: Leaf | None = None\n    for leaf in reversed(line.leaves):\n        if closing_bracket and leaf is closing_bracket.opening_bracket:\n            closing_bracket = None\n        if leaf.type == STANDALONE_COMMENT and not closing_bracket:\n            return False\n        if (\n            not closing_bracket\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket in line.leaves\n            and leaf.value\n        ):\n            closing_bracket = leaf\n\n    bt = line.bracket_tracker\n    if not bt.delimiters:\n        # Without delimiters the optional parentheses are useless.\n        return True\n\n    max_priority = bt.max_delimiter_priority()\n    delimiter_count = bt.delimiter_count_with_priority(max_priority)\n    if delimiter_count > 1:\n        # With more than one delimiter of a kind the optional parentheses read better.\n        return False\n\n    if delimiter_count == 1:\n        if max_priority == COMMA_PRIORITY and rhs.head.is_with_or_async_with_stmt:\n            # For two context manager with statements, the optional parentheses read\n            # better. In this case, `rhs.body` is the context managers part of\n            # the with statement. `rhs.head` is the `with (` part on the previous\n            # line.\n            return False\n        # Otherwise it may also read better, but we don't do it today and requires\n        # careful considerations for all possible cases. See\n        # https://github.com/psf/black/issues/2156.\n\n    if max_priority == DOT_PRIORITY:\n        # A single stranded method call doesn't require optional parentheses.\n        return True\n\n    assert len(line.leaves) >= 2, \"Stranded delimiter\"\n\n    # With a single delimiter, omit if the expression starts or ends with\n    # a bracket.\n    first = line.leaves[0]\n    second = line.leaves[1]\n    if first.type in OPENING_BRACKETS and second.type not in CLOSING_BRACKETS:\n        if _can_omit_opening_paren(line, first=first, line_length=line_length):\n            return True\n\n        # Note: we are not returning False here because a line might have *both*\n        # a leading opening bracket and a trailing closing bracket.  If the\n        # opening bracket doesn't match our rule, maybe the closing will.\n\n    penultimate = line.leaves[-2]\n    last = line.leaves[-1]\n\n    if (\n        last.type == token.RPAR\n        or last.type == token.RBRACE\n        or (\n            # don't use indexing for omitting optional parentheses;\n            # it looks weird\n            last.type == token.RSQB\n            and last.parent\n            and last.parent.type != syms.trailer\n        )\n    ):\n        if penultimate.type in OPENING_BRACKETS:\n            # Empty brackets don't help.\n            return False\n\n        if is_multiline_string(first):\n            # Additional wrapping of a multiline string in this situation is\n            # unnecessary.\n            return True\n\n        if _can_omit_closing_paren(line, last=last, line_length=line_length):\n            return True\n\n    return False",
      "old_code": "def can_omit_invisible_parens(\n    rhs: RHSResult,\n    line_length: int,\n) -> bool:\n    \"\"\"Does `rhs.body` have a shape safe to reformat without optional parens around it?\n\n    Returns True for only a subset of potentially nice looking formattings but\n    the point is to not return false positives that end up producing lines that\n    are too long.\n    \"\"\"\n    line = rhs.body\n\n    # We need optional parens in order to split standalone comments to their own lines\n    # if there are no nested parens around the standalone comments\n    closing_bracket: Leaf | None = None\n    for leaf in reversed(line.leaves):\n        if closing_bracket and leaf is closing_bracket.opening_bracket:\n            closing_bracket = None\n        if leaf.type == STANDALONE_COMMENT and not closing_bracket:\n            return False\n        if (\n            not closing_bracket\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket in line.leaves\n            and leaf.value\n        ):\n            closing_bracket = leaf\n\n    bt = line.bracket_tracker\n    if not bt.delimiters:\n        # Without delimiters the optional parentheses are useless.\n        return True\n\n    max_priority = bt.max_delimiter_priority()\n    delimiter_count = bt.delimiter_count_with_priority(max_priority)\n    if delimiter_count > 1:\n        # With more than one delimiter of a kind the optional parentheses read better.\n        return False\n\n    if delimiter_count == 1:\n        if max_priority == COMMA_PRIORITY and rhs.head.is_with_or_async_with_stmt:\n            # For two context manager with statements, the optional parentheses read\n            # better. In this case, `rhs.body` is the context managers part of\n            # the with statement. `rhs.head` is the `with (` part on the previous\n            # line.\n            return False\n        # Otherwise it may also read better, but we don't do it today and requires\n        # careful considerations for all possible cases. See\n        # https://github.com/psf/black/issues/2156.\n\n    if max_priority == DOT_PRIORITY:\n        # A single stranded method call doesn't require optional parentheses.\n        return True\n\n    assert len(line.leaves) >= 2, \"Stranded delimiter\"\n\n    # With a single delimiter, omit if the expression starts or ends with\n    # a bracket.\n    first = line.leaves[0]\n    second = line.leaves[1]\n    if first.type in OPENING_BRACKETS and second.type not in CLOSING_BRACKETS:\n        if _can_omit_opening_paren(line, first=first, line_length=line_length):\n            return True\n\n        # Note: we are not returning False here because a line might have *both*\n        # a leading opening bracket and a trailing closing bracket.  If the\n        # opening bracket doesn't match our rule, maybe the closing will.\n\n    penultimate = line.leaves[-2]\n    last = line.leaves[-1]\n\n    if (\n        last.type == token.RPAR\n        or last.type == token.RBRACE\n        or (\n            # don't use indexing for omitting optional parentheses;\n            # it looks weird\n            last.type == token.RSQB\n            and last.parent\n            and last.parent.type != syms.trailer\n        )\n    ):\n        if penultimate.type in OPENING_BRACKETS:\n            # Empty brackets don't help.\n            return False\n\n        if is_multiline_string(first):\n            # Additional wrapping of a multiline string in this situation is\n            # unnecessary.\n            return True\n\n        if _can_omit_closing_paren(line, last=last, line_length=line_length):\n            return True\n\n    return False"
    },
    {
      "path": "tests/data/cases/type_ignore_with_other_comment.py",
      "version": "new",
      "line": 1,
      "kind": "module",
      "qualname": "tests.data.cases.type_ignore_with_other_comment",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-11T16:05:17"
}