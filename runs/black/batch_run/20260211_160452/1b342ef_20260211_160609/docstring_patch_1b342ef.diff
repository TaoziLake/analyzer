--- a/src/black/comments.py
+++ b/src/black/comments.py
@@ -192,7 +192,13 @@
 def normalize_fmt_off(
     node: Node, mode: Mode, lines: Collection[tuple[int, int]]
 ) -> None:
-    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
+    """TODO: docstring
+
+    Args:
+        node:
+        mode:
+        lines:
+    """
     try_again = True
     while try_again:
         try_again = convert_one_fmt_off_pair(node, mode, lines)
@@ -334,9 +340,12 @@
 def convert_one_fmt_off_pair(
     node: Node, mode: Mode, lines: Collection[tuple[int, int]]
 ) -> bool:
-    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
-
-    Returns True if a pair was converted.
+    """TODO: docstring
+
+    Args:
+        node:
+        mode:
+        lines:
     """
     for leaf in node.leaves():
         # Skip STANDALONE_COMMENT nodes that were created by fmt:off/on/skip processing
@@ -398,7 +407,16 @@
     lines: Collection[tuple[int, int]],
     leaf: Leaf,
 ) -> None:
-    """Handle fmt blocks with actual AST nodes."""
+    """TODO: docstring
+
+    Args:
+        ignored_nodes:
+        comment:
+        previous_consumed:
+        is_fmt_skip:
+        lines:
+        leaf:
+    """
     first = ignored_nodes[0]  # Can be a container node with the `leaf`.
     parent = first.parent
     prefix = first.prefix
@@ -430,6 +448,11 @@
             if has_standalone:
                 # Stringify node with STANDALONE_COMMENT leaves having trailing newlines
                 def stringify_node(n: LN) -> str:
+                    """TODO: docstring
+
+                    Args:
+                        n:
+                    """
                     if isinstance(n, Leaf):
                         if n.type == STANDALONE_COMMENT:
                             result = n.prefix + n.value
@@ -493,10 +516,12 @@
 def generate_ignored_nodes(
     leaf: Leaf, comment: ProtoComment, mode: Mode
 ) -> Iterator[LN]:
-    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
-
-    If comment is skip, returns leaf only.
-    Stops at the end of the block.
+    """TODO: docstring
+
+    Args:
+        leaf:
+        comment:
+        mode:
     """
     if contains_fmt_directive(comment.value, FMT_SKIP):
         yield from _generate_ignored_nodes_from_fmt_skip(leaf, comment, mode)
@@ -634,7 +659,13 @@
 def _generate_ignored_nodes_from_fmt_skip(
     leaf: Leaf, comment: ProtoComment, mode: Mode
 ) -> Iterator[LN]:
-    """Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`."""
+    """TODO: docstring
+
+    Args:
+        leaf:
+        comment:
+        mode:
+    """
     prev_sibling = leaf.prev_sibling
     parent = leaf.parent
     ignored_nodes: list[LN] = []
