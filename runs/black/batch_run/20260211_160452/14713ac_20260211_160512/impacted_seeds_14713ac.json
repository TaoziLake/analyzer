{
  "commit": "14713ac",
  "parent": "1d233bb977901a27c12bd883aa94eaa8f088f02c",
  "repo": "/Users/syhe/2026/black",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 5,
  "seeds": [
    {
      "path": "src/black/trans.py",
      "version": "new",
      "line": 1434,
      "kind": "function",
      "qualname": "src.black.trans.StringSplitter.do_splitter_match",
      "span": [
        1428,
        1494
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if self._prefer_paren_wrap_match(LL) is not None:\n            return TErr(\"Line needs to be wrapped in parens first.\")\n\n        # If the line is just STRING + COMMA (a one-item tuple) and not inside\n        # brackets, we need to defer to StringParenWrapper to wrap it first.\n        # Otherwise, splitting the string would create multiple expressions where\n        # only the last has the comma, breaking AST equivalence. See issue #4912.\n        if (\n            not line.inside_brackets\n            and len(LL) == 2\n            and LL[0].type == token.STRING\n            and LL[1].type == token.COMMA\n        ):\n            return TErr(\n                \"Line with trailing comma tuple needs to be wrapped in parens first.\"\n            )\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        idx = 0\n\n        # The first two leaves MAY be the 'not in' keywords...\n        if (\n            is_valid_index(idx)\n            and is_valid_index(idx + 1)\n            and [LL[idx].type, LL[idx + 1].type] == [token.NAME, token.NAME]\n            and str(LL[idx]) + str(LL[idx + 1]) == \"not in\"\n        ):\n            idx += 2\n        # Else the first leaf MAY be a string operator symbol or the 'in' keyword...\n        elif is_valid_index(idx) and (\n            LL[idx].type in self.STRING_OPERATORS\n            or LL[idx].type == token.NAME\n            and str(LL[idx]) == \"in\"\n        ):\n            idx += 1\n\n        # The next/first leaf MAY be an empty LPAR...\n        if is_valid_index(idx) and is_empty_lpar(LL[idx]):\n            idx += 1\n\n        # The next/first leaf MUST be a string...\n        if not is_valid_index(idx) or LL[idx].type != token.STRING:\n            return TErr(\"Line does not start with a string.\")\n\n        string_idx = idx\n\n        # Skip the string trailer, if one exists.\n        string_parser = StringParser()\n        idx = string_parser.parse(LL, string_idx)\n\n        # That string MAY be followed by an empty RPAR...\n        if is_valid_index(idx) and is_empty_rpar(LL[idx]):\n            idx += 1\n\n        # That string / empty RPAR leaf MAY be followed by a comma...\n        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n            idx += 1\n\n        # But no more leaves are allowed...\n        if is_valid_index(idx):\n            return TErr(\"This line does not end with a string.\")\n\n        return Ok([string_idx])",
      "old_code": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if self._prefer_paren_wrap_match(LL) is not None:\n            return TErr(\"Line needs to be wrapped in parens first.\")\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        idx = 0\n\n        # The first two leaves MAY be the 'not in' keywords...\n        if (\n            is_valid_index(idx)\n            and is_valid_index(idx + 1)\n            and [LL[idx].type, LL[idx + 1].type] == [token.NAME, token.NAME]\n            and str(LL[idx]) + str(LL[idx + 1]) == \"not in\"\n        ):\n            idx += 2\n        # Else the first leaf MAY be a string operator symbol or the 'in' keyword...\n        elif is_valid_index(idx) and (\n            LL[idx].type in self.STRING_OPERATORS\n            or LL[idx].type == token.NAME\n            and str(LL[idx]) == \"in\"\n        ):\n            idx += 1\n\n        # The next/first leaf MAY be an empty LPAR...\n        if is_valid_index(idx) and is_empty_lpar(LL[idx]):\n            idx += 1\n\n        # The next/first leaf MUST be a string...\n        if not is_valid_index(idx) or LL[idx].type != token.STRING:\n            return TErr(\"Line does not start with a string.\")\n\n        string_idx = idx\n\n        # Skip the string trailer, if one exists.\n        string_parser = StringParser()\n        idx = string_parser.parse(LL, string_idx)\n\n        # That string MAY be followed by an empty RPAR...\n        if is_valid_index(idx) and is_empty_rpar(LL[idx]):\n            idx += 1\n\n        # That string / empty RPAR leaf MAY be followed by a comma...\n        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n            idx += 1\n\n        # But no more leaves are allowed...\n        if is_valid_index(idx):\n            return TErr(\"This line does not end with a string.\")\n\n        return Ok([string_idx])"
    },
    {
      "path": "src/black/trans.py",
      "version": "new",
      "line": 1983,
      "kind": "function",
      "qualname": "src.black.trans.StringParenWrapper.do_splitter_match",
      "span": [
        1967,
        2008
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if line.leaves[-1].type in OPENING_BRACKETS:\n            return TErr(\n                \"Cannot wrap parens around a line that ends in an opening bracket.\"\n            )\n\n        string_idx = (\n            self._return_match(LL)\n            or self._else_match(LL)\n            or self._assert_match(LL)\n            or self._assign_match(LL)\n            or self._dict_or_lambda_match(LL)\n        )\n\n        if string_idx is None:\n            string_idx = self._trailing_comma_tuple_match(line)\n\n        if string_idx is None:\n            string_idx = self._prefer_paren_wrap_match(LL)\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has neither spaces nor East Asian stops...\n            if not any(\n                char == \" \" or char in SPLIT_SAFE_CHARS for char in string_value\n            ):\n                # And will still violate the line length limit when split...\n                max_string_width = self.line_length - ((line.depth + 1) * 4)\n                if str_width(string_value) > max_string_width:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok([string_idx])\n\n        return TErr(\"This line does not contain any non-atomic strings.\")",
      "old_code": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if line.leaves[-1].type in OPENING_BRACKETS:\n            return TErr(\n                \"Cannot wrap parens around a line that ends in an opening bracket.\"\n            )\n\n        string_idx = (\n            self._return_match(LL)\n            or self._else_match(LL)\n            or self._assert_match(LL)\n            or self._assign_match(LL)\n            or self._dict_or_lambda_match(LL)\n            or self._prefer_paren_wrap_match(LL)\n        )\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has neither spaces nor East Asian stops...\n            if not any(\n                char == \" \" or char in SPLIT_SAFE_CHARS for char in string_value\n            ):\n                # And will still violate the line length limit when split...\n                max_string_width = self.line_length - ((line.depth + 1) * 4)\n                if str_width(string_value) > max_string_width:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok([string_idx])\n\n        return TErr(\"This line does not contain any non-atomic strings.\")"
    },
    {
      "path": "src/black/trans.py",
      "version": "new",
      "line": 2183,
      "kind": "class",
      "qualname": "src.black.trans.StringParenWrapper",
      "span": [
        1909,
        2330
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class StringParenWrapper(BaseStringSplitter, CustomSplitMapMixin):\n    \"\"\"\n    StringTransformer that wraps strings in parens and then splits at the LPAR.\n\n    Requirements:\n        All of the requirements listed in BaseStringSplitter's docstring in\n        addition to the requirements listed below:\n\n        * The line is a return/yield statement, which returns/yields a string.\n          OR\n        * The line is part of a ternary expression (e.g. `x = y if cond else\n          z`) such that the line starts with `else <string>`, where <string> is\n          some string.\n          OR\n        * The line is an assert statement, which ends with a string.\n          OR\n        * The line is an assignment statement (e.g. `x = <string>` or `x +=\n          <string>`) such that the variable is being assigned the value of some\n          string.\n          OR\n        * The line is a dictionary key assignment where some valid key is being\n          assigned the value of some string.\n          OR\n        * The line is an lambda expression and the value is a string.\n          OR\n        * The line starts with an \"atom\" string that prefers to be wrapped in\n          parens. It's preferred to be wrapped when it's is an immediate child of\n          a list/set/tuple literal, AND the string is surrounded by commas (or is\n          the first/last child).\n\n    Transformations:\n        The chosen string is wrapped in parentheses and then split at the LPAR.\n\n        We then have one line which ends with an LPAR and another line that\n        starts with the chosen string. The latter line is then split again at\n        the RPAR. This results in the RPAR (and possibly a trailing comma)\n        being placed on its own line.\n\n        NOTE: If any leaves exist to the right of the chosen string (except\n        for a trailing comma, which would be placed after the RPAR), those\n        leaves are placed inside the parentheses.  In effect, the chosen\n        string is not necessarily being \"wrapped\" by parentheses. We can,\n        however, count on the LPAR being placed directly before the chosen\n        string.\n\n        In other words, StringParenWrapper creates \"atom\" strings. These\n        can then be split again by StringSplitter, if necessary.\n\n    Collaborations:\n        In the event that a string line split by StringParenWrapper is\n        changed such that it no longer needs to be given its own line,\n        StringParenWrapper relies on StringParenStripper to clean up the\n        parentheses it created.\n\n        For \"atom\" strings that prefers to be wrapped in parens, it requires\n        StringSplitter to hold the split until the string is wrapped in parens.\n    \"\"\"\n\n    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if line.leaves[-1].type in OPENING_BRACKETS:\n            return TErr(\n                \"Cannot wrap parens around a line that ends in an opening bracket.\"\n            )\n\n        string_idx = (\n            self._return_match(LL)\n            or self._else_match(LL)\n            or self._assert_match(LL)\n            or self._assign_match(LL)\n            or self._dict_or_lambda_match(LL)\n        )\n\n        if string_idx is None:\n            string_idx = self._trailing_comma_tuple_match(line)\n\n        if string_idx is None:\n            string_idx = self._prefer_paren_wrap_match(LL)\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has neither spaces nor East Asian stops...\n            if not any(\n                char == \" \" or char in SPLIT_SAFE_CHARS for char in string_value\n            ):\n                # And will still violate the line length limit when split...\n                max_string_width = self.line_length - ((line.depth + 1) * 4)\n                if str_width(string_value) > max_string_width:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok([string_idx])\n\n        return TErr(\"This line does not contain any non-atomic strings.\")\n\n    @staticmethod\n    def _return_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the return/yield statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a return/yield statement and the first leaf\n        # contains either the \"return\" or \"yield\" keywords...\n        if parent_type(LL[0]) in [syms.return_stmt, syms.yield_expr] and LL[\n            0\n        ].value in [\"return\", \"yield\"]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None\n\n    @staticmethod\n    def _else_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the ternary expression\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a ternary expression and the first leaf\n        # contains the \"else\" keyword...\n        if (\n            parent_type(LL[0]) == syms.test\n            and LL[0].type == token.NAME\n            and LL[0].value == \"else\"\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None\n\n    @staticmethod\n    def _assert_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assert statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of an assert statement and the first leaf\n        # contains the \"assert\" keyword...\n        if parent_type(LL[0]) == syms.assert_stmt and LL[0].value == \"assert\":\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find a comma...\n                if leaf.type == token.COMMA:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That comma MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    @staticmethod\n    def _assign_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assignment statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of an expression statement or is a function\n        # argument AND the first leaf contains a variable name...\n        if (\n            parent_type(LL[0]) in [syms.expr_stmt, syms.argument, syms.power]\n            and LL[0].type == token.NAME\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find either an '=' or '+=' symbol...\n                if leaf.type in [token.EQUAL, token.PLUSEQUAL]:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That symbol MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # The next leaf MAY be a comma iff this line is a part\n                        # of a function argument...\n                        if (\n                            parent_type(LL[0]) == syms.argument\n                            and is_valid_index(idx)\n                            and LL[idx].type == token.COMMA\n                        ):\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    @staticmethod\n    def _dict_or_lambda_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the dictionary key assignment\n            statement or lambda expression requirements listed in the\n            'Requirements' section of this classes' docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a dictionary key assignment or lambda expression...\n        parent_types = [parent_type(LL[0]), parent_type(LL[0].parent)]\n        if syms.dictsetmaker in parent_types or syms.lambdef in parent_types:\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find a colon, it can either be dict's or lambda's colon...\n                if leaf.type == token.COLON and i < len(LL) - 1:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That colon MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # That string MAY be followed by a comma...\n                        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    @staticmethod\n    def _trailing_comma_tuple_match(line: Line) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @line.leaves[string_idx] is equal to our target\n            (i.e. matched) string, if the line is a bare trailing comma tuple\n            (STRING + COMMA) not inside brackets.\n                OR\n            None, otherwise.\n\n        This handles the case from issue #4912 where a long string with a\n        trailing comma (making it a one-item tuple) needs to be wrapped in\n        parentheses before splitting to preserve AST equivalence.\n        \"\"\"\n        LL = line.leaves\n        # Match: STRING followed by COMMA, not inside brackets\n        if (\n            not line.inside_brackets\n            and len(LL) == 2\n            and LL[0].type == token.STRING\n            and LL[1].type == token.COMMA\n        ):\n            return 0\n\n        return None\n\n    def do_transform(\n        self, line: Line, string_indices: list[int]\n    ) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n        assert len(string_indices) == 1, (\n            f\"{self.__class__.__name__} should only find one match at a time, found\"\n            f\" {len(string_indices)}\"\n        )\n        string_idx = string_indices[0]\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        comma_idx = -1\n        ends_with_comma = False\n        if LL[comma_idx].type == token.COMMA:\n            ends_with_comma = True\n\n        leaves_to_steal_comments_from = [LL[string_idx]]\n        if ends_with_comma:\n            leaves_to_steal_comments_from.append(LL[comma_idx])\n\n        # --- First Line\n        first_line = line.clone()\n        left_leaves = LL[:string_idx]\n\n        # We have to remember to account for (possibly invisible) LPAR and RPAR\n        # leaves that already wrapped the target string. If these leaves do\n        # exist, we will replace them with our own LPAR and RPAR leaves.\n        old_parens_exist = False\n        if left_leaves and left_leaves[-1].type == token.LPAR:\n            old_parens_exist = True\n            leaves_to_steal_comments_from.append(left_leaves[-1])\n            left_leaves.pop()\n\n        append_leaves(first_line, line, left_leaves)\n\n        lpar_leaf = Leaf(token.LPAR, \"(\")\n        if old_parens_exist:\n            replace_child(LL[string_idx - 1], lpar_leaf)\n        else:\n            insert_str_child(lpar_leaf)\n        first_line.append(lpar_leaf)\n\n        # We throw inline comments that were originally to the right of the\n        # target string to the top line. They will now be shown to the right of\n        # the LPAR.\n        for leaf in leaves_to_steal_comments_from:\n            for comment_leaf in line.comments_after(leaf):\n                first_line.append(comment_leaf, preformatted=True)\n\n        yield Ok(first_line)\n\n        # --- Middle (String) Line\n        # We only need to yield one (possibly too long) string line, since the\n        # `StringSplitter` will break it down further if necessary.\n        string_value = LL[string_idx].value\n        string_line = Line(\n            mode=line.mode,\n            depth=line.depth + 1,\n            inside_brackets=True,\n            should_split_rhs=line.should_split_rhs,\n            magic_trailing_comma=line.magic_trailing_comma,\n        )\n        string_leaf = Leaf(token.STRING, string_value)\n        insert_str_child(string_leaf)\n        string_line.append(string_leaf)\n\n        old_rpar_leaf = None\n        if is_valid_index(string_idx + 1):\n            right_leaves = LL[string_idx + 1 :]\n            if ends_with_comma:\n                right_leaves.pop()\n\n            if old_parens_exist:\n                assert right_leaves and right_leaves[-1].type == token.RPAR, (\n                    \"Apparently, old parentheses do NOT exist?!\"\n                    f\" (left_leaves={left_leaves}, right_leaves={right_leaves})\"\n                )\n                old_rpar_leaf = right_leaves.pop()\n            elif right_leaves and right_leaves[-1].type == token.RPAR:\n                # Special case for lambda expressions as dict's value, e.g.:\n                #     my_dict = {\n                #        \"key\": lambda x: f\"formatted: {x}\",\n                #     }\n                # After wrapping the dict's value with parentheses, the string is\n                # followed by a RPAR but its opening bracket is lambda's, not\n                # the string's:\n                #        \"key\": (lambda x: f\"formatted: {x}\"),\n                opening_bracket = right_leaves[-1].opening_bracket\n                if opening_bracket is not None and opening_bracket in left_leaves:\n                    index = left_leaves.index(opening_bracket)\n                    if (\n                        0 < index < len(left_leaves) - 1\n                        and left_leaves[index - 1].type == token.COLON\n                        and left_leaves[index + 1].value == \"lambda\"\n                    ):\n                        right_leaves.pop()\n\n            append_leaves(string_line, line, right_leaves)\n\n        yield Ok(string_line)\n\n        # --- Last Line\n        last_line = line.clone()\n        last_line.bracket_tracker = first_line.bracket_tracker\n\n        new_rpar_leaf = Leaf(token.RPAR, \")\")\n        if old_rpar_leaf is not None:\n            replace_child(old_rpar_leaf, new_rpar_leaf)\n        else:\n            insert_str_child(new_rpar_leaf)\n        last_line.append(new_rpar_leaf)\n\n        # If the target string ended with a comma, we place this comma to the\n        # right of the RPAR on the last line.\n        if ends_with_comma:\n            comma_leaf = Leaf(token.COMMA, \",\")\n            replace_child(LL[comma_idx], comma_leaf)\n            last_line.append(comma_leaf)\n\n        yield Ok(last_line)",
      "old_code": "class StringParenWrapper(BaseStringSplitter, CustomSplitMapMixin):\n    \"\"\"\n    StringTransformer that wraps strings in parens and then splits at the LPAR.\n\n    Requirements:\n        All of the requirements listed in BaseStringSplitter's docstring in\n        addition to the requirements listed below:\n\n        * The line is a return/yield statement, which returns/yields a string.\n          OR\n        * The line is part of a ternary expression (e.g. `x = y if cond else\n          z`) such that the line starts with `else <string>`, where <string> is\n          some string.\n          OR\n        * The line is an assert statement, which ends with a string.\n          OR\n        * The line is an assignment statement (e.g. `x = <string>` or `x +=\n          <string>`) such that the variable is being assigned the value of some\n          string.\n          OR\n        * The line is a dictionary key assignment where some valid key is being\n          assigned the value of some string.\n          OR\n        * The line is an lambda expression and the value is a string.\n          OR\n        * The line starts with an \"atom\" string that prefers to be wrapped in\n          parens. It's preferred to be wrapped when it's is an immediate child of\n          a list/set/tuple literal, AND the string is surrounded by commas (or is\n          the first/last child).\n\n    Transformations:\n        The chosen string is wrapped in parentheses and then split at the LPAR.\n\n        We then have one line which ends with an LPAR and another line that\n        starts with the chosen string. The latter line is then split again at\n        the RPAR. This results in the RPAR (and possibly a trailing comma)\n        being placed on its own line.\n\n        NOTE: If any leaves exist to the right of the chosen string (except\n        for a trailing comma, which would be placed after the RPAR), those\n        leaves are placed inside the parentheses.  In effect, the chosen\n        string is not necessarily being \"wrapped\" by parentheses. We can,\n        however, count on the LPAR being placed directly before the chosen\n        string.\n\n        In other words, StringParenWrapper creates \"atom\" strings. These\n        can then be split again by StringSplitter, if necessary.\n\n    Collaborations:\n        In the event that a string line split by StringParenWrapper is\n        changed such that it no longer needs to be given its own line,\n        StringParenWrapper relies on StringParenStripper to clean up the\n        parentheses it created.\n\n        For \"atom\" strings that prefers to be wrapped in parens, it requires\n        StringSplitter to hold the split until the string is wrapped in parens.\n    \"\"\"\n\n    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        if line.leaves[-1].type in OPENING_BRACKETS:\n            return TErr(\n                \"Cannot wrap parens around a line that ends in an opening bracket.\"\n            )\n\n        string_idx = (\n            self._return_match(LL)\n            or self._else_match(LL)\n            or self._assert_match(LL)\n            or self._assign_match(LL)\n            or self._dict_or_lambda_match(LL)\n            or self._prefer_paren_wrap_match(LL)\n        )\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has neither spaces nor East Asian stops...\n            if not any(\n                char == \" \" or char in SPLIT_SAFE_CHARS for char in string_value\n            ):\n                # And will still violate the line length limit when split...\n                max_string_width = self.line_length - ((line.depth + 1) * 4)\n                if str_width(string_value) > max_string_width:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok([string_idx])\n\n        return TErr(\"This line does not contain any non-atomic strings.\")\n\n    @staticmethod\n    def _return_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the return/yield statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a return/yield statement and the first leaf\n        # contains either the \"return\" or \"yield\" keywords...\n        if parent_type(LL[0]) in [syms.return_stmt, syms.yield_expr] and LL[\n            0\n        ].value in [\"return\", \"yield\"]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None\n\n    @staticmethod\n    def _else_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the ternary expression\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a ternary expression and the first leaf\n        # contains the \"else\" keyword...\n        if (\n            parent_type(LL[0]) == syms.test\n            and LL[0].type == token.NAME\n            and LL[0].value == \"else\"\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None\n\n    @staticmethod\n    def _assert_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assert statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of an assert statement and the first leaf\n        # contains the \"assert\" keyword...\n        if parent_type(LL[0]) == syms.assert_stmt and LL[0].value == \"assert\":\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find a comma...\n                if leaf.type == token.COMMA:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That comma MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    @staticmethod\n    def _assign_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assignment statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of an expression statement or is a function\n        # argument AND the first leaf contains a variable name...\n        if (\n            parent_type(LL[0]) in [syms.expr_stmt, syms.argument, syms.power]\n            and LL[0].type == token.NAME\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find either an '=' or '+=' symbol...\n                if leaf.type in [token.EQUAL, token.PLUSEQUAL]:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That symbol MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # The next leaf MAY be a comma iff this line is a part\n                        # of a function argument...\n                        if (\n                            parent_type(LL[0]) == syms.argument\n                            and is_valid_index(idx)\n                            and LL[idx].type == token.COMMA\n                        ):\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    @staticmethod\n    def _dict_or_lambda_match(LL: list[Leaf]) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the dictionary key assignment\n            statement or lambda expression requirements listed in the\n            'Requirements' section of this classes' docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is a part of a dictionary key assignment or lambda expression...\n        parent_types = [parent_type(LL[0]), parent_type(LL[0].parent)]\n        if syms.dictsetmaker in parent_types or syms.lambdef in parent_types:\n            is_valid_index = is_valid_index_factory(LL)\n\n            for i, leaf in enumerate(LL):\n                # We MUST find a colon, it can either be dict's or lambda's colon...\n                if leaf.type == token.COLON and i < len(LL) - 1:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That colon MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # That string MAY be followed by a comma...\n                        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None\n\n    def do_transform(\n        self, line: Line, string_indices: list[int]\n    ) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n        assert len(string_indices) == 1, (\n            f\"{self.__class__.__name__} should only find one match at a time, found\"\n            f\" {len(string_indices)}\"\n        )\n        string_idx = string_indices[0]\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        comma_idx = -1\n        ends_with_comma = False\n        if LL[comma_idx].type == token.COMMA:\n            ends_with_comma = True\n\n        leaves_to_steal_comments_from = [LL[string_idx]]\n        if ends_with_comma:\n            leaves_to_steal_comments_from.append(LL[comma_idx])\n\n        # --- First Line\n        first_line = line.clone()\n        left_leaves = LL[:string_idx]\n\n        # We have to remember to account for (possibly invisible) LPAR and RPAR\n        # leaves that already wrapped the target string. If these leaves do\n        # exist, we will replace them with our own LPAR and RPAR leaves.\n        old_parens_exist = False\n        if left_leaves and left_leaves[-1].type == token.LPAR:\n            old_parens_exist = True\n            leaves_to_steal_comments_from.append(left_leaves[-1])\n            left_leaves.pop()\n\n        append_leaves(first_line, line, left_leaves)\n\n        lpar_leaf = Leaf(token.LPAR, \"(\")\n        if old_parens_exist:\n            replace_child(LL[string_idx - 1], lpar_leaf)\n        else:\n            insert_str_child(lpar_leaf)\n        first_line.append(lpar_leaf)\n\n        # We throw inline comments that were originally to the right of the\n        # target string to the top line. They will now be shown to the right of\n        # the LPAR.\n        for leaf in leaves_to_steal_comments_from:\n            for comment_leaf in line.comments_after(leaf):\n                first_line.append(comment_leaf, preformatted=True)\n\n        yield Ok(first_line)\n\n        # --- Middle (String) Line\n        # We only need to yield one (possibly too long) string line, since the\n        # `StringSplitter` will break it down further if necessary.\n        string_value = LL[string_idx].value\n        string_line = Line(\n            mode=line.mode,\n            depth=line.depth + 1,\n            inside_brackets=True,\n            should_split_rhs=line.should_split_rhs,\n            magic_trailing_comma=line.magic_trailing_comma,\n        )\n        string_leaf = Leaf(token.STRING, string_value)\n        insert_str_child(string_leaf)\n        string_line.append(string_leaf)\n\n        old_rpar_leaf = None\n        if is_valid_index(string_idx + 1):\n            right_leaves = LL[string_idx + 1 :]\n            if ends_with_comma:\n                right_leaves.pop()\n\n            if old_parens_exist:\n                assert right_leaves and right_leaves[-1].type == token.RPAR, (\n                    \"Apparently, old parentheses do NOT exist?!\"\n                    f\" (left_leaves={left_leaves}, right_leaves={right_leaves})\"\n                )\n                old_rpar_leaf = right_leaves.pop()\n            elif right_leaves and right_leaves[-1].type == token.RPAR:\n                # Special case for lambda expressions as dict's value, e.g.:\n                #     my_dict = {\n                #        \"key\": lambda x: f\"formatted: {x}\",\n                #     }\n                # After wrapping the dict's value with parentheses, the string is\n                # followed by a RPAR but its opening bracket is lambda's, not\n                # the string's:\n                #        \"key\": (lambda x: f\"formatted: {x}\"),\n                opening_bracket = right_leaves[-1].opening_bracket\n                if opening_bracket is not None and opening_bracket in left_leaves:\n                    index = left_leaves.index(opening_bracket)\n                    if (\n                        0 < index < len(left_leaves) - 1\n                        and left_leaves[index - 1].type == token.COLON\n                        and left_leaves[index + 1].value == \"lambda\"\n                    ):\n                        right_leaves.pop()\n\n            append_leaves(string_line, line, right_leaves)\n\n        yield Ok(string_line)\n\n        # --- Last Line\n        last_line = line.clone()\n        last_line.bracket_tracker = first_line.bracket_tracker\n\n        new_rpar_leaf = Leaf(token.RPAR, \")\")\n        if old_rpar_leaf is not None:\n            replace_child(old_rpar_leaf, new_rpar_leaf)\n        else:\n            insert_str_child(new_rpar_leaf)\n        last_line.append(new_rpar_leaf)\n\n        # If the target string ended with a comma, we place this comma to the\n        # right of the RPAR on the last line.\n        if ends_with_comma:\n            comma_leaf = Leaf(token.COMMA, \",\")\n            replace_child(LL[comma_idx], comma_leaf)\n            last_line.append(comma_leaf)\n\n        yield Ok(last_line)"
    },
    {
      "path": "src/black/trans.py",
      "version": "new",
      "line": 2184,
      "kind": "function",
      "qualname": "src.black.trans.StringParenWrapper._trailing_comma_tuple_match",
      "span": [
        2184,
        2207
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _trailing_comma_tuple_match(line: Line) -> int | None:\n        \"\"\"\n        Returns:\n            string_idx such that @line.leaves[string_idx] is equal to our target\n            (i.e. matched) string, if the line is a bare trailing comma tuple\n            (STRING + COMMA) not inside brackets.\n                OR\n            None, otherwise.\n\n        This handles the case from issue #4912 where a long string with a\n        trailing comma (making it a one-item tuple) needs to be wrapped in\n        parentheses before splitting to preserve AST equivalence.\n        \"\"\"\n        LL = line.leaves\n        # Match: STRING followed by COMMA, not inside brackets\n        if (\n            not line.inside_brackets\n            and len(LL) == 2\n            and LL[0].type == token.STRING\n            and LL[1].type == token.COMMA\n        ):\n            return 0\n\n        return None",
      "old_code": null
    },
    {
      "path": "tests/data/cases/preview_long_strings.py",
      "version": "new",
      "line": 42,
      "kind": "module",
      "qualname": "tests.data.cases.preview_long_strings",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-11T16:05:12"
}