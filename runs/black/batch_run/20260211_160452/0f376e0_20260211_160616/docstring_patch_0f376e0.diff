--- a/src/black/comments.py
+++ b/src/black/comments.py
@@ -87,7 +87,13 @@
 
 @lru_cache(maxsize=4096)
 def list_comments(prefix: str, *, is_endmarker: bool, mode: Mode) -> list[ProtoComment]:
-    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
+    """TODO: docstring
+
+    Args:
+        prefix:
+        is_endmarker:
+        mode:
+    """
     result: list[ProtoComment] = []
     if not prefix or "#" not in prefix:
         return result
@@ -149,15 +155,11 @@
 
 
 def make_comment(content: str, mode: Mode) -> str:
-    """Return a consistently formatted comment from the given `content` string.
-
-    All comments (except for "##", "#!", "#:", '#'") should have a single
-    space between the hash sign and the content.
-
-    If `content` didn't start with a hash sign, one is provided.
-
-    Comments containing fmt directives are preserved exactly as-is to respect
-    user intent (e.g., `#no space # fmt: skip` stays as-is).
+    """TODO: docstring
+
+    Args:
+        content:
+        mode:
     """
     content = content.rstrip()
     if not content:
@@ -192,7 +194,13 @@
 def normalize_fmt_off(
     node: Node, mode: Mode, lines: Collection[tuple[int, int]]
 ) -> None:
-    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
+    """TODO: docstring
+
+    Args:
+        node:
+        mode:
+        lines:
+    """
     try_again = True
     while try_again:
         try_again = convert_one_fmt_off_pair(node, mode, lines)
@@ -201,9 +209,11 @@
 def _should_process_fmt_comment(
     comment: ProtoComment, leaf: Leaf
 ) -> tuple[bool, bool, bool]:
-    """Check if comment should be processed for fmt handling.
-
-    Returns (should_process, is_fmt_off, is_fmt_skip).
+    """TODO: docstring
+
+    Args:
+        comment:
+        leaf:
     """
     is_fmt_off = contains_fmt_directive(comment.value, FMT_OFF)
     is_fmt_skip = contains_fmt_directive(comment.value, FMT_SKIP)
@@ -248,9 +258,13 @@
     previous_consumed: int,
     mode: Mode,
 ) -> bool:
-    """Handle fmt:off/on blocks that contain only comments.
-
-    Returns True if a block was converted, False otherwise.
+    """TODO: docstring
+
+    Args:
+        leaf:
+        comment:
+        previous_consumed:
+        mode:
     """
     all_comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)
 
@@ -334,9 +348,12 @@
 def convert_one_fmt_off_pair(
     node: Node, mode: Mode, lines: Collection[tuple[int, int]]
 ) -> bool:
-    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
-
-    Returns True if a pair was converted.
+    """TODO: docstring
+
+    Args:
+        node:
+        mode:
+        lines:
     """
     for leaf in node.leaves():
         # Skip STANDALONE_COMMENT nodes that were created by fmt:off/on processing
@@ -400,7 +417,16 @@
     lines: Collection[tuple[int, int]],
     leaf: Leaf,
 ) -> None:
-    """Handle fmt blocks with actual AST nodes."""
+    """TODO: docstring
+
+    Args:
+        ignored_nodes:
+        comment:
+        previous_consumed:
+        is_fmt_skip:
+        lines:
+        leaf:
+    """
     first = ignored_nodes[0]  # Can be a container node with the `leaf`.
     parent = first.parent
     prefix = first.prefix
@@ -459,10 +485,12 @@
 def generate_ignored_nodes(
     leaf: Leaf, comment: ProtoComment, mode: Mode
 ) -> Iterator[LN]:
-    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
-
-    If comment is skip, returns leaf only.
-    Stops at the end of the block.
+    """TODO: docstring
+
+    Args:
+        leaf:
+        comment:
+        mode:
     """
     if contains_fmt_directive(comment.value, FMT_SKIP):
         yield from _generate_ignored_nodes_from_fmt_skip(leaf, comment, mode)
@@ -600,7 +628,13 @@
 def _generate_ignored_nodes_from_fmt_skip(
     leaf: Leaf, comment: ProtoComment, mode: Mode
 ) -> Iterator[LN]:
-    """Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`."""
+    """TODO: docstring
+
+    Args:
+        leaf:
+        comment:
+        mode:
+    """
     prev_sibling = leaf.prev_sibling
     parent = leaf.parent
     ignored_nodes: list[LN] = []
@@ -716,8 +750,11 @@
 
 
 def is_fmt_on(container: LN, mode: Mode) -> bool:
-    """Determine whether formatting is switched on within a container.
-    Determined by whether the last `# fmt:` comment is `on` or `off`.
+    """TODO: docstring
+
+    Args:
+        container:
+        mode:
     """
     fmt_on = False
     for comment in list_comments(container.prefix, is_endmarker=False, mode=mode):
@@ -729,7 +766,12 @@
 
 
 def children_contains_fmt_on(container: LN, mode: Mode) -> bool:
-    """Determine if children have formatting switched on."""
+    """TODO: docstring
+
+    Args:
+        container:
+        mode:
+    """
     for child in container.children:
         leaf = first_leaf_of(child)
         if leaf is not None and is_fmt_on(leaf, mode=mode):
@@ -755,17 +797,11 @@
 def contains_fmt_directive(
     comment_line: str, directives: set[str] = FMT_OFF | FMT_ON | FMT_SKIP
 ) -> bool:
-    """
-    Checks if the given comment contains format directives, alone or paired with
-    other comments.
-
-    Defaults to checking all directives (skip, off, on, yapf), but can be
-    narrowed to specific ones.
-
-    Matching styles:
-      # foobar                    <-- single comment
-      # foobar # foobar # foobar  <-- multiple comments
-      # foobar; foobar            <-- list of comments (; separated)
+    """TODO: docstring
+
+    Args:
+        comment_line:
+        directives:
     """
     semantic_comment_blocks = [
         comment_line,

--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -387,6 +387,11 @@
         yield from self.line()
 
     def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
+        """TODO: docstring
+
+        Args:
+            leaf:
+        """
         any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
         if not any_open_brackets:
             yield from self.line()
@@ -1470,13 +1475,13 @@
 def normalize_invisible_parens(
     node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]
 ) -> None:
-    """Make existing optional parentheses invisible or create new ones.
-
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    """TODO: docstring
+
+    Args:
+        node:
+        parens_after:
+        mode:
+        features:
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if contains_fmt_directive(pc.value, FMT_OFF):
