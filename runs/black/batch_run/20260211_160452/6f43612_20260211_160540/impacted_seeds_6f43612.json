{
  "commit": "6f43612",
  "parent": "200c550aff44372f801a6d826a361cb26f45a504",
  "repo": "/Users/syhe/2026/black",
  "num_files_in_diff": 5,
  "num_py_files_in_diff": 3,
  "num_seeds": 16,
  "seeds": [
    {
      "path": "src/black/__init__.py",
      "version": "new",
      "line": 26,
      "kind": "module",
      "qualname": "src.black.__init__",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/black/__init__.py",
      "version": "new",
      "line": 688,
      "kind": "function",
      "qualname": "src.black.__init__.main",
      "span": [
        516,
        730
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def main(\n    ctx: click.Context,\n    code: str | None,\n    line_length: int,\n    target_version: list[TargetVersion],\n    check: bool,\n    diff: bool,\n    line_ranges: Sequence[str],\n    color: bool,\n    fast: bool,\n    pyi: bool,\n    ipynb: bool,\n    python_cell_magics: Sequence[str],\n    skip_source_first_line: bool,\n    skip_string_normalization: bool,\n    skip_magic_trailing_comma: bool,\n    preview: bool,\n    unstable: bool,\n    enable_unstable_feature: list[Preview],\n    quiet: bool,\n    verbose: bool,\n    required_version: str | None,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    stdin_filename: str | None,\n    workers: int | None,\n    src: tuple[str, ...],\n    config: str | None,\n    no_cache: bool,\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    ctx.ensure_object(dict)\n\n    assert sys.version_info >= (3, 10), \"Black requires Python 3.10+\"\n    if sys.version_info[:3] == (3, 12, 5):\n        out(\n            \"Python 3.12.5 has a memory safety issue that can cause Black's \"\n            \"AST safety checks to fail. \"\n            \"Please upgrade to Python 3.12.6 or downgrade to Python 3.12.4\"\n        )\n        ctx.exit(1)\n\n    if src and code is not None:\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'SRC' and 'code' cannot be passed simultaneously.\"\n        )\n        ctx.exit(1)\n    if not src and code is None:\n        out(main.get_usage(ctx) + \"\\n\\nOne of 'SRC' or 'code' is required.\")\n        ctx.exit(1)\n\n    # It doesn't do anything if --unstable is also passed, so just allow it.\n    if enable_unstable_feature and not (preview or unstable):\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'--enable-unstable-feature' requires '--preview'.\"\n        )\n        ctx.exit(1)\n\n    root, method = (\n        find_project_root(src, stdin_filename) if code is None else (None, None)\n    )\n    ctx.obj[\"root\"] = root\n\n    if verbose:\n        if root:\n            out(\n                f\"Identified `{root}` as project root containing a {method}.\",\n                fg=\"blue\",\n            )\n\n        if config:\n            config_source = ctx.get_parameter_source(\"config\")\n            user_level_config = str(find_user_pyproject_toml())\n            if config == user_level_config:\n                out(\n                    \"Using configuration from user-level config at \"\n                    f\"'{user_level_config}'.\",\n                    fg=\"blue\",\n                )\n            elif config_source in (\n                ParameterSource.DEFAULT,\n                ParameterSource.DEFAULT_MAP,\n            ):\n                out(\"Using configuration from project root.\", fg=\"blue\")\n            else:\n                out(f\"Using configuration in '{config}'.\", fg=\"blue\")\n            if ctx.default_map:\n                for param, value in ctx.default_map.items():\n                    out(f\"{param}: {value}\")\n\n    error_msg = \"Oh no! ðŸ’¥ ðŸ’” ðŸ’¥\"\n    if (\n        required_version\n        and required_version != __version__\n        and required_version != __version__.split(\".\")[0]\n    ):\n        err(\n            f\"{error_msg} The required version `{required_version}` does not match\"\n            f\" the running version `{__version__}`!\"\n        )\n        ctx.exit(1)\n    if ipynb and pyi:\n        err(\"Cannot pass both `pyi` and `ipynb` flags!\")\n        ctx.exit(1)\n\n    write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)\n    if target_version:\n        versions = set(target_version)\n    else:\n        # We'll autodetect later.\n        versions = set()\n    mode = Mode(\n        target_versions=versions,\n        line_length=line_length,\n        is_pyi=pyi,\n        is_ipynb=ipynb,\n        skip_source_first_line=skip_source_first_line,\n        string_normalization=not skip_string_normalization,\n        magic_trailing_comma=not skip_magic_trailing_comma,\n        preview=preview,\n        unstable=unstable,\n        python_cell_magics=set(python_cell_magics),\n        enabled_features=set(enable_unstable_feature),\n    )\n\n    lines: list[tuple[int, int]] = []\n    if line_ranges:\n        if ipynb:\n            err(\"Cannot use --line-ranges with ipynb files.\")\n            ctx.exit(1)\n\n        try:\n            lines = parse_line_ranges(line_ranges)\n        except ValueError as e:\n            err(str(e))\n            ctx.exit(1)\n\n    if code is not None:\n        # Run in quiet mode by default with -c; the extra output isn't useful.\n        # You can still pass -v to get verbose output.\n        quiet = True\n\n    report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)\n\n    if code is not None:\n        reformat_code(\n            content=code,\n            fast=fast,\n            write_back=write_back,\n            mode=mode,\n            report=report,\n            lines=lines,\n        )\n    else:\n        assert root is not None  # root is only None if code is not None\n        try:\n            sources = get_sources(\n                root=root,\n                src=src,\n                quiet=quiet,\n                verbose=verbose,\n                include=include,\n                exclude=exclude,\n                extend_exclude=extend_exclude,\n                force_exclude=force_exclude,\n                report=report,\n                stdin_filename=stdin_filename,\n            )\n        except GitIgnorePatternError:\n            ctx.exit(1)\n\n        if not sources:\n            if verbose or not quiet:\n                out(\"No Python files are present to be formatted. Nothing to do ðŸ˜´\")\n            if \"-\" in src:\n                sys.stdout.write(sys.stdin.read())\n            ctx.exit(0)\n\n        if len(sources) == 1:\n            reformat_one(\n                src=sources.pop(),\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                lines=lines,\n                no_cache=no_cache,\n            )\n        else:\n            from black.concurrency import reformat_many\n\n            if lines:\n                err(\"Cannot use --line-ranges to format multiple files.\")\n                ctx.exit(1)\n            reformat_many(\n                sources=sources,\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                workers=workers,\n                no_cache=no_cache,\n            )\n\n    if verbose or not quiet:\n        if code is None and (verbose or report.change_count or report.failure_count):\n            out()\n        out(error_msg if report.return_code else \"All done! âœ¨ ðŸ° âœ¨\")\n        if code is None:\n            click.echo(str(report), err=True)\n    ctx.exit(report.return_code)",
      "old_code": "def main(\n    ctx: click.Context,\n    code: str | None,\n    line_length: int,\n    target_version: list[TargetVersion],\n    check: bool,\n    diff: bool,\n    line_ranges: Sequence[str],\n    color: bool,\n    fast: bool,\n    pyi: bool,\n    ipynb: bool,\n    python_cell_magics: Sequence[str],\n    skip_source_first_line: bool,\n    skip_string_normalization: bool,\n    skip_magic_trailing_comma: bool,\n    preview: bool,\n    unstable: bool,\n    enable_unstable_feature: list[Preview],\n    quiet: bool,\n    verbose: bool,\n    required_version: str | None,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    stdin_filename: str | None,\n    workers: int | None,\n    src: tuple[str, ...],\n    config: str | None,\n    no_cache: bool,\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    ctx.ensure_object(dict)\n\n    assert sys.version_info >= (3, 10), \"Black requires Python 3.10+\"\n    if sys.version_info[:3] == (3, 12, 5):\n        out(\n            \"Python 3.12.5 has a memory safety issue that can cause Black's \"\n            \"AST safety checks to fail. \"\n            \"Please upgrade to Python 3.12.6 or downgrade to Python 3.12.4\"\n        )\n        ctx.exit(1)\n\n    if src and code is not None:\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'SRC' and 'code' cannot be passed simultaneously.\"\n        )\n        ctx.exit(1)\n    if not src and code is None:\n        out(main.get_usage(ctx) + \"\\n\\nOne of 'SRC' or 'code' is required.\")\n        ctx.exit(1)\n\n    # It doesn't do anything if --unstable is also passed, so just allow it.\n    if enable_unstable_feature and not (preview or unstable):\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'--enable-unstable-feature' requires '--preview'.\"\n        )\n        ctx.exit(1)\n\n    root, method = (\n        find_project_root(src, stdin_filename) if code is None else (None, None)\n    )\n    ctx.obj[\"root\"] = root\n\n    if verbose:\n        if root:\n            out(\n                f\"Identified `{root}` as project root containing a {method}.\",\n                fg=\"blue\",\n            )\n\n        if config:\n            config_source = ctx.get_parameter_source(\"config\")\n            user_level_config = str(find_user_pyproject_toml())\n            if config == user_level_config:\n                out(\n                    \"Using configuration from user-level config at \"\n                    f\"'{user_level_config}'.\",\n                    fg=\"blue\",\n                )\n            elif config_source in (\n                ParameterSource.DEFAULT,\n                ParameterSource.DEFAULT_MAP,\n            ):\n                out(\"Using configuration from project root.\", fg=\"blue\")\n            else:\n                out(f\"Using configuration in '{config}'.\", fg=\"blue\")\n            if ctx.default_map:\n                for param, value in ctx.default_map.items():\n                    out(f\"{param}: {value}\")\n\n    error_msg = \"Oh no! ðŸ’¥ ðŸ’” ðŸ’¥\"\n    if (\n        required_version\n        and required_version != __version__\n        and required_version != __version__.split(\".\")[0]\n    ):\n        err(\n            f\"{error_msg} The required version `{required_version}` does not match\"\n            f\" the running version `{__version__}`!\"\n        )\n        ctx.exit(1)\n    if ipynb and pyi:\n        err(\"Cannot pass both `pyi` and `ipynb` flags!\")\n        ctx.exit(1)\n\n    write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)\n    if target_version:\n        versions = set(target_version)\n    else:\n        # We'll autodetect later.\n        versions = set()\n    mode = Mode(\n        target_versions=versions,\n        line_length=line_length,\n        is_pyi=pyi,\n        is_ipynb=ipynb,\n        skip_source_first_line=skip_source_first_line,\n        string_normalization=not skip_string_normalization,\n        magic_trailing_comma=not skip_magic_trailing_comma,\n        preview=preview,\n        unstable=unstable,\n        python_cell_magics=set(python_cell_magics),\n        enabled_features=set(enable_unstable_feature),\n    )\n\n    lines: list[tuple[int, int]] = []\n    if line_ranges:\n        if ipynb:\n            err(\"Cannot use --line-ranges with ipynb files.\")\n            ctx.exit(1)\n\n        try:\n            lines = parse_line_ranges(line_ranges)\n        except ValueError as e:\n            err(str(e))\n            ctx.exit(1)\n\n    if code is not None:\n        # Run in quiet mode by default with -c; the extra output isn't useful.\n        # You can still pass -v to get verbose output.\n        quiet = True\n\n    report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)\n\n    if code is not None:\n        reformat_code(\n            content=code,\n            fast=fast,\n            write_back=write_back,\n            mode=mode,\n            report=report,\n            lines=lines,\n        )\n    else:\n        assert root is not None  # root is only None if code is not None\n        try:\n            sources = get_sources(\n                root=root,\n                src=src,\n                quiet=quiet,\n                verbose=verbose,\n                include=include,\n                exclude=exclude,\n                extend_exclude=extend_exclude,\n                force_exclude=force_exclude,\n                report=report,\n                stdin_filename=stdin_filename,\n            )\n        except GitWildMatchPatternError:\n            ctx.exit(1)\n\n        if not sources:\n            if verbose or not quiet:\n                out(\"No Python files are present to be formatted. Nothing to do ðŸ˜´\")\n            if \"-\" in src:\n                sys.stdout.write(sys.stdin.read())\n            ctx.exit(0)\n\n        if len(sources) == 1:\n            reformat_one(\n                src=sources.pop(),\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                lines=lines,\n                no_cache=no_cache,\n            )\n        else:\n            from black.concurrency import reformat_many\n\n            if lines:\n                err(\"Cannot use --line-ranges to format multiple files.\")\n                ctx.exit(1)\n            reformat_many(\n                sources=sources,\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                workers=workers,\n                no_cache=no_cache,\n            )\n\n    if verbose or not quiet:\n        if code is None and (verbose or report.change_count or report.failure_count):\n            out()\n        out(error_msg if report.return_code else \"All done! âœ¨ ðŸ° âœ¨\")\n        if code is None:\n            click.echo(str(report), err=True)\n    ctx.exit(report.return_code)"
    },
    {
      "path": "src/black/__init__.py",
      "version": "new",
      "line": 752,
      "kind": "function",
      "qualname": "src.black.__init__.get_sources",
      "span": [
        733,
        828
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def get_sources(\n    *,\n    root: Path,\n    src: tuple[str, ...],\n    quiet: bool,\n    verbose: bool,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    report: \"Report\",\n    stdin_filename: str | None,\n) -> set[Path]:\n    \"\"\"Compute the set of files to be formatted.\"\"\"\n    sources: set[Path] = set()\n\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    using_default_exclude = exclude is None\n    exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES) if exclude is None else exclude\n    gitignore: dict[Path, GitIgnoreSpec] | None = None\n    root_gitignore = get_gitignore(root)\n\n    for s in src:\n        if s == \"-\" and stdin_filename:\n            path = Path(stdin_filename)\n            if path_is_excluded(stdin_filename, force_exclude):\n                report.path_ignored(\n                    path,\n                    \"--stdin-filename matches the --force-exclude regular expression\",\n                )\n                continue\n            is_stdin = True\n        else:\n            path = Path(s)\n            is_stdin = False\n\n        # Compare the logic here to the logic in `gen_python_files`.\n        if is_stdin or path.is_file():\n            if resolves_outside_root_or_cannot_stat(path, root, report):\n                if verbose:\n                    out(f'Skipping invalid source: \"{path}\"', fg=\"red\")\n                continue\n\n            root_relative_path = best_effort_relative_path(path, root).as_posix()\n            root_relative_path = \"/\" + root_relative_path\n\n            # Hard-exclude any files that matches the `--force-exclude` regex.\n            if path_is_excluded(root_relative_path, force_exclude):\n                report.path_ignored(\n                    path, \"matches the --force-exclude regular expression\"\n                )\n                continue\n\n            if is_stdin:\n                path = Path(f\"{STDIN_PLACEHOLDER}{path}\")\n\n            if path.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\n                warn=verbose or not quiet\n            ):\n                continue\n\n            if verbose:\n                out(f'Found input source: \"{path}\"', fg=\"blue\")\n            sources.add(path)\n        elif path.is_dir():\n            path = root / (path.resolve().relative_to(root))\n            if verbose:\n                out(f'Found input source directory: \"{path}\"', fg=\"blue\")\n\n            if using_default_exclude:\n                gitignore = {\n                    root: root_gitignore,\n                    path: get_gitignore(path),\n                }\n            sources.update(\n                gen_python_files(\n                    path.iterdir(),\n                    root,\n                    include,\n                    exclude,\n                    extend_exclude,\n                    force_exclude,\n                    report,\n                    gitignore,\n                    verbose=verbose,\n                    quiet=quiet,\n                )\n            )\n        elif s == \"-\":\n            if verbose:\n                out(\"Found input source stdin\", fg=\"blue\")\n            sources.add(path)\n        else:\n            err(f\"invalid path: {s}\")\n\n    return sources",
      "old_code": "def get_sources(\n    *,\n    root: Path,\n    src: tuple[str, ...],\n    quiet: bool,\n    verbose: bool,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    report: \"Report\",\n    stdin_filename: str | None,\n) -> set[Path]:\n    \"\"\"Compute the set of files to be formatted.\"\"\"\n    sources: set[Path] = set()\n\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    using_default_exclude = exclude is None\n    exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES) if exclude is None else exclude\n    gitignore: dict[Path, PathSpec] | None = None\n    root_gitignore = get_gitignore(root)\n\n    for s in src:\n        if s == \"-\" and stdin_filename:\n            path = Path(stdin_filename)\n            if path_is_excluded(stdin_filename, force_exclude):\n                report.path_ignored(\n                    path,\n                    \"--stdin-filename matches the --force-exclude regular expression\",\n                )\n                continue\n            is_stdin = True\n        else:\n            path = Path(s)\n            is_stdin = False\n\n        # Compare the logic here to the logic in `gen_python_files`.\n        if is_stdin or path.is_file():\n            if resolves_outside_root_or_cannot_stat(path, root, report):\n                if verbose:\n                    out(f'Skipping invalid source: \"{path}\"', fg=\"red\")\n                continue\n\n            root_relative_path = best_effort_relative_path(path, root).as_posix()\n            root_relative_path = \"/\" + root_relative_path\n\n            # Hard-exclude any files that matches the `--force-exclude` regex.\n            if path_is_excluded(root_relative_path, force_exclude):\n                report.path_ignored(\n                    path, \"matches the --force-exclude regular expression\"\n                )\n                continue\n\n            if is_stdin:\n                path = Path(f\"{STDIN_PLACEHOLDER}{path}\")\n\n            if path.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\n                warn=verbose or not quiet\n            ):\n                continue\n\n            if verbose:\n                out(f'Found input source: \"{path}\"', fg=\"blue\")\n            sources.add(path)\n        elif path.is_dir():\n            path = root / (path.resolve().relative_to(root))\n            if verbose:\n                out(f'Found input source directory: \"{path}\"', fg=\"blue\")\n\n            if using_default_exclude:\n                gitignore = {\n                    root: root_gitignore,\n                    path: get_gitignore(path),\n                }\n            sources.update(\n                gen_python_files(\n                    path.iterdir(),\n                    root,\n                    include,\n                    exclude,\n                    extend_exclude,\n                    force_exclude,\n                    report,\n                    gitignore,\n                    verbose=verbose,\n                    quiet=quiet,\n                )\n            )\n        elif s == \"-\":\n            if verbose:\n                out(\"Found input source stdin\", fg=\"blue\")\n            sources.add(path)\n        else:\n            err(f\"invalid path: {s}\")\n\n    return sources"
    },
    {
      "path": "src/black/files.py",
      "version": "new",
      "line": 13,
      "kind": "module",
      "qualname": "src.black.files",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/black/files.py",
      "version": "new",
      "line": 241,
      "kind": "function",
      "qualname": "src.black.files.get_gitignore",
      "span": [
        241,
        252
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def get_gitignore(root: Path) -> GitIgnoreSpec:\n    \"\"\"Return a GitIgnoreSpec matching gitignore content if present.\"\"\"\n    gitignore = root / \".gitignore\"\n    lines: list[str] = []\n    if gitignore.is_file():\n        with gitignore.open(encoding=\"utf-8\") as gf:\n            lines = gf.readlines()\n    try:\n        return GitIgnoreSpec.from_lines(lines)\n    except GitIgnorePatternError as e:\n        err(f\"Could not parse {gitignore}: {e}\")\n        raise",
      "old_code": "def get_gitignore(root: Path) -> PathSpec:\n    \"\"\"Return a PathSpec matching gitignore content if present.\"\"\"\n    gitignore = root / \".gitignore\"\n    lines: list[str] = []\n    if gitignore.is_file():\n        with gitignore.open(encoding=\"utf-8\") as gf:\n            lines = gf.readlines()\n    try:\n        return PathSpec.from_lines(\"gitwildmatch\", lines)\n    except GitWildMatchPatternError as e:\n        err(f\"Could not parse {gitignore}: {e}\")\n        raise"
    },
    {
      "path": "src/black/files.py",
      "version": "new",
      "line": 295,
      "kind": "function",
      "qualname": "src.black.files._path_is_ignored",
      "span": [
        292,
        309
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _path_is_ignored(\n    root_relative_path: str,\n    root: Path,\n    gitignore_dict: dict[Path, GitIgnoreSpec],\n) -> bool:\n    path = root / root_relative_path\n    # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must\n    # ensure that gitignore_dict is ordered from least specific to most specific.\n    for gitignore_path, pattern in gitignore_dict.items():\n        try:\n            relative_path = path.relative_to(gitignore_path).as_posix()\n            if path.is_dir():\n                relative_path = relative_path + \"/\"\n        except ValueError:\n            break\n        if pattern.match_file(relative_path):\n            return True\n    return False",
      "old_code": "def _path_is_ignored(\n    root_relative_path: str,\n    root: Path,\n    gitignore_dict: dict[Path, PathSpec],\n) -> bool:\n    path = root / root_relative_path\n    # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must\n    # ensure that gitignore_dict is ordered from least specific to most specific.\n    for gitignore_path, pattern in gitignore_dict.items():\n        try:\n            relative_path = path.relative_to(gitignore_path).as_posix()\n            if path.is_dir():\n                relative_path = relative_path + \"/\"\n        except ValueError:\n            break\n        if pattern.match_file(relative_path):\n            return True\n    return False"
    },
    {
      "path": "src/black/files.py",
      "version": "new",
      "line": 328,
      "kind": "function",
      "qualname": "src.black.files.gen_python_files",
      "span": [
        320,
        406
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def gen_python_files(\n    paths: Iterable[Path],\n    root: Path,\n    include: Pattern[str],\n    exclude: Pattern[str],\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    report: Report,\n    gitignore_dict: dict[Path, GitIgnoreSpec] | None,\n    *,\n    verbose: bool,\n    quiet: bool,\n) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` whose paths are not excluded by the\n    `exclude_regex`, `extend_exclude`, or `force_exclude` regexes,\n    but are included by the `include` regex.\n\n    Symbolic links pointing outside of the `root` directory are ignored.\n\n    `report` is where output about exclusions goes.\n    \"\"\"\n\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    for child in paths:\n        assert child.is_absolute()\n        root_relative_path = child.relative_to(root).as_posix()\n\n        # First ignore files matching .gitignore, if passed\n        if gitignore_dict and _path_is_ignored(\n            root_relative_path, root, gitignore_dict\n        ):\n            report.path_ignored(child, \"matches a .gitignore file content\")\n            continue\n\n        # Then ignore with `--exclude` `--extend-exclude` and `--force-exclude` options.\n        root_relative_path = \"/\" + root_relative_path\n        if child.is_dir():\n            root_relative_path += \"/\"\n\n        if path_is_excluded(root_relative_path, exclude):\n            report.path_ignored(child, \"matches the --exclude regular expression\")\n            continue\n\n        if path_is_excluded(root_relative_path, extend_exclude):\n            report.path_ignored(\n                child, \"matches the --extend-exclude regular expression\"\n            )\n            continue\n\n        if path_is_excluded(root_relative_path, force_exclude):\n            report.path_ignored(child, \"matches the --force-exclude regular expression\")\n            continue\n\n        if resolves_outside_root_or_cannot_stat(child, root, report):\n            continue\n\n        if child.is_dir():\n            # If gitignore is None, gitignore usage is disabled, while a Falsey\n            # gitignore is when the directory doesn't have a .gitignore file.\n            if gitignore_dict is not None:\n                new_gitignore_dict = {\n                    **gitignore_dict,\n                    root / child: get_gitignore(child),\n                }\n            else:\n                new_gitignore_dict = None\n            yield from gen_python_files(\n                child.iterdir(),\n                root,\n                include,\n                exclude,\n                extend_exclude,\n                force_exclude,\n                report,\n                new_gitignore_dict,\n                verbose=verbose,\n                quiet=quiet,\n            )\n\n        elif child.is_file():\n            if child.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\n                warn=verbose or not quiet\n            ):\n                continue\n            include_match = include.search(root_relative_path) if include else True\n            if include_match:\n                yield child",
      "old_code": "def gen_python_files(\n    paths: Iterable[Path],\n    root: Path,\n    include: Pattern[str],\n    exclude: Pattern[str],\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    report: Report,\n    gitignore_dict: dict[Path, PathSpec] | None,\n    *,\n    verbose: bool,\n    quiet: bool,\n) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` whose paths are not excluded by the\n    `exclude_regex`, `extend_exclude`, or `force_exclude` regexes,\n    but are included by the `include` regex.\n\n    Symbolic links pointing outside of the `root` directory are ignored.\n\n    `report` is where output about exclusions goes.\n    \"\"\"\n\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    for child in paths:\n        assert child.is_absolute()\n        root_relative_path = child.relative_to(root).as_posix()\n\n        # First ignore files matching .gitignore, if passed\n        if gitignore_dict and _path_is_ignored(\n            root_relative_path, root, gitignore_dict\n        ):\n            report.path_ignored(child, \"matches a .gitignore file content\")\n            continue\n\n        # Then ignore with `--exclude` `--extend-exclude` and `--force-exclude` options.\n        root_relative_path = \"/\" + root_relative_path\n        if child.is_dir():\n            root_relative_path += \"/\"\n\n        if path_is_excluded(root_relative_path, exclude):\n            report.path_ignored(child, \"matches the --exclude regular expression\")\n            continue\n\n        if path_is_excluded(root_relative_path, extend_exclude):\n            report.path_ignored(\n                child, \"matches the --extend-exclude regular expression\"\n            )\n            continue\n\n        if path_is_excluded(root_relative_path, force_exclude):\n            report.path_ignored(child, \"matches the --force-exclude regular expression\")\n            continue\n\n        if resolves_outside_root_or_cannot_stat(child, root, report):\n            continue\n\n        if child.is_dir():\n            # If gitignore is None, gitignore usage is disabled, while a Falsey\n            # gitignore is when the directory doesn't have a .gitignore file.\n            if gitignore_dict is not None:\n                new_gitignore_dict = {\n                    **gitignore_dict,\n                    root / child: get_gitignore(child),\n                }\n            else:\n                new_gitignore_dict = None\n            yield from gen_python_files(\n                child.iterdir(),\n                root,\n                include,\n                exclude,\n                extend_exclude,\n                force_exclude,\n                report,\n                new_gitignore_dict,\n                verbose=verbose,\n                quiet=quiet,\n            )\n\n        elif child.is_file():\n            if child.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\n                warn=verbose or not quiet\n            ):\n                continue\n            include_match = include.search(root_relative_path) if include else True\n            if include_match:\n                yield child"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 31,
      "kind": "module",
      "qualname": "tests.test_black",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2517,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_gitignore_exclude",
      "span": [
        2512,
        2540
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_gitignore_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"exclude/\", \".definitely_exclude\", \"!exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)",
      "old_code": "    def test_gitignore_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\n            \"gitwildmatch\", [\"exclude/\", \".definitely_exclude\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2542,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_gitignore_reinclude",
      "span": [
        2542,
        2572
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_gitignore_reinclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"*/exclude/*\", \".definitely_exclude\", \"!*/exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)",
      "old_code": null
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2573,
      "kind": "class",
      "qualname": "tests.test_black.TestFileCollection",
      "span": [
        2469,
        2990
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "class TestFileCollection:\n    def test_include_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        assert_collected_sources(\n            src,\n            expected,\n            include=r\"\\.pyi?$\",\n            exclude=r\"/exclude/|/\\.definitely_exclude/\",\n        )\n\n    def test_gitignore_used_as_default(self) -> None:\n        base = Path(DATA_DIR / \"include_exclude_tests\")\n        expected = [\n            base / \"b/.definitely_exclude/a.py\",\n            base / \"b/.definitely_exclude/a.pyi\",\n        ]\n        src = [base / \"b/\"]\n        assert_collected_sources(src, expected, root=base, extend_exclude=r\"/exclude/\")\n\n    def test_gitignore_used_on_multiple_sources(self) -> None:\n        root = Path(DATA_DIR / \"gitignore_used_on_multiple_sources\")\n        expected = [\n            root / \"dir1\" / \"b.py\",\n            root / \"dir2\" / \"b.py\",\n        ]\n        src = [root / \"dir1\", root / \"dir2\"]\n        assert_collected_sources(src, expected, root=root)\n\n    @patch(\"black.find_project_root\", lambda *args: (THIS_DIR.resolve(), None))\n    def test_exclude_for_issue_1572(self) -> None:\n        # Exclude shouldn't touch files that were explicitly given to Black through the\n        # CLI. Exclude is supposed to only apply to the recursive discovery of files.\n        # https://github.com/psf/black/issues/1572\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path / \"b/exclude/a.py\"]\n        expected = [path / \"b/exclude/a.py\"]\n        assert_collected_sources(src, expected, include=\"\", exclude=r\"/exclude/|a\\.py\")\n\n    def test_gitignore_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"exclude/\", \".definitely_exclude\", \"!exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_gitignore_reinclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"*/exclude/*\", \".definitely_exclude\", \"!*/exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_gitignore_reinclude_root(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\" / \"b\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"exclude/*\", \".definitely_exclude\", \"!exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"dont_exclude/a.py\"),\n            Path(path / \"dont_exclude/a.pyi\"),\n            Path(path / \"exclude/still_exclude/a.py\"),\n            Path(path / \"exclude/still_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_nested_gitignore(self) -> None:\n        path = Path(THIS_DIR / \"data\" / \"nested_gitignore_tests\")\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        root_gitignore = black.files.get_gitignore(path)\n        report = black.Report()\n        expected: list[Path] = [\n            Path(path / \"x.py\"),\n            Path(path / \"root/b.py\"),\n            Path(path / \"root/c.py\"),\n            Path(path / \"root/child/c.py\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources = list(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: root_gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_nested_gitignore_directly_in_source_directory(self) -> None:\n        # https://github.com/psf/black/issues/2598\n        path = Path(DATA_DIR / \"nested_gitignore_tests\")\n        src = Path(path / \"root\" / \"child\")\n        expected = [src / \"a.py\", src / \"c.py\"]\n        assert_collected_sources([src], expected)\n\n    def test_invalid_gitignore(self) -> None:\n        path = THIS_DIR / \"data\" / \"invalid_gitignore_tests\"\n        empty_config = path / \"pyproject.toml\"\n        result = BlackRunner().invoke(\n            black.main, [\"--verbose\", \"--config\", str(empty_config), str(path)]\n        )\n        assert result.exit_code == 1\n        assert result.stderr_bytes is not None\n\n        gitignore = path / \".gitignore\"\n        assert re.search(\n            f\"Could not parse {gitignore}\".replace(\"\\\\\", \"\\\\\\\\\"),\n            result.stderr_bytes.decode(),\n            re.IGNORECASE if isinstance(gitignore, WindowsPath) else 0,\n        )\n\n    def test_invalid_nested_gitignore(self) -> None:\n        path = THIS_DIR / \"data\" / \"invalid_nested_gitignore_tests\"\n        empty_config = path / \"pyproject.toml\"\n        result = BlackRunner().invoke(\n            black.main, [\"--verbose\", \"--config\", str(empty_config), str(path)]\n        )\n        assert result.exit_code == 1\n        assert result.stderr_bytes is not None\n\n        gitignore = path / \"a\" / \".gitignore\"\n        assert re.search(\n            f\"Could not parse {gitignore}\".replace(\"\\\\\", \"\\\\\\\\\"),\n            result.stderr_bytes.decode(),\n            re.IGNORECASE if isinstance(gitignore, WindowsPath) else 0,\n        )\n\n    def test_gitignore_that_ignores_subfolders(self) -> None:\n        # If gitignore with */* is in root\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\" / \"subdir\")\n        expected = [root / \"b.py\"]\n        assert_collected_sources([root], expected, root=root)\n\n        # If .gitignore with */* is nested\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\")\n        expected = [\n            root / \"a.py\",\n            root / \"subdir\" / \"b.py\",\n        ]\n        assert_collected_sources([root], expected, root=root)\n\n        # If command is executed from outer dir\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\")\n        target = root / \"subdir\"\n        expected = [target / \"b.py\"]\n        assert_collected_sources([target], expected, root=root)\n\n    def test_gitignore_that_ignores_directory(self) -> None:\n        # If gitignore with a directory is in root\n        root = Path(DATA_DIR, \"ignore_directory_gitignore_tests\")\n        expected = [root / \"z.py\"]\n        assert_collected_sources([root], expected, root=root)\n\n    def test_empty_include(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.pie\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/exclude/still_exclude/a.pie\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.pyi\"),\n            Path(path / \"b/dont_exclude/a.pie\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.pie\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n            Path(path / \".gitignore\"),\n            Path(path / \"pyproject.toml\"),\n        ]\n        # Setting exclude explicitly to an empty string to block .gitignore usage.\n        assert_collected_sources(src, expected, include=\"\", exclude=\"\")\n\n    def test_include_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.pie\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"^/b/dont_exclude/a\\.pie$\", exclude=\"\"\n        )\n\n    def test_exclude_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"\\.py$\", exclude=r\"^/b/exclude/a\\.py$\"\n        )\n\n    def test_extend_exclude(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, exclude=r\"\\.pyi$\", extend_exclude=r\"\\.definitely_exclude\"\n        )\n\n    @pytest.mark.incompatible_with_mypyc\n    def test_symlinks(self) -> None:\n        root = THIS_DIR.resolve()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines([])\n\n        regular = MagicMock()\n        regular.relative_to.return_value = Path(\"regular.py\")\n        regular.resolve.return_value = root / \"regular.py\"\n        regular.is_dir.return_value = False\n        regular.is_file.return_value = True\n\n        outside_root_symlink = MagicMock()\n        outside_root_symlink.relative_to.return_value = Path(\"symlink.py\")\n        outside_root_symlink.resolve.return_value = Path(\"/nowhere\")\n        outside_root_symlink.is_dir.return_value = False\n        outside_root_symlink.is_file.return_value = True\n\n        ignored_symlink = MagicMock()\n        ignored_symlink.relative_to.return_value = Path(\".mypy_cache\") / \"symlink.py\"\n        ignored_symlink.is_dir.return_value = False\n        ignored_symlink.is_file.return_value = True\n\n        # A symlink that has an excluded name, but points to an included name\n        symlink_excluded_name = MagicMock()\n        symlink_excluded_name.relative_to.return_value = Path(\"excluded_name\")\n        symlink_excluded_name.resolve.return_value = root / \"included_name.py\"\n        symlink_excluded_name.is_dir.return_value = False\n        symlink_excluded_name.is_file.return_value = True\n\n        # A symlink that has an included name, but points to an excluded name\n        symlink_included_name = MagicMock()\n        symlink_included_name.relative_to.return_value = Path(\"included_name.py\")\n        symlink_included_name.resolve.return_value = root / \"excluded_name\"\n        symlink_included_name.is_dir.return_value = False\n        symlink_included_name.is_file.return_value = True\n\n        path = MagicMock()\n        path.iterdir.return_value = [\n            regular,\n            outside_root_symlink,\n            ignored_symlink,\n            symlink_excluded_name,\n            symlink_included_name,\n        ]\n\n        files = list(\n            black.gen_python_files(\n                path.iterdir(),\n                root,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert files == [regular, symlink_included_name]\n\n        path.iterdir.assert_called_once()\n        outside_root_symlink.resolve.assert_called_once()\n        ignored_symlink.resolve.assert_not_called()\n\n    def test_get_sources_symlink_and_force_exclude(self) -> None:\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n            actual = tmp / \"actual\"\n            actual.mkdir()\n            symlink = tmp / \"symlink\"\n            symlink.symlink_to(actual)\n\n            actual_proj = actual / \"project\"\n            actual_proj.mkdir()\n            (actual_proj / \"module.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n\n            symlink_proj = symlink / \"project\"\n\n            with change_directory(symlink_proj):\n                assert_collected_sources(\n                    src=[\"module.py\"],\n                    root=symlink_proj.resolve(),\n                    expected=[\"module.py\"],\n                )\n\n                absolute_module = symlink_proj / \"module.py\"\n                assert_collected_sources(\n                    src=[absolute_module],\n                    root=symlink_proj.resolve(),\n                    expected=[absolute_module],\n                )\n\n                # a few tricky tests for force_exclude\n                flat_symlink = symlink_proj / \"symlink_module.py\"\n                flat_symlink.symlink_to(actual_proj / \"module.py\")\n                assert_collected_sources(\n                    src=[flat_symlink],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"/symlink_module.py\",\n                    expected=[],\n                )\n\n                target = actual_proj / \"target\"\n                target.mkdir()\n                (target / \"another.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n                (symlink_proj / \"nested\").symlink_to(target)\n\n                assert_collected_sources(\n                    src=[symlink_proj / \"nested\" / \"another.py\"],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"nested\",\n                    expected=[],\n                )\n                assert_collected_sources(\n                    src=[symlink_proj / \"nested\" / \"another.py\"],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"target\",\n                    expected=[symlink_proj / \"nested\" / \"another.py\"],\n                )\n\n    def test_get_sources_with_stdin_symlink_outside_root(\n        self,\n    ) -> None:\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n\n            root = tmp / \"root\"\n            root.mkdir()\n            (root / \"pyproject.toml\").write_text(\"[tool.black]\", encoding=\"utf-8\")\n\n            target = tmp / \"outside_root\" / \"a.py\"\n            target.parent.mkdir()\n            target.write_text(\"print('hello')\", encoding=\"utf-8\")\n            (root / \"a.py\").symlink_to(target)\n\n            stdin_filename = str(root / \"a.py\")\n            assert_collected_sources(\n                root=root,\n                src=[\"-\"],\n                expected=[],\n                stdin_filename=stdin_filename,\n            )\n\n    def test_get_sources_with_stdin(self) -> None:\n        src = [\"-\"]\n        expected = [\"-\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            include=\"\",\n            exclude=r\"/exclude/|a\\.py\",\n        )\n\n    def test_get_sources_with_stdin_filename(self) -> None:\n        src = [\"-\"]\n        stdin_filename = str(THIS_DIR / \"data/collections.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            exclude=r\"/exclude/a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_exclude(self) -> None:\n        # Exclude shouldn't exclude stdin_filename since it is mimicking the\n        # file being passed directly. This is the same as\n        # test_exclude_for_issue_1572\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [\"-\"]\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_extend_exclude(self) -> None:\n        # Extend exclude shouldn't exclude stdin_filename since it is mimicking the\n        # file being passed directly. This is the same as\n        # test_exclude_for_issue_1572\n        src = [\"-\"]\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            extend_exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_force_exclude(self) -> None:\n        # Force exclude should exclude the file when passing it through\n        # stdin_filename\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        assert_collected_sources(\n            src=[\"-\"],\n            root=THIS_DIR.resolve(),\n            expected=[],\n            force_exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_force_exclude_and_symlink(\n        self,\n    ) -> None:\n        # Force exclude should exclude a symlink based on the symlink, not its target\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n            (tmp / \"exclude\").mkdir()\n            (tmp / \"exclude\" / \"a.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n            (tmp / \"symlink.py\").symlink_to(tmp / \"exclude\" / \"a.py\")\n\n            stdin_filename = str(tmp / \"symlink.py\")\n            expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n            with change_directory(tmp):\n                assert_collected_sources(\n                    src=[\"-\"],\n                    root=tmp,\n                    expected=expected,\n                    force_exclude=r\"exclude/a\\.py\",\n                    stdin_filename=stdin_filename,\n                )",
      "old_code": "class TestFileCollection:\n    def test_include_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        assert_collected_sources(\n            src,\n            expected,\n            include=r\"\\.pyi?$\",\n            exclude=r\"/exclude/|/\\.definitely_exclude/\",\n        )\n\n    def test_gitignore_used_as_default(self) -> None:\n        base = Path(DATA_DIR / \"include_exclude_tests\")\n        expected = [\n            base / \"b/.definitely_exclude/a.py\",\n            base / \"b/.definitely_exclude/a.pyi\",\n        ]\n        src = [base / \"b/\"]\n        assert_collected_sources(src, expected, root=base, extend_exclude=r\"/exclude/\")\n\n    def test_gitignore_used_on_multiple_sources(self) -> None:\n        root = Path(DATA_DIR / \"gitignore_used_on_multiple_sources\")\n        expected = [\n            root / \"dir1\" / \"b.py\",\n            root / \"dir2\" / \"b.py\",\n        ]\n        src = [root / \"dir1\", root / \"dir2\"]\n        assert_collected_sources(src, expected, root=root)\n\n    @patch(\"black.find_project_root\", lambda *args: (THIS_DIR.resolve(), None))\n    def test_exclude_for_issue_1572(self) -> None:\n        # Exclude shouldn't touch files that were explicitly given to Black through the\n        # CLI. Exclude is supposed to only apply to the recursive discovery of files.\n        # https://github.com/psf/black/issues/1572\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path / \"b/exclude/a.py\"]\n        expected = [path / \"b/exclude/a.py\"]\n        assert_collected_sources(src, expected, include=\"\", exclude=r\"/exclude/|a\\.py\")\n\n    def test_gitignore_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\n            \"gitwildmatch\", [\"exclude/\", \".definitely_exclude\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_nested_gitignore(self) -> None:\n        path = Path(THIS_DIR / \"data\" / \"nested_gitignore_tests\")\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        root_gitignore = black.files.get_gitignore(path)\n        report = black.Report()\n        expected: list[Path] = [\n            Path(path / \"x.py\"),\n            Path(path / \"root/b.py\"),\n            Path(path / \"root/c.py\"),\n            Path(path / \"root/child/c.py\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources = list(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: root_gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)\n\n    def test_nested_gitignore_directly_in_source_directory(self) -> None:\n        # https://github.com/psf/black/issues/2598\n        path = Path(DATA_DIR / \"nested_gitignore_tests\")\n        src = Path(path / \"root\" / \"child\")\n        expected = [src / \"a.py\", src / \"c.py\"]\n        assert_collected_sources([src], expected)\n\n    def test_invalid_gitignore(self) -> None:\n        path = THIS_DIR / \"data\" / \"invalid_gitignore_tests\"\n        empty_config = path / \"pyproject.toml\"\n        result = BlackRunner().invoke(\n            black.main, [\"--verbose\", \"--config\", str(empty_config), str(path)]\n        )\n        assert result.exit_code == 1\n        assert result.stderr_bytes is not None\n\n        gitignore = path / \".gitignore\"\n        assert re.search(\n            f\"Could not parse {gitignore}\".replace(\"\\\\\", \"\\\\\\\\\"),\n            result.stderr_bytes.decode(),\n            re.IGNORECASE if isinstance(gitignore, WindowsPath) else 0,\n        )\n\n    def test_invalid_nested_gitignore(self) -> None:\n        path = THIS_DIR / \"data\" / \"invalid_nested_gitignore_tests\"\n        empty_config = path / \"pyproject.toml\"\n        result = BlackRunner().invoke(\n            black.main, [\"--verbose\", \"--config\", str(empty_config), str(path)]\n        )\n        assert result.exit_code == 1\n        assert result.stderr_bytes is not None\n\n        gitignore = path / \"a\" / \".gitignore\"\n        assert re.search(\n            f\"Could not parse {gitignore}\".replace(\"\\\\\", \"\\\\\\\\\"),\n            result.stderr_bytes.decode(),\n            re.IGNORECASE if isinstance(gitignore, WindowsPath) else 0,\n        )\n\n    def test_gitignore_that_ignores_subfolders(self) -> None:\n        # If gitignore with */* is in root\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\" / \"subdir\")\n        expected = [root / \"b.py\"]\n        assert_collected_sources([root], expected, root=root)\n\n        # If .gitignore with */* is nested\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\")\n        expected = [\n            root / \"a.py\",\n            root / \"subdir\" / \"b.py\",\n        ]\n        assert_collected_sources([root], expected, root=root)\n\n        # If command is executed from outer dir\n        root = Path(DATA_DIR / \"ignore_subfolders_gitignore_tests\")\n        target = root / \"subdir\"\n        expected = [target / \"b.py\"]\n        assert_collected_sources([target], expected, root=root)\n\n    def test_gitignore_that_ignores_directory(self) -> None:\n        # If gitignore with a directory is in root\n        root = Path(DATA_DIR, \"ignore_directory_gitignore_tests\")\n        expected = [root / \"z.py\"]\n        assert_collected_sources([root], expected, root=root)\n\n    def test_empty_include(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.pie\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/dont_exclude/a.pie\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.pie\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n            Path(path / \".gitignore\"),\n            Path(path / \"pyproject.toml\"),\n        ]\n        # Setting exclude explicitly to an empty string to block .gitignore usage.\n        assert_collected_sources(src, expected, include=\"\", exclude=\"\")\n\n    def test_include_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.pie\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"^/b/dont_exclude/a\\.pie$\", exclude=\"\"\n        )\n\n    def test_exclude_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"\\.py$\", exclude=r\"^/b/exclude/a\\.py$\"\n        )\n\n    def test_extend_exclude(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, exclude=r\"\\.pyi$\", extend_exclude=r\"\\.definitely_exclude\"\n        )\n\n    @pytest.mark.incompatible_with_mypyc\n    def test_symlinks(self) -> None:\n        root = THIS_DIR.resolve()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n\n        regular = MagicMock()\n        regular.relative_to.return_value = Path(\"regular.py\")\n        regular.resolve.return_value = root / \"regular.py\"\n        regular.is_dir.return_value = False\n        regular.is_file.return_value = True\n\n        outside_root_symlink = MagicMock()\n        outside_root_symlink.relative_to.return_value = Path(\"symlink.py\")\n        outside_root_symlink.resolve.return_value = Path(\"/nowhere\")\n        outside_root_symlink.is_dir.return_value = False\n        outside_root_symlink.is_file.return_value = True\n\n        ignored_symlink = MagicMock()\n        ignored_symlink.relative_to.return_value = Path(\".mypy_cache\") / \"symlink.py\"\n        ignored_symlink.is_dir.return_value = False\n        ignored_symlink.is_file.return_value = True\n\n        # A symlink that has an excluded name, but points to an included name\n        symlink_excluded_name = MagicMock()\n        symlink_excluded_name.relative_to.return_value = Path(\"excluded_name\")\n        symlink_excluded_name.resolve.return_value = root / \"included_name.py\"\n        symlink_excluded_name.is_dir.return_value = False\n        symlink_excluded_name.is_file.return_value = True\n\n        # A symlink that has an included name, but points to an excluded name\n        symlink_included_name = MagicMock()\n        symlink_included_name.relative_to.return_value = Path(\"included_name.py\")\n        symlink_included_name.resolve.return_value = root / \"excluded_name\"\n        symlink_included_name.is_dir.return_value = False\n        symlink_included_name.is_file.return_value = True\n\n        path = MagicMock()\n        path.iterdir.return_value = [\n            regular,\n            outside_root_symlink,\n            ignored_symlink,\n            symlink_excluded_name,\n            symlink_included_name,\n        ]\n\n        files = list(\n            black.gen_python_files(\n                path.iterdir(),\n                root,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert files == [regular, symlink_included_name]\n\n        path.iterdir.assert_called_once()\n        outside_root_symlink.resolve.assert_called_once()\n        ignored_symlink.resolve.assert_not_called()\n\n    def test_get_sources_symlink_and_force_exclude(self) -> None:\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n            actual = tmp / \"actual\"\n            actual.mkdir()\n            symlink = tmp / \"symlink\"\n            symlink.symlink_to(actual)\n\n            actual_proj = actual / \"project\"\n            actual_proj.mkdir()\n            (actual_proj / \"module.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n\n            symlink_proj = symlink / \"project\"\n\n            with change_directory(symlink_proj):\n                assert_collected_sources(\n                    src=[\"module.py\"],\n                    root=symlink_proj.resolve(),\n                    expected=[\"module.py\"],\n                )\n\n                absolute_module = symlink_proj / \"module.py\"\n                assert_collected_sources(\n                    src=[absolute_module],\n                    root=symlink_proj.resolve(),\n                    expected=[absolute_module],\n                )\n\n                # a few tricky tests for force_exclude\n                flat_symlink = symlink_proj / \"symlink_module.py\"\n                flat_symlink.symlink_to(actual_proj / \"module.py\")\n                assert_collected_sources(\n                    src=[flat_symlink],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"/symlink_module.py\",\n                    expected=[],\n                )\n\n                target = actual_proj / \"target\"\n                target.mkdir()\n                (target / \"another.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n                (symlink_proj / \"nested\").symlink_to(target)\n\n                assert_collected_sources(\n                    src=[symlink_proj / \"nested\" / \"another.py\"],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"nested\",\n                    expected=[],\n                )\n                assert_collected_sources(\n                    src=[symlink_proj / \"nested\" / \"another.py\"],\n                    root=symlink_proj.resolve(),\n                    force_exclude=r\"target\",\n                    expected=[symlink_proj / \"nested\" / \"another.py\"],\n                )\n\n    def test_get_sources_with_stdin_symlink_outside_root(\n        self,\n    ) -> None:\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n\n            root = tmp / \"root\"\n            root.mkdir()\n            (root / \"pyproject.toml\").write_text(\"[tool.black]\", encoding=\"utf-8\")\n\n            target = tmp / \"outside_root\" / \"a.py\"\n            target.parent.mkdir()\n            target.write_text(\"print('hello')\", encoding=\"utf-8\")\n            (root / \"a.py\").symlink_to(target)\n\n            stdin_filename = str(root / \"a.py\")\n            assert_collected_sources(\n                root=root,\n                src=[\"-\"],\n                expected=[],\n                stdin_filename=stdin_filename,\n            )\n\n    def test_get_sources_with_stdin(self) -> None:\n        src = [\"-\"]\n        expected = [\"-\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            include=\"\",\n            exclude=r\"/exclude/|a\\.py\",\n        )\n\n    def test_get_sources_with_stdin_filename(self) -> None:\n        src = [\"-\"]\n        stdin_filename = str(THIS_DIR / \"data/collections.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            exclude=r\"/exclude/a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_exclude(self) -> None:\n        # Exclude shouldn't exclude stdin_filename since it is mimicking the\n        # file being passed directly. This is the same as\n        # test_exclude_for_issue_1572\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [\"-\"]\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_extend_exclude(self) -> None:\n        # Extend exclude shouldn't exclude stdin_filename since it is mimicking the\n        # file being passed directly. This is the same as\n        # test_exclude_for_issue_1572\n        src = [\"-\"]\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n        assert_collected_sources(\n            src,\n            root=THIS_DIR.resolve(),\n            expected=expected,\n            extend_exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_force_exclude(self) -> None:\n        # Force exclude should exclude the file when passing it through\n        # stdin_filename\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        stdin_filename = str(path / \"b/exclude/a.py\")\n        assert_collected_sources(\n            src=[\"-\"],\n            root=THIS_DIR.resolve(),\n            expected=[],\n            force_exclude=r\"/exclude/|a\\.py\",\n            stdin_filename=stdin_filename,\n        )\n\n    def test_get_sources_with_stdin_filename_and_force_exclude_and_symlink(\n        self,\n    ) -> None:\n        # Force exclude should exclude a symlink based on the symlink, not its target\n        with TemporaryDirectory() as tempdir:\n            tmp = Path(tempdir).resolve()\n            (tmp / \"exclude\").mkdir()\n            (tmp / \"exclude\" / \"a.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n            (tmp / \"symlink.py\").symlink_to(tmp / \"exclude\" / \"a.py\")\n\n            stdin_filename = str(tmp / \"symlink.py\")\n            expected = [f\"__BLACK_STDIN_FILENAME__{stdin_filename}\"]\n            with change_directory(tmp):\n                assert_collected_sources(\n                    src=[\"-\"],\n                    root=tmp,\n                    expected=expected,\n                    force_exclude=r\"exclude/a\\.py\",\n                    stdin_filename=stdin_filename,\n                )"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2574,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_gitignore_reinclude_root",
      "span": [
        2574,
        2604
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_gitignore_reinclude_root(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\" / \"b\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines(\n            [\"exclude/*\", \".definitely_exclude\", \"!exclude/still_exclude/\"]\n        )\n        sources: list[Path] = []\n        expected = [\n            Path(path / \"dont_exclude/a.py\"),\n            Path(path / \"dont_exclude/a.pyi\"),\n            Path(path / \"exclude/still_exclude/a.py\"),\n            Path(path / \"exclude/still_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files(\n                path.iterdir(),\n                this_abs,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert sorted(expected) == sorted(sources)",
      "old_code": null
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2707,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_empty_include",
      "span": [
        2700,
        2720
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_empty_include(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.pie\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/exclude/still_exclude/a.pie\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.pyi\"),\n            Path(path / \"b/dont_exclude/a.pie\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.pie\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n            Path(path / \".gitignore\"),\n            Path(path / \"pyproject.toml\"),\n        ]\n        # Setting exclude explicitly to an empty string to block .gitignore usage.\n        assert_collected_sources(src, expected, include=\"\", exclude=\"\")",
      "old_code": "    def test_empty_include(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.pie\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/dont_exclude/a.pie\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.pie\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n            Path(path / \".gitignore\"),\n            Path(path / \"pyproject.toml\"),\n        ]\n        # Setting exclude explicitly to an empty string to block .gitignore usage.\n        assert_collected_sources(src, expected, include=\"\", exclude=\"\")"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2737,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_exclude_absolute_path",
      "span": [
        2732,
        2742
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_exclude_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"\\.py$\", exclude=r\"^/b/exclude/a\\.py$\"\n        )",
      "old_code": "    def test_exclude_absolute_path(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, root=path, include=r\"\\.py$\", exclude=r\"^/b/exclude/a\\.py$\"\n        )"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2749,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_extend_exclude",
      "span": [
        2744,
        2754
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_extend_exclude(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/still_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, exclude=r\"\\.pyi$\", extend_exclude=r\"\\.definitely_exclude\"\n        )",
      "old_code": "    def test_extend_exclude(self) -> None:\n        path = DATA_DIR / \"include_exclude_tests\"\n        src = [path]\n        expected = [\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n        ]\n        assert_collected_sources(\n            src, expected, exclude=r\"\\.pyi$\", extend_exclude=r\"\\.definitely_exclude\"\n        )"
    },
    {
      "path": "tests/test_black.py",
      "version": "new",
      "line": 2762,
      "kind": "function",
      "qualname": "tests.test_black.TestFileCollection.test_symlinks",
      "span": [
        2757,
        2822
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_symlinks(self) -> None:\n        root = THIS_DIR.resolve()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n        gitignore = GitIgnoreSpec.from_lines([])\n\n        regular = MagicMock()\n        regular.relative_to.return_value = Path(\"regular.py\")\n        regular.resolve.return_value = root / \"regular.py\"\n        regular.is_dir.return_value = False\n        regular.is_file.return_value = True\n\n        outside_root_symlink = MagicMock()\n        outside_root_symlink.relative_to.return_value = Path(\"symlink.py\")\n        outside_root_symlink.resolve.return_value = Path(\"/nowhere\")\n        outside_root_symlink.is_dir.return_value = False\n        outside_root_symlink.is_file.return_value = True\n\n        ignored_symlink = MagicMock()\n        ignored_symlink.relative_to.return_value = Path(\".mypy_cache\") / \"symlink.py\"\n        ignored_symlink.is_dir.return_value = False\n        ignored_symlink.is_file.return_value = True\n\n        # A symlink that has an excluded name, but points to an included name\n        symlink_excluded_name = MagicMock()\n        symlink_excluded_name.relative_to.return_value = Path(\"excluded_name\")\n        symlink_excluded_name.resolve.return_value = root / \"included_name.py\"\n        symlink_excluded_name.is_dir.return_value = False\n        symlink_excluded_name.is_file.return_value = True\n\n        # A symlink that has an included name, but points to an excluded name\n        symlink_included_name = MagicMock()\n        symlink_included_name.relative_to.return_value = Path(\"included_name.py\")\n        symlink_included_name.resolve.return_value = root / \"excluded_name\"\n        symlink_included_name.is_dir.return_value = False\n        symlink_included_name.is_file.return_value = True\n\n        path = MagicMock()\n        path.iterdir.return_value = [\n            regular,\n            outside_root_symlink,\n            ignored_symlink,\n            symlink_excluded_name,\n            symlink_included_name,\n        ]\n\n        files = list(\n            black.gen_python_files(\n                path.iterdir(),\n                root,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert files == [regular, symlink_included_name]\n\n        path.iterdir.assert_called_once()\n        outside_root_symlink.resolve.assert_called_once()\n        ignored_symlink.resolve.assert_not_called()",
      "old_code": "    def test_symlinks(self) -> None:\n        root = THIS_DIR.resolve()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n\n        regular = MagicMock()\n        regular.relative_to.return_value = Path(\"regular.py\")\n        regular.resolve.return_value = root / \"regular.py\"\n        regular.is_dir.return_value = False\n        regular.is_file.return_value = True\n\n        outside_root_symlink = MagicMock()\n        outside_root_symlink.relative_to.return_value = Path(\"symlink.py\")\n        outside_root_symlink.resolve.return_value = Path(\"/nowhere\")\n        outside_root_symlink.is_dir.return_value = False\n        outside_root_symlink.is_file.return_value = True\n\n        ignored_symlink = MagicMock()\n        ignored_symlink.relative_to.return_value = Path(\".mypy_cache\") / \"symlink.py\"\n        ignored_symlink.is_dir.return_value = False\n        ignored_symlink.is_file.return_value = True\n\n        # A symlink that has an excluded name, but points to an included name\n        symlink_excluded_name = MagicMock()\n        symlink_excluded_name.relative_to.return_value = Path(\"excluded_name\")\n        symlink_excluded_name.resolve.return_value = root / \"included_name.py\"\n        symlink_excluded_name.is_dir.return_value = False\n        symlink_excluded_name.is_file.return_value = True\n\n        # A symlink that has an included name, but points to an excluded name\n        symlink_included_name = MagicMock()\n        symlink_included_name.relative_to.return_value = Path(\"included_name.py\")\n        symlink_included_name.resolve.return_value = root / \"excluded_name\"\n        symlink_included_name.is_dir.return_value = False\n        symlink_included_name.is_file.return_value = True\n\n        path = MagicMock()\n        path.iterdir.return_value = [\n            regular,\n            outside_root_symlink,\n            ignored_symlink,\n            symlink_excluded_name,\n            symlink_included_name,\n        ]\n\n        files = list(\n            black.gen_python_files(\n                path.iterdir(),\n                root,\n                include,\n                exclude,\n                None,\n                None,\n                report,\n                {path: gitignore},\n                verbose=False,\n                quiet=False,\n            )\n        )\n        assert files == [regular, symlink_included_name]\n\n        path.iterdir.assert_called_once()\n        outside_root_symlink.resolve.assert_called_once()\n        ignored_symlink.resolve.assert_not_called()"
    }
  ],
  "generated_at": "2026-02-11T16:05:40"
}