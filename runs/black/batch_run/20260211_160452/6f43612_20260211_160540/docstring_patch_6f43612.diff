--- a/src/black/files.py
+++ b/src/black/files.py
@@ -239,7 +239,11 @@
 
 @lru_cache
 def get_gitignore(root: Path) -> GitIgnoreSpec:
-    """Return a GitIgnoreSpec matching gitignore content if present."""
+    """TODO: docstring
+
+    Args:
+        root:
+    """
     gitignore = root / ".gitignore"
     lines: list[str] = []
     if gitignore.is_file():
@@ -294,6 +298,13 @@
     root: Path,
     gitignore_dict: dict[Path, GitIgnoreSpec],
 ) -> bool:
+    """TODO: docstring
+
+    Args:
+        root_relative_path:
+        root:
+        gitignore_dict:
+    """
     path = root / root_relative_path
     # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must
     # ensure that gitignore_dict is ordered from least specific to most specific.
@@ -330,13 +341,19 @@
     verbose: bool,
     quiet: bool,
 ) -> Iterator[Path]:
-    """Generate all files under `path` whose paths are not excluded by the
-    `exclude_regex`, `extend_exclude`, or `force_exclude` regexes,
-    but are included by the `include` regex.
-
-    Symbolic links pointing outside of the `root` directory are ignored.
-
-    `report` is where output about exclusions goes.
+    """TODO: docstring
+
+    Args:
+        paths:
+        root:
+        include:
+        exclude:
+        extend_exclude:
+        force_exclude:
+        report:
+        gitignore_dict:
+        verbose:
+        quiet:
     """
 
     assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
