--- a/scripts/release_tests.py
+++ b/scripts/release_tests.py
@@ -14,10 +14,22 @@
     """Used to mock the date to test generating next calver function"""
 
     def today(*args: Any, **kwargs: Any) -> "FakeDateTime":  # noqa: B902
+        """TODO: docstring
+
+        Args:
+            *args:
+            **kwargs:
+        """
         return FakeDateTime()
 
     # Add leading 0 on purpose to ensure we remove it
     def strftime(*args: Any, **kwargs: Any) -> str:  # noqa: B902
+        """TODO: docstring
+
+        Args:
+            *args:
+            **kwargs:
+        """
         return "69.01"
 
 

--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -698,11 +698,12 @@
 def transform_line(
     line: Line, mode: Mode, features: Collection[Feature] = ()
 ) -> Iterator[Line]:
-    """Transform a `line`, potentially splitting it into many lines.
-
-    They should fit in the allotted `line_length` but might not be able to.
-
-    `features` are syntactical features that may be used in the output.
+    """TODO: docstring
+
+    Args:
+        line:
+        mode:
+        features:
     """
     if line.is_comment:
         yield line
@@ -747,11 +748,12 @@
         def _rhs(
             self: object, line: Line, features: Collection[Feature], mode: Mode
         ) -> Iterator[Line]:
-            """Wraps calls to `right_hand_split`.
-
-            The calls increasingly `omit` right-hand trailers (bracket pairs with
-            content), meaning the trailers get glued together to split on another
-            bracket pair instead.
+            """TODO: docstring
+
+            Args:
+                line:
+                features:
+                mode:
             """
             for omit in generate_trailers_to_omit(line, mode.line_length):
                 lines = list(right_hand_split(line, mode, features, omit=omit))
@@ -947,11 +949,11 @@
     line: Line,
     omit: Collection[LeafID] = (),
 ) -> RHSResult:
-    """Split the line into head, body, tail starting with the last bracket pair.
-
-    Note: this function should not have side effects. It's relied upon by
-    _maybe_split_omitting_optional_parens to get an opinion whether to prefer
-    splitting on the right side of an assignment statement.
+    """TODO: docstring
+
+    Args:
+        line:
+        omit:
     """
     tail_leaves: list[Leaf] = []
     body_leaves: list[Leaf] = []
@@ -1053,6 +1055,15 @@
     features: Collection[Feature] = (),
     omit: Collection[LeafID] = (),
 ) -> Iterator[Line]:
+    """TODO: docstring
+
+    Args:
+        rhs:
+        line:
+        mode:
+        features:
+        omit:
+    """
     if (
         Feature.FORCE_OPTIONAL_PARENTHESES not in features
         # the opening bracket is an optional paren
@@ -1117,9 +1128,12 @@
 def _prefer_split_rhs_oop_over_rhs(
     rhs_oop: RHSResult, rhs: RHSResult, mode: Mode
 ) -> bool:
-    """
-    Returns whether we should prefer the result from a split omitting optional parens
-    (rhs_oop) over the original (rhs).
+    """TODO: docstring
+
+    Args:
+        rhs_oop:
+        rhs:
+        mode:
     """
     # contains unsplittable type ignore
     if (
@@ -1475,13 +1489,13 @@
 def normalize_invisible_parens(
     node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]
 ) -> None:
-    """Make existing optional parentheses invisible or create new ones.
-
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    """TODO: docstring
+
+    Args:
+        node:
+        parens_after:
+        mode:
+        features:
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if pc.value in FMT_OFF:
@@ -2002,6 +2016,15 @@
     *,
     line_str: str = "",
 ) -> list[Line]:
+    """TODO: docstring
+
+    Args:
+        line:
+        transform:
+        mode:
+        features:
+        line_str:
+    """
     if not line_str:
         line_str = line_to_string(line)
     result: list[Line] = []

--- a/src/black/lines.py
+++ b/src/black/lines.py
@@ -53,14 +53,12 @@
     def append(
         self, leaf: Leaf, preformatted: bool = False, track_bracket: bool = False
     ) -> None:
-        """Add a new `leaf` to the end of the line.
-
-        Unless `preformatted` is True, the `leaf` will receive a new consistent
-        whitespace prefix and metadata applied by :class:`BracketTracker`.
-        Trailing commas are maybe removed, unpacked for loop variables are
-        demoted from being delimiters.
-
-        Inline comments are put aside.
+        """TODO: docstring
+
+        Args:
+            leaf:
+            preformatted:
+            track_bracket:
         """
         has_value = (
             leaf.type in BRACKETS
@@ -92,10 +90,11 @@
             self.leaves.append(leaf)
 
     def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
-        """Like :func:`append()` but disallow invalid standalone comment structure.
-
-        Raises ValueError when any `leaf` is appended after a standalone comment
-        or when a standalone comment is not the first leaf on the line.
+        """TODO: docstring
+
+        Args:
+            leaf:
+            preformatted:
         """
         if (
             self.bracket_tracker.depth == 0
@@ -546,10 +545,10 @@
     semantic_leading_comment: LinesBlock | None = None
 
     def maybe_empty_lines(self, current_line: Line) -> LinesBlock:
-        """Return the number of extra empty lines before and after the `current_line`.
-
-        This is for separating `def`, `async def` and `class` with extra empty
-        lines (two on module-level).
+        """TODO: docstring
+
+        Args:
+            current_line:
         """
         form_feed = (
             current_line.depth == 0
@@ -617,6 +616,11 @@
         return True
 
     def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:
+        """TODO: docstring
+
+        Args:
+            current_line:
+        """
         max_allowed = 1
         if current_line.depth == 0:
             max_allowed = 1 if self.mode.is_pyi else 2
@@ -712,6 +716,13 @@
     def _maybe_empty_lines_for_class_or_def(
         self, current_line: Line, before: int, user_had_newline: bool
     ) -> tuple[int, int]:
+        """TODO: docstring
+
+        Args:
+            current_line:
+            before:
+            user_had_newline:
+        """
         assert self.previous_line is not None
 
         if self.previous_line.is_decorator:
@@ -823,10 +834,12 @@
 
 
 def is_line_short_enough(line: Line, *, mode: Mode, line_str: str = "") -> bool:
-    """For non-multiline strings, return True if `line` is no longer than `line_length`.
-    For multiline strings, looks at the context around `line` to determine
-    if it should be inlined or split up.
-    Uses the provided `line_str` rendering, if any, otherwise computes a new one.
+    """TODO: docstring
+
+    Args:
+        line:
+        mode:
+        line_str:
     """
     if not line_str:
         line_str = line_to_string(line)

--- a/src/black/nodes.py
+++ b/src/black/nodes.py
@@ -178,10 +178,12 @@
 
 
 def whitespace(leaf: Leaf, *, complex_subscript: bool, mode: Mode) -> str:
-    """Return whitespace prefix if needed for the given `leaf`.
-
-    `complex_subscript` signals whether the given leaf is part of a subscription
-    which has non-trivial arguments, like arithmetic expressions or function calls.
+    """TODO: docstring
+
+    Args:
+        leaf:
+        complex_subscript:
+        mode:
     """
     NO: Final[str] = ""
     SPACE: Final[str] = " "

--- a/src/black/parsing.py
+++ b/src/black/parsing.py
@@ -167,19 +167,36 @@
 
 
 def stringify_ast(node: ast.AST) -> Iterator[str]:
-    """Simple visitor generating strings to compare ASTs by content."""
+    """TODO: docstring
+
+    Args:
+        node:
+    """
     return _stringify_ast(node, [])
 
 
 def _stringify_ast_with_new_parent(
     node: ast.AST, parent_stack: list[ast.AST], new_parent: ast.AST
 ) -> Iterator[str]:
+    """TODO: docstring
+
+    Args:
+        node:
+        parent_stack:
+        new_parent:
+    """
     parent_stack.append(new_parent)
     yield from _stringify_ast(node, parent_stack)
     parent_stack.pop()
 
 
 def _stringify_ast(node: ast.AST, parent_stack: list[ast.AST]) -> Iterator[str]:
+    """TODO: docstring
+
+    Args:
+        node:
+        parent_stack:
+    """
     if (
         isinstance(node, ast.Constant)
         and isinstance(node.value, str)

--- a/scripts/release.py
+++ b/scripts/release.py
@@ -97,6 +97,11 @@
 class SourceFiles:
     def __init__(self, black_repo_dir: Path):
         # File path fun all pathlib to be platform agnostic
+        """TODO: docstring
+
+        Args:
+            black_repo_dir:
+        """
         self.black_repo_path = black_repo_dir
         self.changes_path = self.black_repo_path / "CHANGES.md"
         self.docs_path = self.black_repo_path / "docs"
@@ -166,7 +171,7 @@
         return sorted(get_git_tags(), key=lambda k: tuple_calver(k))[-1]
 
     def get_next_version(self) -> str:
-        """Workout the year and month + version number we need to move to"""
+        """TODO: docstring"""
         base_calver = datetime.today().strftime("%y.%m")
         calver_parts = base_calver.split(".")
         base_calver = f"{calver_parts[0]}.{int(calver_parts[1])}"  # Remove leading 0
