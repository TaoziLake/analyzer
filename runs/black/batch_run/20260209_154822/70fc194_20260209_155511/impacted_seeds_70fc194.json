{
  "commit": "70fc194",
  "parent": "7044b145f4826e0d6e07178d89666856a8e37aff",
  "repo": "D:\\locbench\\black",
  "num_files_in_diff": 4,
  "num_py_files_in_diff": 3,
  "num_seeds": 5,
  "seeds": [
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 648,
      "kind": "function",
      "qualname": "src.black.comments._generate_ignored_nodes_from_fmt_skip",
      "span": [
        634,
        770
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _generate_ignored_nodes_from_fmt_skip(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.\"\"\"\n    prev_sibling = leaf.prev_sibling\n    parent = leaf.parent\n    ignored_nodes: list[LN] = []\n    # Need to properly format the leaf prefix to compare it to comment.value,\n    # which is also formatted\n    comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n    if not comments or comment.value != comments[0].value:\n        return\n\n    if Preview.fix_fmt_skip_in_one_liners in mode and not prev_sibling and parent:\n        prev_sibling = parent.prev_sibling\n\n    if prev_sibling is not None:\n        leaf.prefix = leaf.prefix[comment.consumed :]\n\n        if Preview.fix_fmt_skip_in_one_liners not in mode:\n            siblings = [prev_sibling]\n            while (\n                \"\\n\" not in prev_sibling.prefix\n                and prev_sibling.prev_sibling is not None\n            ):\n                prev_sibling = prev_sibling.prev_sibling\n                siblings.insert(0, prev_sibling)\n            yield from siblings\n            return\n\n        # Generates the nodes to be ignored by `fmt: skip`.\n\n        # Nodes to ignore are the ones on the same line as the\n        # `# fmt: skip` comment, excluding the `# fmt: skip`\n        # node itself.\n\n        # Traversal process (starting at the `# fmt: skip` node):\n        # 1. Move to the `prev_sibling` of the current node.\n        # 2. If `prev_sibling` has children, go to its rightmost leaf.\n        # 3. If there's no `prev_sibling`, move up to the parent\n        # node and repeat.\n        # 4. Continue until:\n        #    a. You encounter an `INDENT` or `NEWLINE` node (indicates\n        #       start of the line).\n        #    b. You reach the root node.\n\n        # Include all visited LEAVES in the ignored list, except INDENT\n        # or NEWLINE leaves.\n\n        current_node = prev_sibling\n        ignored_nodes = [current_node]\n        if current_node.prev_sibling is None and current_node.parent is not None:\n            current_node = current_node.parent\n\n        # Track seen nodes to detect cycles that can occur after tree modifications\n        seen_nodes = {id(current_node)}\n\n        while \"\\n\" not in current_node.prefix and current_node.prev_sibling is not None:\n            leaf_nodes = list(current_node.prev_sibling.leaves())\n            next_node = leaf_nodes[-1] if leaf_nodes else current_node\n\n            # Detect infinite loop - if we've seen this node before, stop\n            # This can happen when STANDALONE_COMMENT nodes are inserted\n            # during processing\n            if id(next_node) in seen_nodes:\n                break\n\n            current_node = next_node\n            seen_nodes.add(id(current_node))\n\n            # Stop if we encounter a STANDALONE_COMMENT created by fmt processing\n            if (\n                isinstance(current_node, Leaf)\n                and current_node.type == STANDALONE_COMMENT\n                and hasattr(current_node, \"fmt_pass_converted_first_leaf\")\n            ):\n                break\n\n            if (\n                current_node.type in CLOSING_BRACKETS\n                and current_node.parent\n                and current_node.parent.type == syms.atom\n            ):\n                current_node = current_node.parent\n\n            if current_node.type in (token.NEWLINE, token.INDENT):\n                current_node.prefix = \"\"\n                break\n\n            if current_node.type == token.DEDENT:\n                break\n\n            # Special case for with expressions\n            # Without this, we can stuck inside the asexpr_test's children's children\n            if (\n                current_node.parent\n                and current_node.parent.type == syms.asexpr_test\n                and current_node.parent.parent\n                and current_node.parent.parent.type == syms.with_stmt\n            ):\n                current_node = current_node.parent\n\n            ignored_nodes.insert(0, current_node)\n\n            if current_node.prev_sibling is None and current_node.parent is not None:\n                current_node = current_node.parent\n\n        # Special handling for compound statements with semicolon-separated bodies\n        if Preview.fix_fmt_skip_in_one_liners in mode and isinstance(parent, Node):\n            body_node = _find_compound_statement_context(parent)\n            if body_node is not None:\n                header_nodes = _get_compound_statement_header(body_node, parent)\n                if header_nodes:\n                    ignored_nodes = header_nodes + ignored_nodes\n\n        yield from ignored_nodes\n    elif (\n        parent is not None and parent.type == syms.suite and leaf.type == token.NEWLINE\n    ):\n        # The `# fmt: skip` is on the colon line of the if/while/def/class/...\n        # statements. The ignored nodes should be previous siblings of the\n        # parent suite node.\n        leaf.prefix = \"\"\n        parent_sibling = parent.prev_sibling\n        while parent_sibling is not None and parent_sibling.type != syms.suite:\n            ignored_nodes.insert(0, parent_sibling)\n            parent_sibling = parent_sibling.prev_sibling\n        # Special case for `async_stmt` where the ASYNC token is on the\n        # grandparent node.\n        grandparent = parent.parent\n        if (\n            grandparent is not None\n            and grandparent.prev_sibling is not None\n            and grandparent.prev_sibling.type == token.ASYNC\n        ):\n            ignored_nodes.insert(0, grandparent.prev_sibling)\n        yield from iter(ignored_nodes)",
      "old_code": "def _generate_ignored_nodes_from_fmt_skip(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.\"\"\"\n    prev_sibling = leaf.prev_sibling\n    parent = leaf.parent\n    ignored_nodes: list[LN] = []\n    # Need to properly format the leaf prefix to compare it to comment.value,\n    # which is also formatted\n    comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n    if not comments or comment.value != comments[0].value:\n        return\n\n    if Preview.fix_fmt_skip_in_one_liners in mode and not prev_sibling and parent:\n        # If the current leaf doesn't have a previous sibling, it might be deeply nested\n        # (e.g. inside a list, function call, etc.). We need to climb up the tree\n        # to find the previous sibling on the same line.\n\n        # First, find the ancestor node that starts the current line\n        # (has a newline in its prefix, or is at the root)\n        line_start_node = parent\n        while line_start_node.parent is not None:\n            # The comment itself is in the leaf's prefix, so we need to check\n            # if the current node's prefix (before the comment) has a newline\n            node_prefix = (\n                line_start_node.prefix if hasattr(line_start_node, \"prefix\") else \"\"\n            )\n            # Skip the comment part if this is the first node (parent)\n            if line_start_node == parent:\n                # The parent node has the comment in its prefix, so we check\n                # what's before the comment\n                comment_start = node_prefix.find(comment.value)\n                if comment_start >= 0:\n                    prefix_before_comment = node_prefix[:comment_start]\n                    if \"\\n\" in prefix_before_comment:\n                        # There's a newline before the comment, so this node\n                        # is at the start of the line\n                        break\n                elif \"\\n\" in node_prefix:\n                    break\n            elif \"\\n\" in node_prefix:\n                # This node starts on a new line, so it's the line start\n                break\n            line_start_node = line_start_node.parent\n\n        # Now find the prev_sibling by climbing from parent up to line_start_node\n        curr = parent\n        while curr is not None and curr != line_start_node.parent:\n            if curr.prev_sibling is not None:\n                prev_sibling = curr.prev_sibling\n                break\n            if curr.parent is None:\n                break\n            curr = curr.parent\n\n    if prev_sibling is not None:\n        leaf.prefix = leaf.prefix[comment.consumed :]\n\n        if Preview.fix_fmt_skip_in_one_liners not in mode:\n            siblings = [prev_sibling]\n            while (\n                \"\\n\" not in prev_sibling.prefix\n                and prev_sibling.prev_sibling is not None\n            ):\n                prev_sibling = prev_sibling.prev_sibling\n                siblings.insert(0, prev_sibling)\n            yield from siblings\n            return\n\n        # Generates the nodes to be ignored by `fmt: skip`.\n\n        # Nodes to ignore are the ones on the same line as the\n        # `# fmt: skip` comment, excluding the `# fmt: skip`\n        # node itself.\n\n        # Traversal process (starting at the `# fmt: skip` node):\n        # 1. Move to the `prev_sibling` of the current node.\n        # 2. If `prev_sibling` has children, go to its rightmost leaf.\n        # 3. If there's no `prev_sibling`, move up to the parent\n        # node and repeat.\n        # 4. Continue until:\n        #    a. You encounter an `INDENT` or `NEWLINE` node (indicates\n        #       start of the line).\n        #    b. You reach the root node.\n\n        # Include all visited LEAVES in the ignored list, except INDENT\n        # or NEWLINE leaves.\n\n        current_node = prev_sibling\n        ignored_nodes = [current_node]\n        if current_node.prev_sibling is None and current_node.parent is not None:\n            current_node = current_node.parent\n\n        # Track seen nodes to detect cycles that can occur after tree modifications\n        seen_nodes = {id(current_node)}\n\n        while \"\\n\" not in current_node.prefix and current_node.prev_sibling is not None:\n            leaf_nodes = list(current_node.prev_sibling.leaves())\n            next_node = leaf_nodes[-1] if leaf_nodes else current_node\n\n            # Detect infinite loop - if we've seen this node before, stop\n            # This can happen when STANDALONE_COMMENT nodes are inserted\n            # during processing\n            if id(next_node) in seen_nodes:\n                break\n\n            current_node = next_node\n            seen_nodes.add(id(current_node))\n\n            # Stop if we encounter a STANDALONE_COMMENT created by fmt processing\n            if (\n                isinstance(current_node, Leaf)\n                and current_node.type == STANDALONE_COMMENT\n                and hasattr(current_node, \"fmt_pass_converted_first_leaf\")\n            ):\n                break\n\n            if (\n                current_node.type in CLOSING_BRACKETS\n                and current_node.parent\n                and current_node.parent.type == syms.atom\n            ):\n                current_node = current_node.parent\n\n            if current_node.type in (token.NEWLINE, token.INDENT):\n                current_node.prefix = \"\"\n                break\n\n            if current_node.type == token.DEDENT:\n                break\n\n            # Special case for with expressions\n            # Without this, we can stuck inside the asexpr_test's children's children\n            if (\n                current_node.parent\n                and current_node.parent.type == syms.asexpr_test\n                and current_node.parent.parent\n                and current_node.parent.parent.type == syms.with_stmt\n            ):\n                current_node = current_node.parent\n\n            ignored_nodes.insert(0, current_node)\n\n            if current_node.prev_sibling is None and current_node.parent is not None:\n                current_node = current_node.parent\n\n        # Special handling for compound statements with semicolon-separated bodies\n        if Preview.fix_fmt_skip_in_one_liners in mode and isinstance(parent, Node):\n            body_node = _find_compound_statement_context(parent)\n            if body_node is not None:\n                header_nodes = _get_compound_statement_header(body_node, parent)\n                if header_nodes:\n                    ignored_nodes = header_nodes + ignored_nodes\n\n        # If the leaf's parent is an atom (parenthesized expression) and we've\n        # captured the opening bracket in our ignored_nodes, we should include\n        # the entire atom (including the closing bracket and the leaf itself)\n        # to avoid partial formatting\n        if (\n            parent is not None\n            and parent.type == syms.atom\n            and len(parent.children) >= 2\n            and parent.children[0].type in OPENING_BRACKETS\n            and parent.children[0] in ignored_nodes\n        ):\n            # Replace the opening bracket and any other captured children of this atom\n            # with the entire atom node\n            ignored_nodes = [node for node in ignored_nodes if node.parent != parent]\n            ignored_nodes.append(parent)\n\n        yield from ignored_nodes\n    elif (\n        parent is not None and parent.type == syms.suite and leaf.type == token.NEWLINE\n    ):\n        # The `# fmt: skip` is on the colon line of the if/while/def/class/...\n        # statements. The ignored nodes should be previous siblings of the\n        # parent suite node.\n        leaf.prefix = \"\"\n        parent_sibling = parent.prev_sibling\n        while parent_sibling is not None and parent_sibling.type != syms.suite:\n            ignored_nodes.insert(0, parent_sibling)\n            parent_sibling = parent_sibling.prev_sibling\n        # Special case for `async_stmt` where the ASYNC token is on the\n        # grandparent node.\n        grandparent = parent.parent\n        if (\n            grandparent is not None\n            and grandparent.prev_sibling is not None\n            and grandparent.prev_sibling.type == token.ASYNC\n        ):\n            ignored_nodes.insert(0, grandparent.prev_sibling)\n        yield from iter(ignored_nodes)"
    },
    {
      "path": "src/black/lines.py",
      "version": "new",
      "line": 881,
      "kind": "function",
      "qualname": "src.black.lines.is_line_short_enough",
      "span": [
        825,
        917
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def is_line_short_enough(line: Line, *, mode: Mode, line_str: str = \"\") -> bool:\n    \"\"\"For non-multiline strings, return True if `line` is no longer than `line_length`.\n    For multiline strings, looks at the context around `line` to determine\n    if it should be inlined or split up.\n    Uses the provided `line_str` rendering, if any, otherwise computes a new one.\n    \"\"\"\n    if not line_str:\n        line_str = line_to_string(line)\n\n    if Preview.multiline_string_handling not in mode:\n        return (\n            str_width(line_str) <= mode.line_length\n            and \"\\n\" not in line_str  # multiline strings\n            and not line.contains_standalone_comments()\n        )\n\n    if line.contains_standalone_comments():\n        return False\n    if \"\\n\" not in line_str:\n        # No multiline strings (MLS) present\n        return str_width(line_str) <= mode.line_length\n\n    first, *_, last = line_str.split(\"\\n\")\n    if str_width(first) > mode.line_length or str_width(last) > mode.line_length:\n        return False\n\n    # Traverse the AST to examine the context of the multiline string (MLS),\n    # tracking aspects such as depth and comma existence,\n    # to determine whether to split the MLS or keep it together.\n    # Depth (which is based on the existing bracket_depth concept)\n    # is needed to determine nesting level of the MLS.\n    # Includes special case for trailing commas.\n    commas: list[int] = []  # tracks number of commas per depth level\n    multiline_string: Leaf | None = None\n    # store the leaves that contain parts of the MLS\n    multiline_string_contexts: list[LN] = []\n\n    max_level_to_update: int | float = math.inf  # track the depth of the MLS\n    for i, leaf in enumerate(line.leaves):\n        if max_level_to_update == math.inf:\n            had_comma: int | None = None\n            if leaf.bracket_depth + 1 > len(commas):\n                commas.append(0)\n            elif leaf.bracket_depth + 1 < len(commas):\n                had_comma = commas.pop()\n            if (\n                had_comma is not None\n                and multiline_string is not None\n                and multiline_string.bracket_depth == leaf.bracket_depth + 1\n            ):\n                # Have left the level with the MLS, stop tracking commas\n                max_level_to_update = leaf.bracket_depth\n                if had_comma > 0:\n                    # MLS was in parens with at least one comma - force split\n                    return False\n\n        if leaf.bracket_depth <= max_level_to_update and leaf.type == token.COMMA:\n            # Inside brackets, ignore trailing comma\n            # directly after MLS/MLS-containing expression\n            ignore_ctxs: list[LN | None] = [None]\n            ignore_ctxs += multiline_string_contexts\n            if (line.inside_brackets or leaf.bracket_depth > 0) and (\n                i != len(line.leaves) - 1 or leaf.prev_sibling not in ignore_ctxs\n            ):\n                commas[leaf.bracket_depth] += 1\n        if max_level_to_update != math.inf:\n            max_level_to_update = min(max_level_to_update, leaf.bracket_depth)\n\n        if is_multiline_string(leaf):\n            if leaf.parent and (\n                leaf.parent.type == syms.test\n                or (leaf.parent.parent and leaf.parent.parent.type == syms.dictsetmaker)\n            ):\n                # Keep ternary and dictionary values parenthesized\n                return False\n            if len(multiline_string_contexts) > 0:\n                # >1 multiline string cannot fit on a single line - force split\n                return False\n            multiline_string = leaf\n            ctx: LN = leaf\n            # fetch the leaf components of the MLS in the AST\n            while str(ctx) in line_str:\n                multiline_string_contexts.append(ctx)\n                if ctx.parent is None:\n                    break\n                ctx = ctx.parent\n\n    # May not have a triple-quoted multiline string at all,\n    # in case of a regular string with embedded newlines and line continuations\n    if len(multiline_string_contexts) == 0:\n        return True\n\n    return all(val == 0 for val in commas)",
      "old_code": "def is_line_short_enough(line: Line, *, mode: Mode, line_str: str = \"\") -> bool:\n    \"\"\"For non-multiline strings, return True if `line` is no longer than `line_length`.\n    For multiline strings, looks at the context around `line` to determine\n    if it should be inlined or split up.\n    Uses the provided `line_str` rendering, if any, otherwise computes a new one.\n    \"\"\"\n    if not line_str:\n        line_str = line_to_string(line)\n\n    if Preview.multiline_string_handling not in mode:\n        return (\n            str_width(line_str) <= mode.line_length\n            and \"\\n\" not in line_str  # multiline strings\n            and not line.contains_standalone_comments()\n        )\n\n    if line.contains_standalone_comments():\n        return False\n    if \"\\n\" not in line_str:\n        # No multiline strings (MLS) present\n        return str_width(line_str) <= mode.line_length\n\n    first, *_, last = line_str.split(\"\\n\")\n    if str_width(first) > mode.line_length or str_width(last) > mode.line_length:\n        return False\n\n    # Traverse the AST to examine the context of the multiline string (MLS),\n    # tracking aspects such as depth and comma existence,\n    # to determine whether to split the MLS or keep it together.\n    # Depth (which is based on the existing bracket_depth concept)\n    # is needed to determine nesting level of the MLS.\n    # Includes special case for trailing commas.\n    commas: list[int] = []  # tracks number of commas per depth level\n    multiline_string: Leaf | None = None\n    # store the leaves that contain parts of the MLS\n    multiline_string_contexts: list[LN] = []\n\n    max_level_to_update: int | float = math.inf  # track the depth of the MLS\n    for i, leaf in enumerate(line.leaves):\n        if max_level_to_update == math.inf:\n            had_comma: int | None = None\n            # Skip multiline_string_handling logic for leaves without bracket_depth\n            # (e.g., newly created leaves not yet processed by bracket tracker)\n            if not hasattr(leaf, \"bracket_depth\"):\n                continue\n            if leaf.bracket_depth + 1 > len(commas):\n                commas.append(0)\n            elif leaf.bracket_depth + 1 < len(commas):\n                had_comma = commas.pop()\n            if (\n                had_comma is not None\n                and multiline_string is not None\n                and multiline_string.bracket_depth == leaf.bracket_depth + 1\n            ):\n                # Have left the level with the MLS, stop tracking commas\n                max_level_to_update = leaf.bracket_depth\n                if had_comma > 0:\n                    # MLS was in parens with at least one comma - force split\n                    return False\n\n        # Skip bracket-depth-dependent processing for leaves without the attribute\n        if not hasattr(leaf, \"bracket_depth\"):\n            # Still process multiline string detection below\n            pass\n        else:\n            if leaf.bracket_depth <= max_level_to_update and leaf.type == token.COMMA:\n                # Inside brackets, ignore trailing comma\n                # directly after MLS/MLS-containing expression\n                ignore_ctxs: list[LN | None] = [None]\n                ignore_ctxs += multiline_string_contexts\n                if (line.inside_brackets or leaf.bracket_depth > 0) and (\n                    i != len(line.leaves) - 1 or leaf.prev_sibling not in ignore_ctxs\n                ):\n                    commas[leaf.bracket_depth] += 1\n            if max_level_to_update != math.inf:\n                max_level_to_update = min(max_level_to_update, leaf.bracket_depth)\n\n        if is_multiline_string(leaf):\n            if leaf.parent and (\n                leaf.parent.type == syms.test\n                or (leaf.parent.parent and leaf.parent.parent.type == syms.dictsetmaker)\n            ):\n                # Keep ternary and dictionary values parenthesized\n                return False\n            if len(multiline_string_contexts) > 0:\n                # >1 multiline string cannot fit on a single line - force split\n                return False\n            multiline_string = leaf\n            ctx: LN = leaf\n            # fetch the leaf components of the MLS in the AST\n            while str(ctx) in line_str:\n                multiline_string_contexts.append(ctx)\n                if ctx.parent is None:\n                    break\n                ctx = ctx.parent\n\n    # May not have a triple-quoted multiline string at all,\n    # in case of a regular string with embedded newlines and line continuations\n    if len(multiline_string_contexts) == 0:\n        return True\n\n    return all(val == 0 for val in commas)"
    },
    {
      "path": "tests/data/cases/fmtskip_nested_if.py",
      "version": "old",
      "line": 1,
      "kind": "module",
      "qualname": "tests.data.cases.fmtskip_nested_if",
      "span": null,
      "reason": "diff_old_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/data/cases/fmtskip_nested_if.py",
      "version": "old",
      "line": 2,
      "kind": "class",
      "qualname": "tests.data.cases.fmtskip_nested_if.ClassWithALongName",
      "span": [
        2,
        5
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "class ClassWithALongName:\n    Constant1 = 1\n    Constant2 = 2\n    Constant3 = 3"
    },
    {
      "path": "tests/data/cases/fmtskip_nested_if.py",
      "version": "old",
      "line": 8,
      "kind": "function",
      "qualname": "tests.data.cases.fmtskip_nested_if.test",
      "span": [
        8,
        19
      ],
      "reason": "diff_old_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": "def test():\n    if (\n        \"cond1\" == \"cond1\"\n        and \"cond2\" == \"cond2\"\n        and 1 in (  # fmt: skip\n            ClassWithALongName.Constant1,\n            ClassWithALongName.Constant2,\n            ClassWithALongName.Constant3,\n        )\n    ):\n        return True\n    return False"
    }
  ],
  "generated_at": "2026-02-09T15:55:11"
}