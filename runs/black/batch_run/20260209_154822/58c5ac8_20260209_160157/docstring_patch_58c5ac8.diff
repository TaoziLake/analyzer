--- a/scripts/release_tests.py
+++ b/scripts/release_tests.py
@@ -14,10 +14,33 @@
     """Used to mock the date to test generating next calver function"""
 
     def today(*args: Any, **kwargs: Any) -> "FakeDateTime":  # noqa: B902
+        """Mock implementation of datetime.today() for test environments.
+
+        Returns a new FakeDateTime instance regardless of arguments.
+
+        Args:
+            *args: Variable positional arguments (ignored)
+            **kwargs: Variable keyword arguments (ignored)
+
+        Returns:
+            FakeDateTime: A new instance of the FakeDateTime class
+        """
         return FakeDateTime()
 
     # Add leading 0 on purpose to ensure we remove it
     def strftime(*args: Any, **kwargs: Any) -> str:  # noqa: B902
+        """FakeDateTime.strftime returns a fixed string "69.01" regardless of input arguments.
+
+        Args:
+            *args: Variable positional arguments (ignored)
+            **kwargs: Variable keyword arguments (ignored)
+
+        Returns:
+            str: The constant string "69.01"
+
+        Raises:
+            None
+        """
         return "69.01"
 
 

--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -1477,11 +1477,21 @@
 ) -> None:
     """Make existing optional parentheses invisible or create new ones.
 
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    `parens_after` is a set of string leaf values immediately after which parens should be put.
+
+    Standardizes on visible parentheses for single-element tuples, and keeps existing visible parentheses for other tuples and generator expressions.
+
+    Args:
+        node (Node): The node to process.
+        parens_after (set[str]): Set of string leaf values after which parentheses should be inserted.
+        mode (Mode): Formatting mode configuration.
+        features (Collection[Feature]): Active formatting features.
+
+    Returns:
+        None: Modifies the node in place.
+
+    Raises:
+        None: This function does not raise exceptions.
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if pc.value in FMT_OFF:

--- a/src/black/lines.py
+++ b/src/black/lines.py
@@ -550,6 +550,16 @@
 
         This is for separating `def`, `async def` and `class` with extra empty
         lines (two on module-level).
+
+        Args:
+            current_line (Line): The current line being processed.
+
+        Returns:
+            LinesBlock: A block object containing before/after empty line counts,
+                        form feed indicator, and line metadata.
+
+        Raises:
+            No exceptions are raised under normal operation.
         """
         form_feed = (
             current_line.depth == 0
@@ -617,6 +627,19 @@
         return True
 
     def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:
+        """Determine the number of empty lines before and after a given line in the code.
+
+        Args:
+            current_line (Line): The line to analyze for empty lines.
+
+        Returns:
+            tuple[int, int]: A tuple containing:
+                - The number of empty lines to insert before the current line
+                - The number of empty lines to insert after the current line
+
+        Raises:
+            AssertionError: If previous_def exists but previous_line is None (due to the assert statement in the code).
+        """
         max_allowed = 1
         if current_line.depth == 0:
             max_allowed = 1 if self.mode.is_pyi else 2
@@ -712,6 +735,21 @@
     def _maybe_empty_lines_for_class_or_def(
         self, current_line: Line, before: int, user_had_newline: bool
     ) -> tuple[int, int]:
+        """Determine the number of empty lines needed before a class or function definition line.
+
+        Args:
+            current_line (Line): The current line being processed
+            before (int): Number of existing newlines before the line
+            user_had_newline (bool): Whether the user explicitly added a newline
+
+        Returns:
+            tuple[int, int]: A tuple containing:
+                - Number of empty lines to add before the line
+                - Always 0 in current implementation (placeholder for future use)
+
+        Raises:
+            AssertionError: If previous_line is None (internal consistency check)
+        """
         assert self.previous_line is not None
 
         if self.previous_line.is_decorator:
@@ -827,6 +865,17 @@
     For multiline strings, looks at the context around `line` to determine
     if it should be inlined or split up.
     Uses the provided `line_str` rendering, if any, otherwise computes a new one.
+
+    Args:
+        line (Line): The line to check
+        mode (Mode): Mode object controlling formatting behavior
+        line_str (str): Optional pre-rendered string representation of the line
+
+    Returns:
+        bool: True if the line is short enough to remain unsplit, False otherwise
+
+    Raises:
+        No exceptions explicitly raised under normal operation
     """
     if not line_str:
         line_str = line_to_string(line)

--- a/src/black/nodes.py
+++ b/src/black/nodes.py
@@ -180,8 +180,15 @@
 def whitespace(leaf: Leaf, *, complex_subscript: bool, mode: Mode) -> str:
     """Return whitespace prefix if needed for the given `leaf`.
 
-    `complex_subscript` signals whether the given leaf is part of a subscription
-    which has non-trivial arguments, like arithmetic expressions or function calls.
+    `complex_subscript` signals whether the given leaf is part of a subscription which has non-trivial arguments, like arithmetic expressions or function calls.
+
+    Args:
+        leaf: Leaf node to determine whitespace for
+        complex_subscript: Boolean indicating if the leaf is in a complex subscription context
+        mode: Formatting mode configuration
+
+    Returns:
+        str: Whitespace prefix (empty string, single space, or double space) based on context
     """
     NO: Final[str] = ""
     SPACE: Final[str] = " "

--- a/src/black/parsing.py
+++ b/src/black/parsing.py
@@ -180,6 +180,18 @@
 
 
 def _stringify_ast(node: ast.AST, parent_stack: list[ast.AST]) -> Iterator[str]:
+    """Function to generate a textual representation of an AST node with indentation based on parent hierarchy.
+
+    Args:
+        node: AST node to convert to string representation
+        parent_stack: Stack of parent AST nodes used for indentation
+
+    Returns:
+        Iterator[str]: Yields lines of stringified AST representation with indentation
+
+    Raises:
+        May propagate exceptions from AST node field access or recursive calls
+    """
     if (
         isinstance(node, ast.Constant)
         and isinstance(node.value, str)
