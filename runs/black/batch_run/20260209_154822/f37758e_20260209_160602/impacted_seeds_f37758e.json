{
  "commit": "f37758e",
  "parent": "300d1d8f82a463f5e67971df5950f7643b22b8a3",
  "repo": "D:\\locbench\\black",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 2,
  "seeds": [
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 653,
      "kind": "function",
      "qualname": "src.black.comments._generate_ignored_nodes_from_fmt_skip",
      "span": [
        596,
        697
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _generate_ignored_nodes_from_fmt_skip(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.\"\"\"\n    prev_sibling = leaf.prev_sibling\n    parent = leaf.parent\n    ignored_nodes: list[LN] = []\n    # Need to properly format the leaf prefix to compare it to comment.value,\n    # which is also formatted\n    comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n    if not comments or comment.value != comments[0].value:\n        return\n    if prev_sibling is not None:\n        leaf.prefix = leaf.prefix[comment.consumed :]\n\n        if Preview.fix_fmt_skip_in_one_liners not in mode:\n            siblings = [prev_sibling]\n            while (\n                \"\\n\" not in prev_sibling.prefix\n                and prev_sibling.prev_sibling is not None\n            ):\n                prev_sibling = prev_sibling.prev_sibling\n                siblings.insert(0, prev_sibling)\n            yield from siblings\n            return\n\n        # Generates the nodes to be ignored by `fmt: skip`.\n\n        # Nodes to ignore are the ones on the same line as the\n        # `# fmt: skip` comment, excluding the `# fmt: skip`\n        # node itself.\n\n        # Traversal process (starting at the `# fmt: skip` node):\n        # 1. Move to the `prev_sibling` of the current node.\n        # 2. If `prev_sibling` has children, go to its rightmost leaf.\n        # 3. If there's no `prev_sibling`, move up to the parent\n        # node and repeat.\n        # 4. Continue until:\n        #    a. You encounter an `INDENT` or `NEWLINE` node (indicates\n        #       start of the line).\n        #    b. You reach the root node.\n\n        # Include all visited LEAVES in the ignored list, except INDENT\n        # or NEWLINE leaves.\n\n        current_node = prev_sibling\n        ignored_nodes = [current_node]\n        if current_node.prev_sibling is None and current_node.parent is not None:\n            current_node = current_node.parent\n        while \"\\n\" not in current_node.prefix and current_node.prev_sibling is not None:\n            leaf_nodes = list(current_node.prev_sibling.leaves())\n            current_node = leaf_nodes[-1] if leaf_nodes else current_node\n\n            if current_node.type in (token.NEWLINE, token.INDENT):\n                current_node.prefix = \"\"\n                break\n\n            # Special case for with expressions\n            # Without this, we can stuck inside the asexpr_test's children's children\n            if (\n                current_node.parent\n                and current_node.parent.type == syms.asexpr_test\n                and current_node.parent.parent\n                and current_node.parent.parent.type == syms.with_stmt\n            ):\n                current_node = current_node.parent\n\n            ignored_nodes.insert(0, current_node)\n\n            if current_node.prev_sibling is None and current_node.parent is not None:\n                current_node = current_node.parent\n\n        # Special handling for compound statements with semicolon-separated bodies\n        if Preview.fix_fmt_skip_in_one_liners in mode and isinstance(parent, Node):\n            body_node = _find_compound_statement_context(parent)\n            if body_node is not None:\n                header_nodes = _get_compound_statement_header(body_node, parent)\n                if header_nodes:\n                    ignored_nodes = header_nodes + ignored_nodes\n\n        yield from ignored_nodes\n    elif (\n        parent is not None and parent.type == syms.suite and leaf.type == token.NEWLINE\n    ):\n        # The `# fmt: skip` is on the colon line of the if/while/def/class/...\n        # statements. The ignored nodes should be previous siblings of the\n        # parent suite node.\n        leaf.prefix = \"\"\n        parent_sibling = parent.prev_sibling\n        while parent_sibling is not None and parent_sibling.type != syms.suite:\n            ignored_nodes.insert(0, parent_sibling)\n            parent_sibling = parent_sibling.prev_sibling\n        # Special case for `async_stmt` where the ASYNC token is on the\n        # grandparent node.\n        grandparent = parent.parent\n        if (\n            grandparent is not None\n            and grandparent.prev_sibling is not None\n            and grandparent.prev_sibling.type == token.ASYNC\n        ):\n            ignored_nodes.insert(0, grandparent.prev_sibling)\n        yield from iter(ignored_nodes)",
      "old_code": "def _generate_ignored_nodes_from_fmt_skip(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.\"\"\"\n    prev_sibling = leaf.prev_sibling\n    parent = leaf.parent\n    ignored_nodes: list[LN] = []\n    # Need to properly format the leaf prefix to compare it to comment.value,\n    # which is also formatted\n    comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n    if not comments or comment.value != comments[0].value:\n        return\n    if prev_sibling is not None:\n        leaf.prefix = leaf.prefix[comment.consumed :]\n\n        if Preview.fix_fmt_skip_in_one_liners not in mode:\n            siblings = [prev_sibling]\n            while (\n                \"\\n\" not in prev_sibling.prefix\n                and prev_sibling.prev_sibling is not None\n            ):\n                prev_sibling = prev_sibling.prev_sibling\n                siblings.insert(0, prev_sibling)\n            yield from siblings\n            return\n\n        # Generates the nodes to be ignored by `fmt: skip`.\n\n        # Nodes to ignore are the ones on the same line as the\n        # `# fmt: skip` comment, excluding the `# fmt: skip`\n        # node itself.\n\n        # Traversal process (starting at the `# fmt: skip` node):\n        # 1. Move to the `prev_sibling` of the current node.\n        # 2. If `prev_sibling` has children, go to its rightmost leaf.\n        # 3. If there's no `prev_sibling`, move up to the parent\n        # node and repeat.\n        # 4. Continue until:\n        #    a. You encounter an `INDENT` or `NEWLINE` node (indicates\n        #       start of the line).\n        #    b. You reach the root node.\n\n        # Include all visited LEAVES in the ignored list, except INDENT\n        # or NEWLINE leaves.\n\n        current_node = prev_sibling\n        ignored_nodes = [current_node]\n        if current_node.prev_sibling is None and current_node.parent is not None:\n            current_node = current_node.parent\n        while \"\\n\" not in current_node.prefix and current_node.prev_sibling is not None:\n            leaf_nodes = list(current_node.prev_sibling.leaves())\n            current_node = leaf_nodes[-1] if leaf_nodes else current_node\n\n            if current_node.type in (token.NEWLINE, token.INDENT):\n                current_node.prefix = \"\"\n                break\n\n            ignored_nodes.insert(0, current_node)\n\n            if current_node.prev_sibling is None and current_node.parent is not None:\n                current_node = current_node.parent\n        # Special handling for compound statements with semicolon-separated bodies\n        if Preview.fix_fmt_skip_in_one_liners in mode and isinstance(parent, Node):\n            body_node = _find_compound_statement_context(parent)\n            if body_node is not None:\n                header_nodes = _get_compound_statement_header(body_node, parent)\n                if header_nodes:\n                    ignored_nodes = header_nodes + ignored_nodes\n\n        yield from ignored_nodes\n    elif (\n        parent is not None and parent.type == syms.suite and leaf.type == token.NEWLINE\n    ):\n        # The `# fmt: skip` is on the colon line of the if/while/def/class/...\n        # statements. The ignored nodes should be previous siblings of the\n        # parent suite node.\n        leaf.prefix = \"\"\n        parent_sibling = parent.prev_sibling\n        while parent_sibling is not None and parent_sibling.type != syms.suite:\n            ignored_nodes.insert(0, parent_sibling)\n            parent_sibling = parent_sibling.prev_sibling\n        # Special case for `async_stmt` where the ASYNC token is on the\n        # grandparent node.\n        grandparent = parent.parent\n        if (\n            grandparent is not None\n            and grandparent.prev_sibling is not None\n            and grandparent.prev_sibling.type == token.ASYNC\n        ):\n            ignored_nodes.insert(0, grandparent.prev_sibling)\n        yield from iter(ignored_nodes)"
    },
    {
      "path": "tests/data/cases/fmtskip12.py",
      "version": "new",
      "line": 1,
      "kind": "module",
      "qualname": "tests.data.cases.fmtskip12",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-09T16:06:03"
}