{
  "commit": "6ea3ef8",
  "parent": "f5e2d0667dbeb36e6b11e1a04f3f41ccd893babe",
  "repo": "D:\\locbench\\black",
  "num_files_in_diff": 7,
  "num_py_files_in_diff": 4,
  "num_seeds": 9,
  "seeds": [
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1527,
      "kind": "function",
      "qualname": "src.black.linegen.normalize_invisible_parens",
      "span": [
        1475,
        1608
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def normalize_invisible_parens(  # noqa: C901\n    node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]\n) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n\n    # The multiple context managers grammar has a different pattern, thus this is\n    # separate from the for-loop below. This possibly wraps them in invisible parens,\n    # and later will be removed in remove_with_parens when needed.\n    if node.type == syms.with_stmt:\n        _maybe_wrap_cms_in_parens(node, mode, features)\n\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(\n                child, parens_after=parens_after, mode=mode, features=features\n            )\n\n        # Fixes a bug where invisible parens are not properly wrapped around\n        # case blocks.\n        if isinstance(child, Node) and child.type == syms.case_block:\n            normalize_invisible_parens(\n                child, parens_after={\"case\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around if guards in case blocks\n        if isinstance(child, Node) and child.type == syms.guard:\n            normalize_invisible_parens(\n                child, parens_after={\"if\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        # Check for assignment LHS with preview feature enabled\n        if (\n            Preview.remove_parens_from_assignment_lhs in mode\n            and index == 0\n            and isinstance(child, Node)\n            and child.type == syms.atom\n            and node.type == syms.expr_stmt\n            and not _atom_has_magic_trailing_comma(child, mode)\n            and not _is_atom_multiline(child)\n        ):\n            if maybe_make_parens_invisible_in_atom(\n                child,\n                parent=node,\n                mode=mode,\n                features=features,\n                remove_brackets_around_comma=True,\n                allow_star_expr=True,\n            ):\n                wrap_in_parentheses(node, child, visible=False)\n\n        if check_lpar:\n            if (\n                child.type == syms.atom\n                and node.type == syms.for_stmt\n                and isinstance(child.prev_sibling, Leaf)\n                and child.prev_sibling.type == token.NAME\n                and child.prev_sibling.value == \"for\"\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child,\n                    parent=node,\n                    mode=mode,\n                    features=features,\n                    remove_brackets_around_comma=True,\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif isinstance(child, Node) and node.type == syms.with_stmt:\n                remove_with_parens(child, node, mode=mode, features=features)\n            elif child.type == syms.atom and not (\n                \"in\" in parens_after\n                and len(child.children) == 3\n                and is_lpar_token(child.children[0])\n                and is_rpar_token(child.children[-1])\n                and child.children[1].type == syms.test\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child, parent=node, mode=mode, features=features\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                _normalize_import_from(node, child, index)\n                break\n            elif (\n                index == 1\n                and child.type == token.STAR\n                and node.type == syms.except_clause\n            ):\n                # In except* (PEP 654), the star is actually part of\n                # of the keyword. So we need to skip the insertion of\n                # invisible parentheses to work more precisely.\n                continue\n\n            elif (\n                isinstance(child, Leaf)\n                and child.next_sibling is not None\n                and child.next_sibling.type == token.COLON\n                and child.value == \"case\"\n            ):\n                # A special patch for \"case case:\" scenario, the second occurrence\n                # of case will be not parsed as a Python keyword.\n                break\n\n            elif not is_multiline_string(child):\n                wrap_in_parentheses(node, child, visible=False)\n\n        comma_check = child.type == token.COMMA\n\n        check_lpar = isinstance(child, Leaf) and (\n            child.value in parens_after or comma_check\n        )",
      "old_code": "def normalize_invisible_parens(  # noqa: C901\n    node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]\n) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n\n    # The multiple context managers grammar has a different pattern, thus this is\n    # separate from the for-loop below. This possibly wraps them in invisible parens,\n    # and later will be removed in remove_with_parens when needed.\n    if node.type == syms.with_stmt:\n        _maybe_wrap_cms_in_parens(node, mode, features)\n\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(\n                child, parens_after=parens_after, mode=mode, features=features\n            )\n\n        # Fixes a bug where invisible parens are not properly wrapped around\n        # case blocks.\n        if isinstance(child, Node) and child.type == syms.case_block:\n            normalize_invisible_parens(\n                child, parens_after={\"case\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around if guards in case blocks\n        if isinstance(child, Node) and child.type == syms.guard:\n            normalize_invisible_parens(\n                child, parens_after={\"if\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        if check_lpar:\n            if (\n                child.type == syms.atom\n                and node.type == syms.for_stmt\n                and isinstance(child.prev_sibling, Leaf)\n                and child.prev_sibling.type == token.NAME\n                and child.prev_sibling.value == \"for\"\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child,\n                    parent=node,\n                    mode=mode,\n                    features=features,\n                    remove_brackets_around_comma=True,\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif isinstance(child, Node) and node.type == syms.with_stmt:\n                remove_with_parens(child, node, mode=mode, features=features)\n            elif child.type == syms.atom and not (\n                \"in\" in parens_after\n                and len(child.children) == 3\n                and is_lpar_token(child.children[0])\n                and is_rpar_token(child.children[-1])\n                and child.children[1].type == syms.test\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child, parent=node, mode=mode, features=features\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                _normalize_import_from(node, child, index)\n                break\n            elif (\n                index == 1\n                and child.type == token.STAR\n                and node.type == syms.except_clause\n            ):\n                # In except* (PEP 654), the star is actually part of\n                # of the keyword. So we need to skip the insertion of\n                # invisible parentheses to work more precisely.\n                continue\n\n            elif (\n                isinstance(child, Leaf)\n                and child.next_sibling is not None\n                and child.next_sibling.type == token.COLON\n                and child.value == \"case\"\n            ):\n                # A special patch for \"case case:\" scenario, the second occurrence\n                # of case will be not parsed as a Python keyword.\n                break\n\n            elif not is_multiline_string(child):\n                wrap_in_parentheses(node, child, visible=False)\n\n        comma_check = child.type == token.COMMA\n\n        check_lpar = isinstance(child, Leaf) and (\n            child.value in parens_after or comma_check\n        )"
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1752,
      "kind": "function",
      "qualname": "src.black.linegen._atom_has_magic_trailing_comma",
      "span": [
        1752,
        1761
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _atom_has_magic_trailing_comma(node: LN, mode: Mode) -> bool:\n    \"\"\"Check if an atom node has a magic trailing comma.\n\n    Returns True for single-element tuples with trailing commas like (a,),\n    which should be preserved to maintain their tuple type.\n    \"\"\"\n    if not mode.magic_trailing_comma:\n        return False\n\n    return is_one_tuple(node)",
      "old_code": null
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1762,
      "kind": "module",
      "qualname": "src.black.linegen",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1764,
      "kind": "function",
      "qualname": "src.black.linegen._is_atom_multiline",
      "span": [
        1764,
        1776
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _is_atom_multiline(node: LN) -> bool:\n    \"\"\"Check if an atom node is multiline (indicating intentional formatting).\"\"\"\n    if not isinstance(node, Node) or len(node.children) < 3:\n        return False\n\n    # Check the middle child (between LPAR and RPAR) for newlines in its subtree\n    # The first child's prefix contains blank lines/comments before the opening paren\n    middle = node.children[1]\n    for child in middle.pre_order():\n        if isinstance(child, Leaf) and \"\\n\" in child.prefix:\n            return True\n\n    return False",
      "old_code": null
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1785,
      "kind": "function",
      "qualname": "src.black.linegen.maybe_make_parens_invisible_in_atom",
      "span": [
        1779,
        1891
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def maybe_make_parens_invisible_in_atom(\n    node: LN,\n    parent: LN,\n    mode: Mode,\n    features: Collection[Feature],\n    remove_brackets_around_comma: bool = False,\n    allow_star_expr: bool = False,\n) -> bool:\n    \"\"\"If it's safe, make the parens in the atom `node` invisible, recursively.\n    Additionally, remove repeated, adjacent invisible parens from the atom `node`\n    as they are redundant.\n\n    Returns whether the node should itself be wrapped in invisible parentheses.\n    \"\"\"\n    if (\n        node.type not in (syms.atom, syms.expr)\n        or is_empty_tuple(node)\n        or is_one_tuple(node)\n        or (is_tuple(node) and parent.type == syms.asexpr_test)\n        or (\n            is_tuple(node)\n            and parent.type == syms.with_stmt\n            and has_sibling_with_type(node, token.COMMA)\n        )\n        or (is_yield(node) and parent.type != syms.expr_stmt)\n        or (\n            # This condition tries to prevent removing non-optional brackets\n            # around a tuple, however, can be a bit overzealous so we provide\n            # and option to skip this check for `for` and `with` statements.\n            not remove_brackets_around_comma\n            and max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n            # Skip this check in Preview mode in order to\n            # Remove parentheses around multiple exception types in except and\n            # except* without as. See PEP 758 for details.\n            and not (\n                Preview.remove_parens_around_except_types in mode\n                and Feature.UNPARENTHESIZED_EXCEPT_TYPES in features\n                # is a tuple\n                and is_tuple(node)\n                # has a parent node\n                and node.parent is not None\n                # parent is an except clause\n                and node.parent.type == syms.except_clause\n                # is not immediately followed by as clause\n                and not (\n                    node.next_sibling is not None\n                    and is_name_token(node.next_sibling)\n                    and node.next_sibling.value == \"as\"\n                )\n            )\n        )\n        or is_tuple_containing_walrus(node)\n        or (not allow_star_expr and is_tuple_containing_star(node))\n        or is_generator(node)\n    ):\n        return False\n\n    if is_walrus_assignment(node):\n        if parent.type in [\n            syms.annassign,\n            syms.expr_stmt,\n            syms.assert_stmt,\n            syms.return_stmt,\n            syms.except_clause,\n            syms.funcdef,\n            syms.with_stmt,\n            syms.testlist_gexp,\n            syms.tname,\n            # these ones aren't useful to end users, but they do please fuzzers\n            syms.for_stmt,\n            syms.del_stmt,\n            syms.for_stmt,\n        ]:\n            return False\n\n    first = node.children[0]\n    last = node.children[-1]\n    if is_lpar_token(first) and is_rpar_token(last):\n        middle = node.children[1]\n        # make parentheses invisible\n        if (\n            # If the prefix of `middle` includes a type comment with\n            # ignore annotation, then we do not remove the parentheses\n            not is_type_ignore_comment_string(middle.prefix.strip(), mode=mode)\n        ):\n            first.value = \"\"\n            last.value = \"\"\n        maybe_make_parens_invisible_in_atom(\n            middle,\n            parent=parent,\n            mode=mode,\n            features=features,\n            remove_brackets_around_comma=remove_brackets_around_comma,\n        )\n\n        if is_atom_with_invisible_parens(middle):\n            # Strip the invisible parens from `middle` by replacing\n            # it with the child in-between the invisible parens\n            middle.replace(middle.children[1])\n\n            if middle.children[0].prefix.strip():\n                # Preserve comments before first paren\n                middle.children[1].prefix = (\n                    middle.children[0].prefix + middle.children[1].prefix\n                )\n\n            if middle.children[-1].prefix.strip():\n                # Preserve comments before last paren\n                last.prefix = middle.children[-1].prefix + last.prefix\n\n        return False\n\n    return True",
      "old_code": "def maybe_make_parens_invisible_in_atom(\n    node: LN,\n    parent: LN,\n    mode: Mode,\n    features: Collection[Feature],\n    remove_brackets_around_comma: bool = False,\n) -> bool:\n    \"\"\"If it's safe, make the parens in the atom `node` invisible, recursively.\n    Additionally, remove repeated, adjacent invisible parens from the atom `node`\n    as they are redundant.\n\n    Returns whether the node should itself be wrapped in invisible parentheses.\n    \"\"\"\n    if (\n        node.type not in (syms.atom, syms.expr)\n        or is_empty_tuple(node)\n        or is_one_tuple(node)\n        or (is_tuple(node) and parent.type == syms.asexpr_test)\n        or (\n            is_tuple(node)\n            and parent.type == syms.with_stmt\n            and has_sibling_with_type(node, token.COMMA)\n        )\n        or (is_yield(node) and parent.type != syms.expr_stmt)\n        or (\n            # This condition tries to prevent removing non-optional brackets\n            # around a tuple, however, can be a bit overzealous so we provide\n            # and option to skip this check for `for` and `with` statements.\n            not remove_brackets_around_comma\n            and max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n            # Skip this check in Preview mode in order to\n            # Remove parentheses around multiple exception types in except and\n            # except* without as. See PEP 758 for details.\n            and not (\n                Preview.remove_parens_around_except_types in mode\n                and Feature.UNPARENTHESIZED_EXCEPT_TYPES in features\n                # is a tuple\n                and is_tuple(node)\n                # has a parent node\n                and node.parent is not None\n                # parent is an except clause\n                and node.parent.type == syms.except_clause\n                # is not immediately followed by as clause\n                and not (\n                    node.next_sibling is not None\n                    and is_name_token(node.next_sibling)\n                    and node.next_sibling.value == \"as\"\n                )\n            )\n        )\n        or is_tuple_containing_walrus(node)\n        or is_tuple_containing_star(node)\n        or is_generator(node)\n    ):\n        return False\n\n    if is_walrus_assignment(node):\n        if parent.type in [\n            syms.annassign,\n            syms.expr_stmt,\n            syms.assert_stmt,\n            syms.return_stmt,\n            syms.except_clause,\n            syms.funcdef,\n            syms.with_stmt,\n            syms.testlist_gexp,\n            syms.tname,\n            # these ones aren't useful to end users, but they do please fuzzers\n            syms.for_stmt,\n            syms.del_stmt,\n            syms.for_stmt,\n        ]:\n            return False\n\n    first = node.children[0]\n    last = node.children[-1]\n    if is_lpar_token(first) and is_rpar_token(last):\n        middle = node.children[1]\n        # make parentheses invisible\n        if (\n            # If the prefix of `middle` includes a type comment with\n            # ignore annotation, then we do not remove the parentheses\n            not is_type_ignore_comment_string(middle.prefix.strip(), mode=mode)\n        ):\n            first.value = \"\"\n            last.value = \"\"\n        maybe_make_parens_invisible_in_atom(\n            middle,\n            parent=parent,\n            mode=mode,\n            features=features,\n            remove_brackets_around_comma=remove_brackets_around_comma,\n        )\n\n        if is_atom_with_invisible_parens(middle):\n            # Strip the invisible parens from `middle` by replacing\n            # it with the child in-between the invisible parens\n            middle.replace(middle.children[1])\n\n            if middle.children[0].prefix.strip():\n                # Preserve comments before first paren\n                middle.children[1].prefix = (\n                    middle.children[0].prefix + middle.children[1].prefix\n                )\n\n            if middle.children[-1].prefix.strip():\n                # Preserve comments before last paren\n                last.prefix = middle.children[-1].prefix + last.prefix\n\n        return False\n\n    return True"
    },
    {
      "path": "src/black/mode.py",
      "version": "new",
      "line": 236,
      "kind": "class",
      "qualname": "src.black.mode.Preview",
      "span": [
        222,
        241
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "class Preview(Enum):\n    \"\"\"Individual preview style features.\"\"\"\n\n    # NOTE: string_processing requires wrap_long_dict_values_in_parens\n    # for https://github.com/psf/black/issues/3117 to be fixed.\n    string_processing = auto()\n    hug_parens_with_braces_and_square_brackets = auto()\n    wrap_long_dict_values_in_parens = auto()\n    multiline_string_handling = auto()\n    always_one_newline_after_import = auto()\n    fix_fmt_skip_in_one_liners = auto()\n    standardize_type_comments = auto()\n    wrap_comprehension_in = auto()\n    # Remove parentheses around multiple exception types in except and\n    # except* without as. See PEP 758 for details.\n    remove_parens_around_except_types = auto()\n    normalize_cr_newlines = auto()\n    fix_module_docstring_detection = auto()\n    fix_type_expansion_split = auto()\n    remove_parens_from_assignment_lhs = auto()",
      "old_code": "class Preview(Enum):\n    \"\"\"Individual preview style features.\"\"\"\n\n    # NOTE: string_processing requires wrap_long_dict_values_in_parens\n    # for https://github.com/psf/black/issues/3117 to be fixed.\n    string_processing = auto()\n    hug_parens_with_braces_and_square_brackets = auto()\n    wrap_long_dict_values_in_parens = auto()\n    multiline_string_handling = auto()\n    always_one_newline_after_import = auto()\n    fix_fmt_skip_in_one_liners = auto()\n    standardize_type_comments = auto()\n    wrap_comprehension_in = auto()\n    # Remove parentheses around multiple exception types in except and\n    # except* without as. See PEP 758 for details.\n    remove_parens_around_except_types = auto()\n    normalize_cr_newlines = auto()\n    fix_module_docstring_detection = auto()\n    fix_type_expansion_split = auto()"
    },
    {
      "path": "src/blib2to3/pgen2/tokenize.py",
      "version": "new",
      "line": 214,
      "kind": "function",
      "qualname": "src.blib2to3.pgen2.tokenize.printtoken",
      "span": [
        211,
        216
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def printtoken(\n    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n) -> None:  # for testing\n    srow, scol = srow_col\n    erow, ecol = erow_col\n    print(f\"{srow},{scol}-{erow},{ecol}:\\t{tok_name[type]}\\t{token!r}\")",
      "old_code": "def printtoken(\n    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n) -> None:  # for testing\n    (srow, scol) = srow_col\n    (erow, ecol) = erow_col\n    print(f\"{srow},{scol}-{erow},{ecol}:\\t{tok_name[type]}\\t{token!r}\")"
    },
    {
      "path": "tests/data/cases/remove_parens_from_lhs.py",
      "version": "new",
      "line": 1,
      "kind": "module",
      "qualname": "tests.data.cases.remove_parens_from_lhs",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/data/cases/remove_parens_from_lhs.py",
      "version": "new",
      "line": 5,
      "kind": "function",
      "qualname": "tests.data.cases.remove_parens_from_lhs.a",
      "span": [
        5,
        6
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "def a():\n    return [1, 2, 3]",
      "old_code": null
    }
  ],
  "generated_at": "2026-02-09T16:04:10"
}