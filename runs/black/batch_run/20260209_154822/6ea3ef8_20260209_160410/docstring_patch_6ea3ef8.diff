--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -1477,11 +1477,18 @@
 ) -> None:
     """Make existing optional parentheses invisible or create new ones.
 
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    `parens_after` is a set of string leaf values immediately after which parens should be put.
+
+    Standardizes on visible parentheses for single-element tuples, and keeps existing visible parentheses for other tuples and generator expressions.
+
+    Args:
+        node (Node): The node to process.
+        parens_after (set[str]): Keywords/operands that should be followed by parentheses.
+        mode (Mode): Formatting mode controlling output style and preview features.
+        features (Collection[Feature]): Enabled Python language features.
+
+    Returns:
+        None: Modifies the node in-place.
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if pc.value in FMT_OFF:
@@ -1754,6 +1761,13 @@
 
     Returns True for single-element tuples with trailing commas like (a,),
     which should be preserved to maintain their tuple type.
+
+    Args:
+        node (LN): The node to check
+        mode (Mode): Formatting mode configuration
+
+    Returns:
+        bool: True if the node is a single-element tuple and magic trailing commas are enabled in mode
     """
     if not mode.magic_trailing_comma:
         return False
@@ -1762,7 +1776,14 @@
 
 
 def _is_atom_multiline(node: LN) -> bool:
-    """Check if an atom node is multiline (indicating intentional formatting)."""
+    """Check if an atom node is multiline (indicating intentional formatting).
+
+    Args:
+        node (LN): The node to check for multiline status.
+
+    Returns:
+        bool: True if the node is a multiline atom, False otherwise.
+    """
     if not isinstance(node, Node) or len(node.children) < 3:
         return False
 
@@ -1784,11 +1805,18 @@
     remove_brackets_around_comma: bool = False,
     allow_star_expr: bool = False,
 ) -> bool:
-    """If it's safe, make the parens in the atom `node` invisible, recursively.
-    Additionally, remove repeated, adjacent invisible parens from the atom `node`
-    as they are redundant.
-
-    Returns whether the node should itself be wrapped in invisible parentheses.
+    """If it's safe, make the parens in the atom `node` invisible, recursively. Additionally, remove repeated, adjacent invisible parens from the atom `node` as they are redundant.
+
+    Args:
+        node (LN): The node to process.
+        parent (LN): The parent node of `node`.
+        mode (Mode): Formatting mode configuration.
+        features (Collection[Feature]): Active formatting features.
+        remove_brackets_around_comma (bool): Whether to skip comma-related bracket checks.
+        allow_star_expr (bool): Whether to allow removing parentheses around tuples containing star expressions.
+
+    Returns:
+        bool: Whether the node should itself be wrapped in invisible parentheses.
     """
     if (
         node.type not in (syms.atom, syms.expr)

--- a/src/blib2to3/pgen2/tokenize.py
+++ b/src/blib2to3/pgen2/tokenize.py
@@ -211,6 +211,18 @@
 def printtoken(
     type: int, token: str, srow_col: Coord, erow_col: Coord, line: str
 ) -> None:  # for testing
+    """Print token information in a human-readable format for testing purposes.
+
+    Args:
+        type: Token type (e.g., NAME, NUMBER)
+        token: The actual token string
+        srow_col: Start position as (row, column) tuple
+        erow_col: End position as (row, column) tuple
+        line: The original source line containing the token
+
+    Returns:
+        None. Output is printed directly to stdout.
+    """
     srow, scol = srow_col
     erow, ecol = erow_col
     print(f"{srow},{scol}-{erow},{ecol}:\t{tok_name[type]}\t{token!r}")
