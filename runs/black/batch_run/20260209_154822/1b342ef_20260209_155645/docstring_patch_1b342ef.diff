--- a/src/black/comments.py
+++ b/src/black/comments.py
@@ -334,9 +334,18 @@
 def convert_one_fmt_off_pair(
     node: Node, mode: Mode, lines: Collection[tuple[int, int]]
 ) -> bool:
-    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
-
-    Returns True if a pair was converted.
+    """Convert content of a single `# fmt: off`/`# fmt: on` or `# fmt: skip` into a standalone comment.
+
+    Args:
+        node: The node to process
+        mode: Black's formatting mode
+        lines: Collection of (start, end) line positions for formatting ranges
+
+    Returns:
+        True if a pair was converted
+
+    Raises:
+        No exceptions explicitly raised
     """
     for leaf in node.leaves():
         # Skip STANDALONE_COMMENT nodes that were created by fmt:off/on/skip processing
@@ -398,7 +407,22 @@
     lines: Collection[tuple[int, int]],
     leaf: Leaf,
 ) -> None:
-    """Handle fmt blocks with actual AST nodes."""
+    """Handle fmt blocks with actual AST nodes.
+
+    Args:
+        ignored_nodes: List of nodes to be ignored during formatting
+        comment: ProtoComment object containing comment metadata
+        previous_consumed: Number of characters consumed in previous operations
+        is_fmt_skip: Boolean indicating if this is a fmt: skip directive
+        lines: Collection of line number ranges for formatting control
+        leaf: Leaf node serving as reference point for operations
+
+    Returns:
+        None. Modifies the AST structure by inserting a new STANDALONE_COMMENT node.
+
+    Raises:
+        AssertionError: If parent or insertion index is None during AST manipulation
+    """
     first = ignored_nodes[0]  # Can be a container node with the `leaf`.
     parent = first.parent
     prefix = first.prefix
@@ -430,6 +454,18 @@
             if has_standalone:
                 # Stringify node with STANDALONE_COMMENT leaves having trailing newlines
                 def stringify_node(n: LN) -> str:
+                    """Converts a node to its string representation, handling standalone comments specially.
+
+                    Args:
+                        n (LN): The node to convert to string. Can be a Leaf or a Parent node.
+
+                    Returns:
+                        str: The string representation of the node. For standalone comments, ensures
+                             trailing newline. For parent nodes, recursively joins child nodes' strings.
+
+                    Raises:
+                        None: This function does not explicitly raise exceptions.
+                    """
                     if isinstance(n, Leaf):
                         if n.type == STANDALONE_COMMENT:
                             result = n.prefix + n.value
@@ -634,7 +670,22 @@
 def _generate_ignored_nodes_from_fmt_skip(
     leaf: Leaf, comment: ProtoComment, mode: Mode
 ) -> Iterator[LN]:
-    """Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`."""
+    """Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.
+
+    Args:
+        leaf: The leaf node containing the fmt: skip comment
+        comment: The ProtoComment object representing the fmt: skip directive
+        mode: The formatting mode controlling behavior
+
+    Returns:
+        An iterator of nodes to be ignored by the fmt: skip directive. Processing stops when:
+        - A cycle is detected in node traversal
+        - A STANDALONE_COMMENT node created during formatting is encountered
+        - Traditional stopping points (NEWLINE, INDENT) are reached
+
+    Raises:
+        No exceptions are raised under normal operation
+    """
     prev_sibling = leaf.prev_sibling
     parent = leaf.parent
     ignored_nodes: list[LN] = []
