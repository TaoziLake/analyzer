{
  "commit": "f0f4094",
  "parent": "70fc194172184861aafb418c124824cae0fbe3b0",
  "repo": "D:\\locbench\\black",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 2,
  "num_seeds": 2,
  "seeds": [
    {
      "path": "src/black/lines.py",
      "version": "new",
      "line": 698,
      "kind": "function",
      "qualname": "src.black.lines.EmptyLineTracker._maybe_empty_lines",
      "span": [
        619,
        711
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 1 if self.mode.is_pyi else 2\n\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n\n        user_had_newline = bool(before)\n        depth = current_line.depth\n\n        # Mutate self.previous_defs, remainder of this function should be pure\n        previous_def = None\n        while self.previous_defs and self.previous_defs[-1].depth >= depth:\n            previous_def = self.previous_defs.pop()\n        if current_line.is_def or current_line.is_class:\n            self.previous_defs.append(current_line)\n\n        if self.previous_line is None:\n            # Don't insert empty lines before the first line in the file.\n            return 0, 0\n\n        if current_line.is_docstring:\n            if self.previous_line.is_class:\n                return 0, 1\n            if self.previous_line.opens_block and self.previous_line.is_def:\n                return 0, 0\n\n        if previous_def is not None:\n            assert self.previous_line is not None\n            if self.mode.is_pyi:\n                if previous_def.is_class and not previous_def.is_stub_class:\n                    before = 1\n                elif depth and not current_line.is_def and self.previous_line.is_def:\n                    # Empty lines between attributes and methods should be preserved.\n                    before = 1 if user_had_newline else 0\n                elif depth:\n                    before = 0\n                else:\n                    before = 1\n            else:\n                if depth:\n                    before = 1\n                elif (\n                    not depth\n                    and previous_def.depth\n                    and current_line.leaves[-1].type == token.COLON\n                    and (\n                        current_line.leaves[0].value\n                        not in (\"with\", \"try\", \"for\", \"while\", \"if\", \"match\")\n                    )\n                ):\n                    # We shouldn't add two newlines between an indented function and\n                    # a dependent non-indented clause. This is to avoid issues with\n                    # conditional function definitions that are technically top-level\n                    # and therefore get two trailing newlines, but look weird and\n                    # inconsistent when they're followed by elif, else, etc. This is\n                    # worse because these functions only get *one* preceding newline\n                    # already.\n                    before = 1\n                else:\n                    before = 2\n\n        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n            return self._maybe_empty_lines_for_class_or_def(\n                current_line, before, user_had_newline\n            )\n\n        if (\n            self.previous_line.is_import\n            and self.previous_line.depth == 0\n            and current_line.depth == 0\n            and not current_line.is_import\n            and not current_line.is_fmt_pass_converted(first_leaf_matches=is_import)\n            and Preview.always_one_newline_after_import in self.mode\n        ):\n            return 1, 0\n\n        if (\n            self.previous_line.is_import\n            and not current_line.is_import\n            and not current_line.is_fmt_pass_converted(first_leaf_matches=is_import)\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        return before, 0",
      "old_code": "    def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 1 if self.mode.is_pyi else 2\n\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n\n        user_had_newline = bool(before)\n        depth = current_line.depth\n\n        # Mutate self.previous_defs, remainder of this function should be pure\n        previous_def = None\n        while self.previous_defs and self.previous_defs[-1].depth >= depth:\n            previous_def = self.previous_defs.pop()\n        if current_line.is_def or current_line.is_class:\n            self.previous_defs.append(current_line)\n\n        if self.previous_line is None:\n            # Don't insert empty lines before the first line in the file.\n            return 0, 0\n\n        if current_line.is_docstring:\n            if self.previous_line.is_class:\n                return 0, 1\n            if self.previous_line.opens_block and self.previous_line.is_def:\n                return 0, 0\n\n        if previous_def is not None:\n            assert self.previous_line is not None\n            if self.mode.is_pyi:\n                if previous_def.is_class and not previous_def.is_stub_class:\n                    before = 1\n                elif depth and not current_line.is_def and self.previous_line.is_def:\n                    # Empty lines between attributes and methods should be preserved.\n                    before = 1 if user_had_newline else 0\n                elif depth:\n                    before = 0\n                else:\n                    before = 1\n            else:\n                if depth:\n                    before = 1\n                elif (\n                    not depth\n                    and previous_def.depth\n                    and current_line.leaves[-1].type == token.COLON\n                    and (\n                        current_line.leaves[0].value\n                        not in (\"with\", \"try\", \"for\", \"while\", \"if\", \"match\")\n                    )\n                ):\n                    # We shouldn't add two newlines between an indented function and\n                    # a dependent non-indented clause. This is to avoid issues with\n                    # conditional function definitions that are technically top-level\n                    # and therefore get two trailing newlines, but look weird and\n                    # inconsistent when they're followed by elif, else, etc. This is\n                    # worse because these functions only get *one* preceding newline\n                    # already.\n                    before = 1\n                else:\n                    before = 2\n\n        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n            return self._maybe_empty_lines_for_class_or_def(\n                current_line, before, user_had_newline\n            )\n\n        if (\n            self.previous_line.is_import\n            and self.previous_line.depth == 0\n            and current_line.depth == 0\n            and not current_line.is_import\n            and Preview.always_one_newline_after_import in self.mode\n        ):\n            return 1, 0\n\n        if (\n            self.previous_line.is_import\n            and not current_line.is_import\n            and not current_line.is_fmt_pass_converted(first_leaf_matches=is_import)\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        return before, 0"
    },
    {
      "path": "tests/data/cases/preview_fmtpass_imports.py",
      "version": "new",
      "line": 1,
      "kind": "module",
      "qualname": "tests.data.cases.preview_fmtpass_imports",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-09T15:54:26"
}