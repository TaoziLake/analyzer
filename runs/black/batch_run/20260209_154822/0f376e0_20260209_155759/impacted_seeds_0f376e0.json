{
  "commit": "0f376e0",
  "parent": "a8bfcc1040fdfce2e02cdd85dc8bf4e7abe0462f",
  "repo": "D:\\locbench\\black",
  "num_files_in_diff": 4,
  "num_py_files_in_diff": 3,
  "num_seeds": 11,
  "seeds": [
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 167,
      "kind": "function",
      "qualname": "src.black.comments.make_comment",
      "span": [
        151,
        189
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def make_comment(content: str, mode: Mode) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\", '#'\") should have a single\n    space between the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n\n    Comments containing fmt directives are preserved exactly as-is to respect\n    user intent (e.g., `#no space # fmt: skip` stays as-is).\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    # Preserve comments with fmt directives exactly as-is\n    if content.startswith(\"#\") and contains_fmt_directive(content):\n        return content\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if (\n        content\n        and content[0] == \"\\N{NO-BREAK SPACE}\"\n        and not is_type_comment_string(\"# \" + content.lstrip(), mode=mode)\n    ):\n        content = \" \" + content[1:]  # Replace NBSP by a simple space\n    if (\n        Preview.standardize_type_comments in mode\n        and content\n        and \"\\N{NO-BREAK SPACE}\" not in content\n        and is_type_comment_string(\"#\" + content, mode=mode)\n    ):\n        type_part, value_part = content.split(\":\", 1)\n        content = type_part.strip() + \": \" + value_part.strip()\n\n    if content and content[0] not in COMMENT_EXCEPTIONS:\n        content = \" \" + content\n    return \"#\" + content",
      "old_code": "def make_comment(content: str, mode: Mode) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\", '#'\") should have a single\n    space between the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n\n    Comments containing fmt directives are preserved exactly as-is to respect\n    user intent (e.g., `#no space # fmt: skip` stays as-is).\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    # Preserve comments with fmt directives exactly as-is\n    if content.startswith(\"#\") and _contains_fmt_directive(content):\n        return content\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if (\n        content\n        and content[0] == \"\\N{NO-BREAK SPACE}\"\n        and not is_type_comment_string(\"# \" + content.lstrip(), mode=mode)\n    ):\n        content = \" \" + content[1:]  # Replace NBSP by a simple space\n    if (\n        Preview.standardize_type_comments in mode\n        and content\n        and \"\\N{NO-BREAK SPACE}\" not in content\n        and is_type_comment_string(\"#\" + content, mode=mode)\n    ):\n        type_part, value_part = content.split(\":\", 1)\n        content = type_part.strip() + \": \" + value_part.strip()\n\n    if content and content[0] not in COMMENT_EXCEPTIONS:\n        content = \" \" + content\n    return \"#\" + content"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 208,
      "kind": "function",
      "qualname": "src.black.comments._should_process_fmt_comment",
      "span": [
        201,
        218
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _should_process_fmt_comment(\n    comment: ProtoComment, leaf: Leaf\n) -> tuple[bool, bool, bool]:\n    \"\"\"Check if comment should be processed for fmt handling.\n\n    Returns (should_process, is_fmt_off, is_fmt_skip).\n    \"\"\"\n    is_fmt_off = contains_fmt_directive(comment.value, FMT_OFF)\n    is_fmt_skip = contains_fmt_directive(comment.value, FMT_SKIP)\n\n    if not is_fmt_off and not is_fmt_skip:\n        return False, False, False\n\n    # Invalid use when `# fmt: off` is applied before a closing bracket\n    if is_fmt_off and leaf.type in CLOSING_BRACKETS:\n        return False, False, False\n\n    return True, is_fmt_off, is_fmt_skip",
      "old_code": "def _should_process_fmt_comment(\n    comment: ProtoComment, leaf: Leaf\n) -> tuple[bool, bool, bool]:\n    \"\"\"Check if comment should be processed for fmt handling.\n\n    Returns (should_process, is_fmt_off, is_fmt_skip).\n    \"\"\"\n    is_fmt_off = _contains_fmt_directive(comment.value, FMT_OFF)\n    is_fmt_skip = _contains_fmt_directive(comment.value, FMT_SKIP)\n\n    if not is_fmt_off and not is_fmt_skip:\n        return False, False, False\n\n    # Invalid use when `# fmt: off` is applied before a closing bracket\n    if is_fmt_off and leaf.type in CLOSING_BRACKETS:\n        return False, False, False\n\n    return True, is_fmt_off, is_fmt_skip"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 261,
      "kind": "function",
      "qualname": "src.black.comments._handle_comment_only_fmt_block",
      "span": [
        245,
        331
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _handle_comment_only_fmt_block(\n    leaf: Leaf,\n    comment: ProtoComment,\n    previous_consumed: int,\n    mode: Mode,\n) -> bool:\n    \"\"\"Handle fmt:off/on blocks that contain only comments.\n\n    Returns True if a block was converted, False otherwise.\n    \"\"\"\n    all_comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n\n    # Find the first fmt:off and its matching fmt:on\n    fmt_off_idx = None\n    fmt_on_idx = None\n    for idx, c in enumerate(all_comments):\n        if fmt_off_idx is None and contains_fmt_directive(c.value, FMT_OFF):\n            fmt_off_idx = idx\n        if (\n            fmt_off_idx is not None\n            and idx > fmt_off_idx\n            and contains_fmt_directive(c.value, FMT_ON)\n        ):\n            fmt_on_idx = idx\n            break\n\n    # Only proceed if we found both directives\n    if fmt_on_idx is None or fmt_off_idx is None:\n        return False\n\n    comment = all_comments[fmt_off_idx]\n    fmt_on_comment = all_comments[fmt_on_idx]\n    original_prefix = leaf.prefix\n\n    # Build the hidden value\n    start_pos = comment.consumed\n    end_pos = fmt_on_comment.consumed\n    content_between_and_fmt_on = original_prefix[start_pos:end_pos]\n    hidden_value = comment.value + \"\\n\" + content_between_and_fmt_on\n\n    if hidden_value.endswith(\"\\n\"):\n        hidden_value = hidden_value[:-1]\n\n    # Build the standalone comment prefix - preserve all content before fmt:off\n    # including any comments that precede it\n    if fmt_off_idx == 0:\n        # No comments before fmt:off, use previous_consumed\n        pre_fmt_off_consumed = previous_consumed\n    else:\n        # Use the consumed position of the last comment before fmt:off\n        # This preserves all comments and content before the fmt:off directive\n        pre_fmt_off_consumed = all_comments[fmt_off_idx - 1].consumed\n\n    standalone_comment_prefix = (\n        original_prefix[:pre_fmt_off_consumed] + \"\\n\" * comment.newlines\n    )\n\n    fmt_off_prefix = original_prefix.split(comment.value)[0]\n    if \"\\n\" in fmt_off_prefix:\n        fmt_off_prefix = fmt_off_prefix.split(\"\\n\")[-1]\n    standalone_comment_prefix += fmt_off_prefix\n\n    # Update leaf prefix\n    leaf.prefix = original_prefix[fmt_on_comment.consumed :]\n\n    # Insert the STANDALONE_COMMENT\n    parent = leaf.parent\n    assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (prefix only)\"\n\n    leaf_idx = None\n    for idx, child in enumerate(parent.children):\n        if child is leaf:\n            leaf_idx = idx\n            break\n\n    assert leaf_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (leaf index)\"\n\n    parent.insert_child(\n        leaf_idx,\n        Leaf(\n            STANDALONE_COMMENT,\n            hidden_value,\n            prefix=standalone_comment_prefix,\n            fmt_pass_converted_first_leaf=None,\n        ),\n    )\n    return True",
      "old_code": "def _handle_comment_only_fmt_block(\n    leaf: Leaf,\n    comment: ProtoComment,\n    previous_consumed: int,\n    mode: Mode,\n) -> bool:\n    \"\"\"Handle fmt:off/on blocks that contain only comments.\n\n    Returns True if a block was converted, False otherwise.\n    \"\"\"\n    all_comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)\n\n    # Find the first fmt:off and its matching fmt:on\n    fmt_off_idx = None\n    fmt_on_idx = None\n    for idx, c in enumerate(all_comments):\n        if fmt_off_idx is None and c.value in FMT_OFF:\n            fmt_off_idx = idx\n        if fmt_off_idx is not None and idx > fmt_off_idx and c.value in FMT_ON:\n            fmt_on_idx = idx\n            break\n\n    # Only proceed if we found both directives\n    if fmt_on_idx is None or fmt_off_idx is None:\n        return False\n\n    comment = all_comments[fmt_off_idx]\n    fmt_on_comment = all_comments[fmt_on_idx]\n    original_prefix = leaf.prefix\n\n    # Build the hidden value\n    start_pos = comment.consumed\n    end_pos = fmt_on_comment.consumed\n    content_between_and_fmt_on = original_prefix[start_pos:end_pos]\n    hidden_value = comment.value + \"\\n\" + content_between_and_fmt_on\n\n    if hidden_value.endswith(\"\\n\"):\n        hidden_value = hidden_value[:-1]\n\n    # Build the standalone comment prefix - preserve all content before fmt:off\n    # including any comments that precede it\n    if fmt_off_idx == 0:\n        # No comments before fmt:off, use previous_consumed\n        pre_fmt_off_consumed = previous_consumed\n    else:\n        # Use the consumed position of the last comment before fmt:off\n        # This preserves all comments and content before the fmt:off directive\n        pre_fmt_off_consumed = all_comments[fmt_off_idx - 1].consumed\n\n    standalone_comment_prefix = (\n        original_prefix[:pre_fmt_off_consumed] + \"\\n\" * comment.newlines\n    )\n\n    fmt_off_prefix = original_prefix.split(comment.value)[0]\n    if \"\\n\" in fmt_off_prefix:\n        fmt_off_prefix = fmt_off_prefix.split(\"\\n\")[-1]\n    standalone_comment_prefix += fmt_off_prefix\n\n    # Update leaf prefix\n    leaf.prefix = original_prefix[fmt_on_comment.consumed :]\n\n    # Insert the STANDALONE_COMMENT\n    parent = leaf.parent\n    assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (prefix only)\"\n\n    leaf_idx = None\n    for idx, child in enumerate(parent.children):\n        if child is leaf:\n            leaf_idx = idx\n            break\n\n    assert leaf_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (leaf index)\"\n\n    parent.insert_child(\n        leaf_idx,\n        Leaf(\n            STANDALONE_COMMENT,\n            hidden_value,\n            prefix=standalone_comment_prefix,\n            fmt_pass_converted_first_leaf=None,\n        ),\n    )\n    return True"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 408,
      "kind": "function",
      "qualname": "src.black.comments._handle_regular_fmt_block",
      "span": [
        395,
        456
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def _handle_regular_fmt_block(\n    ignored_nodes: list[LN],\n    comment: ProtoComment,\n    previous_consumed: int,\n    is_fmt_skip: bool,\n    lines: Collection[tuple[int, int]],\n    leaf: Leaf,\n) -> None:\n    \"\"\"Handle fmt blocks with actual AST nodes.\"\"\"\n    first = ignored_nodes[0]  # Can be a container node with the `leaf`.\n    parent = first.parent\n    prefix = first.prefix\n\n    if contains_fmt_directive(comment.value, FMT_OFF):\n        first.prefix = prefix[comment.consumed :]\n    if is_fmt_skip:\n        first.prefix = \"\"\n        standalone_comment_prefix = prefix\n    else:\n        standalone_comment_prefix = prefix[:previous_consumed] + \"\\n\" * comment.newlines\n\n    hidden_value = \"\".join(str(n) for n in ignored_nodes)\n    comment_lineno = leaf.lineno - comment.newlines\n\n    if contains_fmt_directive(comment.value, FMT_OFF):\n        fmt_off_prefix = \"\"\n        if len(lines) > 0 and not any(\n            line[0] <= comment_lineno <= line[1] for line in lines\n        ):\n            # keeping indentation of comment by preserving original whitespaces.\n            fmt_off_prefix = prefix.split(comment.value)[0]\n            if \"\\n\" in fmt_off_prefix:\n                fmt_off_prefix = fmt_off_prefix.split(\"\\n\")[-1]\n        standalone_comment_prefix += fmt_off_prefix\n        hidden_value = comment.value + \"\\n\" + hidden_value\n\n    if is_fmt_skip:\n        hidden_value += comment.leading_whitespace + comment.value\n\n    if hidden_value.endswith(\"\\n\"):\n        # That happens when one of the `ignored_nodes` ended with a NEWLINE\n        # leaf (possibly followed by a DEDENT).\n        hidden_value = hidden_value[:-1]\n\n    first_idx: int | None = None\n    for ignored in ignored_nodes:\n        index = ignored.remove()\n        if first_idx is None:\n            first_idx = index\n\n    assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (1)\"\n    assert first_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (2)\"\n\n    parent.insert_child(\n        first_idx,\n        Leaf(\n            STANDALONE_COMMENT,\n            hidden_value,\n            prefix=standalone_comment_prefix,\n            fmt_pass_converted_first_leaf=first_leaf_of(first),\n        ),\n    )",
      "old_code": "def _handle_regular_fmt_block(\n    ignored_nodes: list[LN],\n    comment: ProtoComment,\n    previous_consumed: int,\n    is_fmt_skip: bool,\n    lines: Collection[tuple[int, int]],\n    leaf: Leaf,\n) -> None:\n    \"\"\"Handle fmt blocks with actual AST nodes.\"\"\"\n    first = ignored_nodes[0]  # Can be a container node with the `leaf`.\n    parent = first.parent\n    prefix = first.prefix\n\n    if comment.value in FMT_OFF:\n        first.prefix = prefix[comment.consumed :]\n    if is_fmt_skip:\n        first.prefix = \"\"\n        standalone_comment_prefix = prefix\n    else:\n        standalone_comment_prefix = prefix[:previous_consumed] + \"\\n\" * comment.newlines\n\n    hidden_value = \"\".join(str(n) for n in ignored_nodes)\n    comment_lineno = leaf.lineno - comment.newlines\n\n    if comment.value in FMT_OFF:\n        fmt_off_prefix = \"\"\n        if len(lines) > 0 and not any(\n            line[0] <= comment_lineno <= line[1] for line in lines\n        ):\n            # keeping indentation of comment by preserving original whitespaces.\n            fmt_off_prefix = prefix.split(comment.value)[0]\n            if \"\\n\" in fmt_off_prefix:\n                fmt_off_prefix = fmt_off_prefix.split(\"\\n\")[-1]\n        standalone_comment_prefix += fmt_off_prefix\n        hidden_value = comment.value + \"\\n\" + hidden_value\n\n    if is_fmt_skip:\n        hidden_value += comment.leading_whitespace + comment.value\n\n    if hidden_value.endswith(\"\\n\"):\n        # That happens when one of the `ignored_nodes` ended with a NEWLINE\n        # leaf (possibly followed by a DEDENT).\n        hidden_value = hidden_value[:-1]\n\n    first_idx: int | None = None\n    for ignored in ignored_nodes:\n        index = ignored.remove()\n        if first_idx is None:\n            first_idx = index\n\n    assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (1)\"\n    assert first_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (2)\"\n\n    parent.insert_child(\n        first_idx,\n        Leaf(\n            STANDALONE_COMMENT,\n            hidden_value,\n            prefix=standalone_comment_prefix,\n            fmt_pass_converted_first_leaf=first_leaf_of(first),\n        ),\n    )"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 467,
      "kind": "function",
      "qualname": "src.black.comments.generate_ignored_nodes",
      "span": [
        459,
        505
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def generate_ignored_nodes(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Starting from the container of `leaf`, generate all leaves until `# fmt: on`.\n\n    If comment is skip, returns leaf only.\n    Stops at the end of the block.\n    \"\"\"\n    if contains_fmt_directive(comment.value, FMT_SKIP):\n        yield from _generate_ignored_nodes_from_fmt_skip(leaf, comment, mode)\n        return\n    container: LN | None = container_of(leaf)\n    while container is not None and container.type != token.ENDMARKER:\n        if is_fmt_on(container, mode=mode):\n            return\n\n        # fix for fmt: on in children\n        if children_contains_fmt_on(container, mode=mode):\n            for index, child in enumerate(container.children):\n                if isinstance(child, Leaf) and is_fmt_on(child, mode=mode):\n                    if child.type in CLOSING_BRACKETS:\n                        # This means `# fmt: on` is placed at a different bracket level\n                        # than `# fmt: off`. This is an invalid use, but as a courtesy,\n                        # we include this closing bracket in the ignored nodes.\n                        # The alternative is to fail the formatting.\n                        yield child\n                    return\n                if (\n                    child.type == token.INDENT\n                    and index < len(container.children) - 1\n                    and children_contains_fmt_on(\n                        container.children[index + 1], mode=mode\n                    )\n                ):\n                    # This means `# fmt: on` is placed right after an indentation\n                    # level, and we shouldn't swallow the previous INDENT token.\n                    return\n                if children_contains_fmt_on(child, mode=mode):\n                    return\n                yield child\n        else:\n            if container.type == token.DEDENT and container.next_sibling is None:\n                # This can happen when there is no matching `# fmt: on` comment at the\n                # same level as `# fmt: on`. We need to keep this DEDENT.\n                return\n            yield container\n            container = container.next_sibling",
      "old_code": "def generate_ignored_nodes(\n    leaf: Leaf, comment: ProtoComment, mode: Mode\n) -> Iterator[LN]:\n    \"\"\"Starting from the container of `leaf`, generate all leaves until `# fmt: on`.\n\n    If comment is skip, returns leaf only.\n    Stops at the end of the block.\n    \"\"\"\n    if _contains_fmt_directive(comment.value, FMT_SKIP):\n        yield from _generate_ignored_nodes_from_fmt_skip(leaf, comment, mode)\n        return\n    container: LN | None = container_of(leaf)\n    while container is not None and container.type != token.ENDMARKER:\n        if is_fmt_on(container, mode=mode):\n            return\n\n        # fix for fmt: on in children\n        if children_contains_fmt_on(container, mode=mode):\n            for index, child in enumerate(container.children):\n                if isinstance(child, Leaf) and is_fmt_on(child, mode=mode):\n                    if child.type in CLOSING_BRACKETS:\n                        # This means `# fmt: on` is placed at a different bracket level\n                        # than `# fmt: off`. This is an invalid use, but as a courtesy,\n                        # we include this closing bracket in the ignored nodes.\n                        # The alternative is to fail the formatting.\n                        yield child\n                    return\n                if (\n                    child.type == token.INDENT\n                    and index < len(container.children) - 1\n                    and children_contains_fmt_on(\n                        container.children[index + 1], mode=mode\n                    )\n                ):\n                    # This means `# fmt: on` is placed right after an indentation\n                    # level, and we shouldn't swallow the previous INDENT token.\n                    return\n                if children_contains_fmt_on(child, mode=mode):\n                    return\n                yield child\n        else:\n            if container.type == token.DEDENT and container.next_sibling is None:\n                # This can happen when there is no matching `# fmt: on` comment at the\n                # same level as `# fmt: on`. We need to keep this DEDENT.\n                return\n            yield container\n            container = container.next_sibling"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 724,
      "kind": "function",
      "qualname": "src.black.comments.is_fmt_on",
      "span": [
        718,
        728
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def is_fmt_on(container: LN, mode: Mode) -> bool:\n    \"\"\"Determine whether formatting is switched on within a container.\n    Determined by whether the last `# fmt:` comment is `on` or `off`.\n    \"\"\"\n    fmt_on = False\n    for comment in list_comments(container.prefix, is_endmarker=False, mode=mode):\n        if contains_fmt_directive(comment.value, FMT_ON):\n            fmt_on = True\n        elif contains_fmt_directive(comment.value, FMT_OFF):\n            fmt_on = False\n    return fmt_on",
      "old_code": "def is_fmt_on(container: LN, mode: Mode) -> bool:\n    \"\"\"Determine whether formatting is switched on within a container.\n    Determined by whether the last `# fmt:` comment is `on` or `off`.\n    \"\"\"\n    fmt_on = False\n    for comment in list_comments(container.prefix, is_endmarker=False, mode=mode):\n        if comment.value in FMT_ON:\n            fmt_on = True\n        elif comment.value in FMT_OFF:\n            fmt_on = False\n    return fmt_on"
    },
    {
      "path": "src/black/comments.py",
      "version": "new",
      "line": 755,
      "kind": "function",
      "qualname": "src.black.comments.contains_fmt_directive",
      "span": [
        755,
        784
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def contains_fmt_directive(\n    comment_line: str, directives: set[str] = FMT_OFF | FMT_ON | FMT_SKIP\n) -> bool:\n    \"\"\"\n    Checks if the given comment contains format directives, alone or paired with\n    other comments.\n\n    Defaults to checking all directives (skip, off, on, yapf), but can be\n    narrowed to specific ones.\n\n    Matching styles:\n      # foobar                    <-- single comment\n      # foobar # foobar # foobar  <-- multiple comments\n      # foobar; foobar            <-- list of comments (; separated)\n    \"\"\"\n    semantic_comment_blocks = [\n        comment_line,\n        *[\n            _COMMENT_PREFIX + comment.strip()\n            for comment in comment_line.split(_COMMENT_PREFIX)[1:]\n        ],\n        *[\n            _COMMENT_PREFIX + comment.strip()\n            for comment in comment_line.strip(_COMMENT_PREFIX).split(\n                _COMMENT_LIST_SEPARATOR\n            )\n        ],\n    ]\n\n    return any(comment in directives for comment in semantic_comment_blocks)",
      "old_code": null
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 23,
      "kind": "module",
      "qualname": "src.black.linegen",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 390,
      "kind": "function",
      "qualname": "src.black.linegen.LineGenerator.visit_STANDALONE_COMMENT",
      "span": [
        389,
        430
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n        any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n        if not any_open_brackets:\n            yield from self.line()\n        # STANDALONE_COMMENT nodes created by our special handling in\n        # normalize_fmt_off for comment-only blocks have fmt:off as the first\n        # line and fmt:on as the last line (each directive on its own line,\n        # not embedded in other text). These should be appended directly\n        # without calling visit_default, which would process their prefix and\n        # lose indentation. Normal STANDALONE_COMMENT nodes go through\n        # visit_default.\n        value = leaf.value\n        lines = value.splitlines()\n        is_fmt_off_block = (\n            len(lines) >= 2\n            and contains_fmt_directive(lines[0], FMT_OFF)\n            and contains_fmt_directive(lines[-1], FMT_ON)\n        )\n        if is_fmt_off_block:\n            # This is a fmt:off/on block from normalize_fmt_off - we still need\n            # to process any prefix comments (like markdown comments) but append\n            # the fmt block itself directly to preserve its formatting\n\n            # Only process prefix comments if there actually is a prefix with comments\n            if leaf.prefix and any(\n                line.strip().startswith(\"#\")\n                and not contains_fmt_directive(line.strip())\n                for line in leaf.prefix.split(\"\\n\")\n            ):\n                for comment in generate_comments(leaf, mode=self.mode):\n                    yield from self.line()\n                    self.current_line.append(comment)\n                    yield from self.line()\n                # Clear the prefix since we've processed it as comments above\n                leaf.prefix = \"\"\n\n            self.current_line.append(leaf)\n            if not any_open_brackets:\n                yield from self.line()\n        else:\n            # Normal standalone comment - process through visit_default\n            yield from self.visit_default(leaf)",
      "old_code": "    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n        if not self.current_line.bracket_tracker.any_open_brackets():\n            yield from self.line()\n        # STANDALONE_COMMENT nodes created by our special handling in\n        # normalize_fmt_off for comment-only blocks have fmt:off as the first\n        # line and fmt:on as the last line (each directive on its own line,\n        # not embedded in other text). These should be appended directly\n        # without calling visit_default, which would process their prefix and\n        # lose indentation. Normal STANDALONE_COMMENT nodes go through\n        # visit_default.\n        value = leaf.value\n        lines = value.splitlines()\n        if len(lines) >= 2:\n            # Check if first line (after stripping whitespace) is exactly a\n            # fmt:off directive\n            first_line = lines[0].lstrip()\n            first_is_fmt_off = first_line in FMT_OFF\n            # Check if last line (after stripping whitespace) is exactly a\n            # fmt:on directive\n            last_line = lines[-1].lstrip()\n            last_is_fmt_on = last_line in FMT_ON\n            is_fmt_off_block = first_is_fmt_off and last_is_fmt_on\n        else:\n            is_fmt_off_block = False\n        if is_fmt_off_block:\n            # This is a fmt:off/on block from normalize_fmt_off - we still need\n            # to process any prefix comments (like markdown comments) but append\n            # the fmt block itself directly to preserve its formatting\n\n            # Only process prefix comments if there actually is a prefix with comments\n            if leaf.prefix and any(\n                line.strip().startswith(\"#\")\n                and not _contains_fmt_directive(line.strip())\n                for line in leaf.prefix.split(\"\\n\")\n            ):\n                for comment in generate_comments(leaf, mode=self.mode):\n                    yield from self.line()\n                    self.current_line.append(comment)\n                    yield from self.line()\n                # Clear the prefix since we've processed it as comments above\n                leaf.prefix = \"\"\n\n            self.current_line.append(leaf)\n            yield from self.line()\n        else:\n            # Normal standalone comment - process through visit_default\n            yield from self.visit_default(leaf)"
    },
    {
      "path": "src/black/linegen.py",
      "version": "new",
      "line": 1482,
      "kind": "function",
      "qualname": "src.black.linegen.normalize_invisible_parens",
      "span": [
        1470,
        1603
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def normalize_invisible_parens(\n    node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]\n) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):\n        if contains_fmt_directive(pc.value, FMT_OFF):\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n\n    # The multiple context managers grammar has a different pattern, thus this is\n    # separate from the for-loop below. This possibly wraps them in invisible parens,\n    # and later will be removed in remove_with_parens when needed.\n    if node.type == syms.with_stmt:\n        _maybe_wrap_cms_in_parens(node, mode, features)\n\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(\n                child, parens_after=parens_after, mode=mode, features=features\n            )\n\n        # Fixes a bug where invisible parens are not properly wrapped around\n        # case blocks.\n        if isinstance(child, Node) and child.type == syms.case_block:\n            normalize_invisible_parens(\n                child, parens_after={\"case\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around if guards in case blocks\n        if isinstance(child, Node) and child.type == syms.guard:\n            normalize_invisible_parens(\n                child, parens_after={\"if\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        # Check for assignment LHS with preview feature enabled\n        if (\n            Preview.remove_parens_from_assignment_lhs in mode\n            and index == 0\n            and isinstance(child, Node)\n            and child.type == syms.atom\n            and node.type == syms.expr_stmt\n            and not _atom_has_magic_trailing_comma(child, mode)\n            and not _is_atom_multiline(child)\n        ):\n            if maybe_make_parens_invisible_in_atom(\n                child,\n                parent=node,\n                mode=mode,\n                features=features,\n                remove_brackets_around_comma=True,\n                allow_star_expr=True,\n            ):\n                wrap_in_parentheses(node, child, visible=False)\n\n        if check_lpar:\n            if (\n                child.type == syms.atom\n                and node.type == syms.for_stmt\n                and isinstance(child.prev_sibling, Leaf)\n                and child.prev_sibling.type == token.NAME\n                and child.prev_sibling.value == \"for\"\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child,\n                    parent=node,\n                    mode=mode,\n                    features=features,\n                    remove_brackets_around_comma=True,\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif isinstance(child, Node) and node.type == syms.with_stmt:\n                remove_with_parens(child, node, mode=mode, features=features)\n            elif child.type == syms.atom and not (\n                \"in\" in parens_after\n                and len(child.children) == 3\n                and is_lpar_token(child.children[0])\n                and is_rpar_token(child.children[-1])\n                and child.children[1].type == syms.test\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child, parent=node, mode=mode, features=features\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                _normalize_import_from(node, child, index)\n                break\n            elif (\n                index == 1\n                and child.type == token.STAR\n                and node.type == syms.except_clause\n            ):\n                # In except* (PEP 654), the star is actually part of\n                # of the keyword. So we need to skip the insertion of\n                # invisible parentheses to work more precisely.\n                continue\n\n            elif (\n                isinstance(child, Leaf)\n                and child.next_sibling is not None\n                and child.next_sibling.type == token.COLON\n                and child.value == \"case\"\n            ):\n                # A special patch for \"case case:\" scenario, the second occurrence\n                # of case will be not parsed as a Python keyword.\n                break\n\n            elif not is_multiline_string(child):\n                wrap_in_parentheses(node, child, visible=False)\n\n        comma_check = child.type == token.COMMA\n\n        check_lpar = isinstance(child, Leaf) and (\n            child.value in parens_after or comma_check\n        )",
      "old_code": "def normalize_invisible_parens(\n    node: Node, parens_after: set[str], *, mode: Mode, features: Collection[Feature]\n) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n\n    # The multiple context managers grammar has a different pattern, thus this is\n    # separate from the for-loop below. This possibly wraps them in invisible parens,\n    # and later will be removed in remove_with_parens when needed.\n    if node.type == syms.with_stmt:\n        _maybe_wrap_cms_in_parens(node, mode, features)\n\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(\n                child, parens_after=parens_after, mode=mode, features=features\n            )\n\n        # Fixes a bug where invisible parens are not properly wrapped around\n        # case blocks.\n        if isinstance(child, Node) and child.type == syms.case_block:\n            normalize_invisible_parens(\n                child, parens_after={\"case\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around if guards in case blocks\n        if isinstance(child, Node) and child.type == syms.guard:\n            normalize_invisible_parens(\n                child, parens_after={\"if\"}, mode=mode, features=features\n            )\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        # Check for assignment LHS with preview feature enabled\n        if (\n            Preview.remove_parens_from_assignment_lhs in mode\n            and index == 0\n            and isinstance(child, Node)\n            and child.type == syms.atom\n            and node.type == syms.expr_stmt\n            and not _atom_has_magic_trailing_comma(child, mode)\n            and not _is_atom_multiline(child)\n        ):\n            if maybe_make_parens_invisible_in_atom(\n                child,\n                parent=node,\n                mode=mode,\n                features=features,\n                remove_brackets_around_comma=True,\n                allow_star_expr=True,\n            ):\n                wrap_in_parentheses(node, child, visible=False)\n\n        if check_lpar:\n            if (\n                child.type == syms.atom\n                and node.type == syms.for_stmt\n                and isinstance(child.prev_sibling, Leaf)\n                and child.prev_sibling.type == token.NAME\n                and child.prev_sibling.value == \"for\"\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child,\n                    parent=node,\n                    mode=mode,\n                    features=features,\n                    remove_brackets_around_comma=True,\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif isinstance(child, Node) and node.type == syms.with_stmt:\n                remove_with_parens(child, node, mode=mode, features=features)\n            elif child.type == syms.atom and not (\n                \"in\" in parens_after\n                and len(child.children) == 3\n                and is_lpar_token(child.children[0])\n                and is_rpar_token(child.children[-1])\n                and child.children[1].type == syms.test\n            ):\n                if maybe_make_parens_invisible_in_atom(\n                    child, parent=node, mode=mode, features=features\n                ):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                _normalize_import_from(node, child, index)\n                break\n            elif (\n                index == 1\n                and child.type == token.STAR\n                and node.type == syms.except_clause\n            ):\n                # In except* (PEP 654), the star is actually part of\n                # of the keyword. So we need to skip the insertion of\n                # invisible parentheses to work more precisely.\n                continue\n\n            elif (\n                isinstance(child, Leaf)\n                and child.next_sibling is not None\n                and child.next_sibling.type == token.COLON\n                and child.value == \"case\"\n            ):\n                # A special patch for \"case case:\" scenario, the second occurrence\n                # of case will be not parsed as a Python keyword.\n                break\n\n            elif not is_multiline_string(child):\n                wrap_in_parentheses(node, child, visible=False)\n\n        comma_check = child.type == token.COMMA\n\n        check_lpar = isinstance(child, Leaf) and (\n            child.value in parens_after or comma_check\n        )"
    },
    {
      "path": "tests/data/cases/fmtskip11.py",
      "version": "new",
      "line": 7,
      "kind": "module",
      "qualname": "tests.data.cases.fmtskip11",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    }
  ],
  "generated_at": "2026-02-09T15:57:59"
}