--- a/src/black/comments.py
+++ b/src/black/comments.py
@@ -151,13 +151,18 @@
 def make_comment(content: str, mode: Mode) -> str:
     """Return a consistently formatted comment from the given `content` string.
 
-    All comments (except for "##", "#!", "#:", '#'") should have a single
-    space between the hash sign and the content.
+    All comments (except for "##", "#!", "#:", '#') should have a single space between the hash sign and the content.
 
     If `content` didn't start with a hash sign, one is provided.
 
-    Comments containing fmt directives are preserved exactly as-is to respect
-    user intent (e.g., `#no space # fmt: skip` stays as-is).
+    Comments containing fmt directives are preserved exactly as-is to respect user intent (e.g., `#no space # fmt: skip` stays as-is).
+
+    Args:
+        content: The raw comment content to format
+        mode: The formatting mode to apply
+
+    Returns:
+        A consistently formatted comment string
     """
     content = content.rstrip()
     if not content:
@@ -204,6 +209,13 @@
     """Check if comment should be processed for fmt handling.
 
     Returns (should_process, is_fmt_off, is_fmt_skip).
+
+    Args:
+        comment: ProtoComment object containing the comment value
+        leaf: Leaf node to check for invalid closing bracket context
+
+    Returns:
+        Tuple indicating (whether to process, whether fmt:off is present, whether fmt:skip is present)
     """
     is_fmt_off = contains_fmt_directive(comment.value, FMT_OFF)
     is_fmt_skip = contains_fmt_directive(comment.value, FMT_SKIP)
@@ -250,7 +262,14 @@
 ) -> bool:
     """Handle fmt:off/on blocks that contain only comments.
 
-    Returns True if a block was converted, False otherwise.
+    Args:
+        leaf: The leaf node containing the comment prefix to process
+        comment: The ProtoComment object containing position and formatting info
+        previous_consumed: Position in prefix before this comment block started
+        mode: Black's formatting mode configuration
+
+    Returns:
+        True if a fmt:off/on block was successfully converted to a STANDALONE_COMMENT, False otherwise
     """
     all_comments = list_comments(leaf.prefix, is_endmarker=False, mode=mode)
 
@@ -336,7 +355,16 @@
 ) -> bool:
     """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
 
-    Returns True if a pair was converted.
+    Args:
+        node (Node): The AST node to process
+        mode (Mode): Formatting mode configuration
+        lines (Collection[tuple[int, int]]): Collection of (start, end) line ranges to process
+
+    Returns:
+        bool: True if a fmt: off/on pair was successfully converted to a standalone comment
+
+    Raises:
+        No exceptions expected under normal operation
     """
     for leaf in node.leaves():
         # Skip STANDALONE_COMMENT nodes that were created by fmt:off/on processing
@@ -400,7 +428,25 @@
     lines: Collection[tuple[int, int]],
     leaf: Leaf,
 ) -> None:
-    """Handle fmt blocks with actual AST nodes."""
+    """Handle fmt blocks with actual AST nodes.
+
+    Args:
+        ignored_nodes: List of nodes to be ignored during formatting.
+        comment: ProtoComment object containing comment metadata.
+        previous_consumed: Number of previously consumed characters.
+        is_fmt_skip: Boolean indicating if FMT_SKIP is active.
+        lines: Collection of line ranges for current file.
+        leaf: Leaf node containing comment location information.
+
+    Returns:
+        None. Modifies the AST in-place by inserting a STANDALONE_COMMENT node.
+
+    Raises:
+        AssertionError: If parent or index information is missing during AST manipulation.
+
+    Note:
+        Uses contains_fmt_directive() to check FMT_OFF conditions, allowing more flexible directive matching than direct string comparison.
+    """
     first = ignored_nodes[0]  # Can be a container node with the `leaf`.
     parent = first.parent
     prefix = first.prefix
@@ -463,6 +509,17 @@
 
     If comment is skip, returns leaf only.
     Stops at the end of the block.
+
+    Args:
+        leaf: Leaf node to start from
+        comment: ProtoComment associated with the leaf
+        mode: Mode object controlling formatting behavior
+
+    Returns:
+        Iterator over LN nodes that should be ignored during formatting
+
+    Raises:
+        None
     """
     if contains_fmt_directive(comment.value, FMT_SKIP):
         yield from _generate_ignored_nodes_from_fmt_skip(leaf, comment, mode)
@@ -717,7 +774,14 @@
 
 def is_fmt_on(container: LN, mode: Mode) -> bool:
     """Determine whether formatting is switched on within a container.
-    Determined by whether the last `# fmt:` comment is `on` or `off`.
+    Determined by whether the last `# fmt:` comment contains an `on` or `off` directive.
+
+    Args:
+        container: Node container to check for formatting comments
+        mode: Black configuration mode for comment parsing
+
+    Returns:
+        bool: True if last valid directive is `on`, False if `off`
     """
     fmt_on = False
     for comment in list_comments(container.prefix, is_endmarker=False, mode=mode):
@@ -729,7 +793,18 @@
 
 
 def children_contains_fmt_on(container: LN, mode: Mode) -> bool:
-    """Determine if children have formatting switched on."""
+    """Determine if any child node in the container has formatting explicitly enabled.
+
+    Args:
+        container: Node container to check children of
+        mode: Mode object controlling formatting behavior
+
+    Returns:
+        True if any child's first leaf has formatting enabled, False otherwise
+
+    Raises:
+        None
+    """
     for child in container.children:
         leaf = first_leaf_of(child)
         if leaf is not None and is_fmt_on(leaf, mode=mode):
@@ -755,17 +830,17 @@
 def contains_fmt_directive(
     comment_line: str, directives: set[str] = FMT_OFF | FMT_ON | FMT_SKIP
 ) -> bool:
-    """
-    Checks if the given comment contains format directives, alone or paired with
-    other comments.
-
-    Defaults to checking all directives (skip, off, on, yapf), but can be
-    narrowed to specific ones.
-
-    Matching styles:
-      # foobar                    <-- single comment
-      # foobar # foobar # foobar  <-- multiple comments
-      # foobar; foobar            <-- list of comments (; separated)
+    """Checks if a comment line contains format directives, supporting multiple comment styles.
+
+    Args:
+        comment_line (str): The comment line to check.
+        directives (set[str], optional): Set of directives to check against. Defaults to all directives (FMT_OFF, FMT_ON, FMT_SKIP, and yapf variants).
+
+    Returns:
+        bool: True if any directive is found in the comment line.
+
+    Notes:
+        Handles multiple comment styles including single comments, chained comments (# ... # ...), and semicolon-separated lists.
     """
     semantic_comment_blocks = [
         comment_line,

--- a/src/black/linegen.py
+++ b/src/black/linegen.py
@@ -387,6 +387,17 @@
         yield from self.line()
 
     def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
+        """Process a standalone comment leaf node, handling fmt:off/on blocks specially.
+
+        Args:
+            leaf: The Leaf node containing the standalone comment.
+
+        Returns:
+            An iterator of Line objects representing the formatted comment.
+
+        Raises:
+            No exceptions are explicitly raised, but may propagate errors from line generation or comment processing.
+        """
         any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
         if not any_open_brackets:
             yield from self.line()
@@ -1472,11 +1483,18 @@
 ) -> None:
     """Make existing optional parentheses invisible or create new ones.
 
-    `parens_after` is a set of string leaf values immediately after which parens
-    should be put.
-
-    Standardizes on visible parentheses for single-element tuples, and keeps
-    existing visible parentheses for other tuples and generator expressions.
+    `parens_after` is a set of string leaf values immediately after which parens should be put.
+
+    Standardizes on visible parentheses for single-element tuples, and keeps existing visible parentheses for other tuples and generator expressions.
+
+    Args:
+        node: The node to process
+        parens_after: Set of string values indicating where parentheses should be inserted
+        mode: Formatting mode configuration
+        features: Collection of active formatting features
+
+    Returns:
+        None
     """
     for pc in list_comments(node.prefix, is_endmarker=False, mode=mode):
         if contains_fmt_directive(pc.value, FMT_OFF):
