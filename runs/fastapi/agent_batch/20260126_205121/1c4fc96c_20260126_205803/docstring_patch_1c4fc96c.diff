--- a/docs_src/header_params/tutorial003_an_py39.py
+++ b/docs_src/header_params/tutorial003_an_py39.py
@@ -7,4 +7,9 @@
 
 @app.get("/items/")
 async def read_items(x_token: Annotated[Union[list[str], None], Header()] = None):
+    """TODO: docstring
+
+    Args:
+        x_token:
+    """
     return {"X-Token values": x_token}

--- a/fastapi/_compat/shared.py
+++ b/fastapi/_compat/shared.py
@@ -49,6 +49,11 @@
 def lenient_issubclass(
     cls: Any, class_or_tuple: Union[type[Any], tuple[type[Any], ...], None]
 ) -> bool:
+    """TODO: docstring
+
+    Args:
+        class_or_tuple:
+    """
     try:
         return isinstance(cls, type) and issubclass(cls, class_or_tuple)  # type: ignore[arg-type]
     except TypeError:  # pragma: no cover
@@ -58,12 +63,22 @@
 
 
 def _annotation_is_sequence(annotation: Union[type[Any], None]) -> bool:
+    """TODO: docstring
+
+    Args:
+        annotation:
+    """
     if lenient_issubclass(annotation, (str, bytes)):
         return False
     return lenient_issubclass(annotation, sequence_types)
 
 
 def field_annotation_is_sequence(annotation: Union[type[Any], None]) -> bool:
+    """TODO: docstring
+
+    Args:
+        annotation:
+    """
     origin = get_origin(annotation)
     if origin is Union or origin is UnionType:
         for arg in get_args(annotation):
@@ -76,10 +91,20 @@
 
 
 def value_is_sequence(value: Any) -> bool:
+    """TODO: docstring
+
+    Args:
+        value:
+    """
     return isinstance(value, sequence_types) and not isinstance(value, (str, bytes))
 
 
 def _annotation_is_complex(annotation: Union[type[Any], None]) -> bool:
+    """TODO: docstring
+
+    Args:
+        annotation:
+    """
     return (
         lenient_issubclass(
             annotation, (BaseModel, may_v1.BaseModel, Mapping, UploadFile)
@@ -90,6 +115,11 @@
 
 
 def field_annotation_is_complex(annotation: Union[type[Any], None]) -> bool:
+    """TODO: docstring
+
+    Args:
+        annotation:
+    """
     origin = get_origin(annotation)
     if origin is Union or origin is UnionType:
         return any(field_annotation_is_complex(arg) for arg in get_args(annotation))
@@ -111,6 +141,11 @@
 
 
 def field_annotation_is_scalar_sequence(annotation: Union[type[Any], None]) -> bool:
+    """TODO: docstring
+
+    Args:
+        annotation:
+    """
     origin = get_origin(annotation)
     if origin is Union or origin is UnionType:
         at_least_one_scalar_sequence = False

--- a/fastapi/_compat/v2.py
+++ b/fastapi/_compat/v2.py
@@ -74,6 +74,11 @@
 
 # TODO: remove when dropping support for Pydantic < v2.12.3
 def asdict(field_info: FieldInfo) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        field_info:
+    """
     attributes = {}
     for attr in _Attrs:
         value = getattr(field_info, attr, Undefined)
@@ -169,6 +174,13 @@
         *,
         loc: tuple[Union[int, str], ...] = (),
     ) -> tuple[Any, Union[list[dict[str, Any]], None]]:
+        """TODO: docstring
+
+        Args:
+            value:
+            values:
+            loc:
+        """
         try:
             return (
                 self._type_adapter.validate_python(value, from_attributes=True),
@@ -246,6 +258,14 @@
     ],
     separate_input_output_schemas: bool = True,
 ) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        field:
+        model_name_map:
+        field_mapping:
+        separate_input_output_schemas:
+    """
     override_mode: Union[Literal["validation"], None] = (
         None
         if (separate_input_output_schemas or _has_computed_fields(field))
@@ -277,6 +297,13 @@
     dict[tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue],
     dict[str, dict[str, Any]],
 ]:
+    """TODO: docstring
+
+    Args:
+        fields:
+        model_name_map:
+        separate_input_output_schemas:
+    """
     schema_generator = GenerateJsonSchema(ref_template=REF_TEMPLATE)
     validation_fields = [field for field in fields if field.mode == "validation"]
     serialization_fields = [field for field in fields if field.mode == "serialization"]
@@ -337,6 +364,12 @@
     schema: dict[str, Any],
     old_name_to_new_name_map: dict[str, str],
 ) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        schema:
+        old_name_to_new_name_map:
+    """
     new_schema = deepcopy(schema)
     for key, value in new_schema.items():
         if key == "$ref":
@@ -379,6 +412,13 @@
     dict[tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue],
     dict[str, Any],
 ]:
+    """TODO: docstring
+
+    Args:
+        model_name_map:
+        definitions:
+        field_mapping:
+    """
     old_name_to_new_name_map = {}
     for field_key, schema in field_mapping.items():
         model = field_key[0].type_
@@ -448,6 +488,12 @@
 
 
 def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]:
+    """TODO: docstring
+
+    Args:
+        field:
+        value:
+    """
     origin_type = get_origin(field.field_info.annotation) or field.field_info.annotation
     if origin_type is Union or origin_type is UnionType:  # Handle optional sequences
         union_args = get_args(field.field_info.annotation)
@@ -461,6 +507,11 @@
 
 
 def get_missing_field_error(loc: tuple[str, ...]) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        loc:
+    """
     error = ValidationError.from_exception_data(
         "Field required", [{"type": "missing", "loc": loc, "input": {}}]
     ).errors(include_url=False)[0]
@@ -471,12 +522,23 @@
 def create_body_model(
     *, fields: Sequence[ModelField], model_name: str
 ) -> type[BaseModel]:
+    """TODO: docstring
+
+    Args:
+        fields:
+        model_name:
+    """
     field_params = {f.name: (f.field_info.annotation, f.field_info) for f in fields}
     BodyModel: type[BaseModel] = create_model(model_name, **field_params)  # type: ignore[call-overload]
     return BodyModel
 
 
 def get_model_fields(model: type[BaseModel]) -> list[ModelField]:
+    """TODO: docstring
+
+    Args:
+        model:
+    """
     model_fields: list[ModelField] = []
     for name, field_info in model.model_fields.items():
         type_ = field_info.annotation
@@ -506,6 +568,11 @@
 
 
 def get_model_name_map(unique_models: TypeModelSet) -> dict[TypeModelOrEnum, str]:
+    """TODO: docstring
+
+    Args:
+        unique_models:
+    """
     name_model_map = {}
     conflicting_names: set[str] = set()
     for model in unique_models:
@@ -526,6 +593,12 @@
 def get_flat_models_from_model(
     model: type["BaseModel"], known_models: Union[TypeModelSet, None] = None
 ) -> TypeModelSet:
+    """TODO: docstring
+
+    Args:
+        model:
+        known_models:
+    """
     known_models = known_models or set()
     fields = get_model_fields(model)
     get_flat_models_from_fields(fields, known_models=known_models)

--- a/fastapi/applications.py
+++ b/fastapi/applications.py
@@ -851,6 +851,47 @@
             ),
         ],
     ) -> None:
+        """TODO: docstring
+
+        Args:
+            debug:
+            routes:
+            title:
+            summary:
+            description:
+            version:
+            openapi_url:
+            openapi_tags:
+            servers:
+            dependencies:
+            default_response_class:
+            redirect_slashes:
+            docs_url:
+            redoc_url:
+            swagger_ui_oauth2_redirect_url:
+            swagger_ui_init_oauth:
+            middleware:
+            exception_handlers:
+            on_startup:
+            on_shutdown:
+            lifespan:
+            terms_of_service:
+            contact:
+            license_info:
+            openapi_prefix:
+            root_path:
+            root_path_in_servers:
+            responses:
+            callbacks:
+            webhooks:
+            deprecated:
+            include_in_schema:
+            swagger_ui_parameters:
+            generate_unique_id_function:
+            separate_input_output_schemas:
+            openapi_external_docs:
+            **extra:
+        """
         self.debug = debug
         self.title = title
         self.summary = summary
@@ -1166,6 +1207,34 @@
             generate_unique_id
         ),
     ) -> None:
+        """TODO: docstring
+
+        Args:
+            path:
+            endpoint:
+            response_model:
+            status_code:
+            tags:
+            dependencies:
+            summary:
+            description:
+            response_description:
+            responses:
+            deprecated:
+            methods:
+            operation_id:
+            response_model_include:
+            response_model_exclude:
+            response_model_by_alias:
+            response_model_exclude_unset:
+            response_model_exclude_defaults:
+            response_model_exclude_none:
+            include_in_schema:
+            response_class:
+            name:
+            openapi_extra:
+            generate_unique_id_function:
+        """
         self.router.add_api_route(
             path,
             endpoint=endpoint,
@@ -1222,6 +1291,33 @@
             generate_unique_id
         ),
     ) -> Callable[[DecoratedCallable], DecoratedCallable]:
+        """TODO: docstring
+
+        Args:
+            path:
+            response_model:
+            status_code:
+            tags:
+            dependencies:
+            summary:
+            description:
+            response_description:
+            responses:
+            deprecated:
+            methods:
+            operation_id:
+            response_model_include:
+            response_model_exclude:
+            response_model_by_alias:
+            response_model_exclude_unset:
+            response_model_exclude_defaults:
+            response_model_exclude_none:
+            include_in_schema:
+            response_class:
+            name:
+            openapi_extra:
+            generate_unique_id_function:
+        """
         def decorator(func: DecoratedCallable) -> DecoratedCallable:
             self.router.add_api_route(
                 path,

--- a/fastapi/concurrency.py
+++ b/fastapi/concurrency.py
@@ -24,6 +24,11 @@
     # to avoid this we let __exit__ run without a capacity limit
     # since we're creating a new limiter for each call, any non-zero limit
     # works (1 is arbitrary)
+    """TODO: docstring
+
+    Args:
+        cm:
+    """
     exit_limiter = CapacityLimiter(1)
     try:
         yield await run_in_threadpool(cm.__enter__)

--- a/fastapi/datastructures.py
+++ b/fastapi/datastructures.py
@@ -166,6 +166,12 @@
     def __get_pydantic_core_schema__(
         cls, source: type[Any], handler: Callable[[Any], CoreSchema]
     ) -> CoreSchema:
+        """TODO: docstring
+
+        Args:
+            source:
+            handler:
+        """
         from ._compat.v2 import with_info_plain_validator_function
 
         return with_info_plain_validator_function(cls._validate)

--- a/fastapi/dependencies/models.py
+++ b/fastapi/dependencies/models.py
@@ -52,6 +52,7 @@
 
     @cached_property
     def oauth_scopes(self) -> list[str]:
+        """TODO: docstring"""
         scopes = self.parent_oauth_scopes.copy() if self.parent_oauth_scopes else []
         # This doesn't use a set to preserve order, just in case
         for scope in self.own_oauth_scopes or []:
@@ -99,6 +100,7 @@
 
     @cached_property
     def _security_dependencies(self) -> list["Dependant"]:
+        """TODO: docstring"""
         security_deps = [dep for dep in self.dependencies if dep._is_security_scheme]
         return security_deps
 

--- a/fastapi/dependencies/utils.py
+++ b/fastapi/dependencies/utils.py
@@ -117,6 +117,12 @@
 
 
 def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:
+    """TODO: docstring
+
+    Args:
+        depends:
+        path:
+    """
     assert callable(depends.dependency), (
         "A parameter-less dependency must have a callable dependency"
     )
@@ -138,6 +144,14 @@
     visited: Optional[list[DependencyCacheKey]] = None,
     parent_oauth_scopes: Optional[list[str]] = None,
 ) -> Dependant:
+    """TODO: docstring
+
+    Args:
+        dependant:
+        skip_repeats:
+        visited:
+        parent_oauth_scopes:
+    """
     if visited is None:
         visited = []
     visited.append(dependant.cache_key)
@@ -186,6 +200,11 @@
 
 
 def _get_flat_fields_from_params(fields: list[ModelField]) -> list[ModelField]:
+    """TODO: docstring
+
+    Args:
+        fields:
+    """
     if not fields:
         return fields
     first_field = fields[0]
@@ -196,6 +215,11 @@
 
 
 def get_flat_params(dependant: Dependant) -> list[ModelField]:
+    """TODO: docstring
+
+    Args:
+        dependant:
+    """
     flat_dependant = get_flat_dependant(dependant, skip_repeats=True)
     path_params = _get_flat_fields_from_params(flat_dependant.path_params)
     query_params = _get_flat_fields_from_params(flat_dependant.query_params)
@@ -235,6 +259,12 @@
 
 
 def get_typed_annotation(annotation: Any, globalns: dict[str, Any]) -> Any:
+    """TODO: docstring
+
+    Args:
+        annotation:
+        globalns:
+    """
     if isinstance(annotation, str):
         annotation = ForwardRef(annotation)
         annotation = evaluate_forwardref(annotation, globalns, globalns)
@@ -265,6 +295,17 @@
     use_cache: bool = True,
     scope: Union[Literal["function", "request"], None] = None,
 ) -> Dependant:
+    """TODO: docstring
+
+    Args:
+        path:
+        call:
+        name:
+        own_oauth_scopes:
+        parent_oauth_scopes:
+        use_cache:
+        scope:
+    """
     dependant = Dependant(
         call=call,
         name=name,
@@ -569,6 +610,13 @@
 async def _solve_generator(
     *, dependant: Dependant, stack: AsyncExitStack, sub_values: dict[str, Any]
 ) -> Any:
+    """TODO: docstring
+
+    Args:
+        dependant:
+        stack:
+        sub_values:
+    """
     assert dependant.call
     if dependant.is_async_gen_callable:
         cm = asynccontextmanager(dependant.call)(**sub_values)
@@ -600,6 +648,19 @@
     async_exit_stack: AsyncExitStack,
     embed_body_fields: bool,
 ) -> SolvedDependency:
+    """TODO: docstring
+
+    Args:
+        request:
+        dependant:
+        body:
+        background_tasks:
+        response:
+        dependency_overrides_provider:
+        dependency_cache:
+        async_exit_stack:
+        embed_body_fields:
+    """
     request_astack = request.scope.get("fastapi_inner_astack")
     assert isinstance(request_astack, AsyncExitStack), (
         "fastapi_inner_astack not found in request scope"
@@ -729,6 +790,14 @@
 def _validate_value_with_model_field(
     *, field: ModelField, value: Any, values: dict[str, Any], loc: tuple[str, ...]
 ) -> tuple[Any, list[Any]]:
+    """TODO: docstring
+
+    Args:
+        field:
+        value:
+        values:
+        loc:
+    """
     if value is None:
         if field.required:
             return None, [get_missing_field_error(loc=loc)]
@@ -772,6 +841,12 @@
     fields: Sequence[ModelField],
     received_params: Union[Mapping[str, Any], QueryParams, Headers],
 ) -> tuple[dict[str, Any], list[Any]]:
+    """TODO: docstring
+
+    Args:
+        fields:
+        received_params:
+    """
     values: dict[str, Any] = {}
     errors: list[dict[str, Any]] = []
 
@@ -871,6 +946,11 @@
 
 
 def _should_embed_body_fields(fields: list[ModelField]) -> bool:
+    """TODO: docstring
+
+    Args:
+        fields:
+    """
     if not fields:
         return False
     # More than one dependency could have the same field, it would show up as multiple
@@ -898,6 +978,12 @@
     body_fields: list[ModelField],
     received_body: FormData,
 ) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        body_fields:
+        received_body:
+    """
     values = {}
 
     for field in body_fields:
@@ -946,6 +1032,13 @@
     received_body: Optional[Union[dict[str, Any], FormData]],
     embed_body_fields: bool,
 ) -> tuple[dict[str, Any], list[dict[str, Any]]]:
+    """TODO: docstring
+
+    Args:
+        body_fields:
+        received_body:
+        embed_body_fields:
+    """
     values: dict[str, Any] = {}
     errors: list[dict[str, Any]] = []
     assert body_fields, "request_body_to_args() should be called with fields"

--- a/fastapi/encoders.py
+++ b/fastapi/encoders.py
@@ -99,6 +99,11 @@
 def generate_encoders_by_class_tuples(
     type_encoder_map: dict[Any, Callable[[Any], Any]],
 ) -> dict[Callable[[Any], Any], tuple[Any, ...]]:
+    """TODO: docstring
+
+    Args:
+        type_encoder_map:
+    """
     encoders_by_class_tuples: dict[Callable[[Any], Any], tuple[Any, ...]] = defaultdict(
         tuple
     )

--- a/fastapi/exceptions.py
+++ b/fastapi/exceptions.py
@@ -70,6 +70,13 @@
             ),
         ] = None,
     ) -> None:
+        """TODO: docstring
+
+        Args:
+            status_code:
+            detail:
+            headers:
+        """
         super().__init__(status_code=status_code, detail=detail, headers=headers)
 
 

--- a/fastapi/openapi/models.py
+++ b/fastapi/openapi/models.py
@@ -53,6 +53,12 @@
         def __get_pydantic_core_schema__(
             cls, source: type[Any], handler: Callable[[Any], CoreSchema]
         ) -> CoreSchema:
+            """TODO: docstring
+
+            Args:
+                source:
+                handler:
+            """
             return with_info_plain_validator_function(cls._validate)
 
 

--- a/fastapi/openapi/utils.py
+++ b/fastapi/openapi/utils.py
@@ -80,6 +80,11 @@
 def get_openapi_security_definitions(
     flat_dependant: Dependant,
 ) -> tuple[dict[str, Any], list[dict[str, Any]]]:
+    """TODO: docstring
+
+    Args:
+        flat_dependant:
+    """
     security_definitions = {}
     # Use a dict to merge scopes for same security scheme
     operation_security_dict: dict[str, list[str]] = {}
@@ -112,6 +117,14 @@
     ],
     separate_input_output_schemas: bool = True,
 ) -> list[dict[str, Any]]:
+    """TODO: docstring
+
+    Args:
+        dependant:
+        model_name_map:
+        field_mapping:
+        separate_input_output_schemas:
+    """
     parameters = []
     flat_dependant = get_flat_dependant(dependant, skip_repeats=True)
     path_params = _get_flat_fields_from_params(flat_dependant.path_params)
@@ -185,6 +198,14 @@
     ],
     separate_input_output_schemas: bool = True,
 ) -> Optional[dict[str, Any]]:
+    """TODO: docstring
+
+    Args:
+        body_field:
+        model_name_map:
+        field_mapping:
+        separate_input_output_schemas:
+    """
     if not body_field:
         return None
     assert _is_model_field(body_field)
@@ -235,6 +256,13 @@
 def get_openapi_operation_metadata(
     *, route: routing.APIRoute, method: str, operation_ids: set[str]
 ) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        route:
+        method:
+        operation_ids:
+    """
     operation: dict[str, Any] = {}
     if route.tags:
         operation["tags"] = route.tags
@@ -268,6 +296,15 @@
     ],
     separate_input_output_schemas: bool = True,
 ) -> tuple[dict[str, Any], dict[str, Any], dict[str, Any]]:
+    """TODO: docstring
+
+    Args:
+        route:
+        operation_ids:
+        model_name_map:
+        field_mapping:
+        separate_input_output_schemas:
+    """
     path = {}
     security_schemes: dict[str, Any] = {}
     definitions: dict[str, Any] = {}
@@ -447,6 +484,11 @@
 def get_fields_from_routes(
     routes: Sequence[BaseRoute],
 ) -> list[ModelField]:
+    """TODO: docstring
+
+    Args:
+        routes:
+    """
     body_fields_from_routes: list[ModelField] = []
     responses_from_routes: list[ModelField] = []
     request_fields_from_routes: list[ModelField] = []
@@ -492,6 +534,24 @@
     separate_input_output_schemas: bool = True,
     external_docs: Optional[dict[str, Any]] = None,
 ) -> dict[str, Any]:
+    """TODO: docstring
+
+    Args:
+        title:
+        version:
+        openapi_version:
+        summary:
+        description:
+        routes:
+        webhooks:
+        tags:
+        servers:
+        terms_of_service:
+        contact:
+        license_info:
+        separate_input_output_schemas:
+        external_docs:
+    """
     info: dict[str, Any] = {"title": title, "version": version}
     if summary:
         info["summary"] = summary
