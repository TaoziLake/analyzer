--- a/docs_src/header_params/tutorial003_an_py39.py
+++ b/docs_src/header_params/tutorial003_an_py39.py
@@ -7,4 +7,12 @@
 
 @app.get("/items/")
 async def read_items(x_token: Annotated[Union[list[str], None], Header()] = None):
+    """Read items with optional X-Token header values.
+
+    Args:
+        x_token (Union[list[str], None], optional): List of X-Token values from the request header. Defaults to None.
+
+    Returns:
+        dict: A dictionary containing the X-Token values from the request header.
+    """
     return {"X-Token values": x_token}

--- a/fastapi/_compat/shared.py
+++ b/fastapi/_compat/shared.py
@@ -49,6 +49,20 @@
 def lenient_issubclass(
     cls: Any, class_or_tuple: Union[type[Any], tuple[type[Any], ...], None]
 ) -> bool:
+    """Lenient version of issubclass that returns False instead of raising TypeError for non-class inputs.
+
+    Handles generic type aliases (e.g., list[int]) by returning False. Supports Pydantic v1 and v2 compatibility.
+
+    Args:
+        cls (Any): The object to check if it's a subclass. If not a type, returns False.
+        class_or_tuple (Union[type[Any], tuple[type[Any], ...], None): Target class or tuple of classes to check against.
+
+    Returns:
+        bool: True if cls is a subclass of class_or_tuple, False otherwise.
+
+    Raises:
+        TypeError: If class_or_tuple is not a valid type or tuple of types, and cls is a valid type.
+    """
     try:
         return isinstance(cls, type) and issubclass(cls, class_or_tuple)  # type: ignore[arg-type]
     except TypeError:  # pragma: no cover
@@ -58,12 +72,33 @@
 
 
 def _annotation_is_sequence(annotation: Union[type[Any], None]) -> bool:
+    """Check if an annotation represents a sequence type (e.g., list, tuple, set, etc.) but not str or bytes.
+
+    Args:
+        annotation (Union[type[Any], None]): The type annotation to check.
+
+    Returns:
+        bool: True if the annotation is a sequence type (excluding str/bytes), False otherwise.
+    """
     if lenient_issubclass(annotation, (str, bytes)):
         return False
     return lenient_issubclass(annotation, sequence_types)
 
 
 def field_annotation_is_sequence(annotation: Union[type[Any], None]) -> bool:
+    """Check if a type annotation represents a sequence type, handling Union and Optional types.
+
+    Args:
+        annotation: The type annotation to check, or None.
+
+    Returns:
+        True if the annotation is a sequence type (list, tuple, set, etc.) or contains
+        a sequence type in a Union/Optional declaration, False otherwise.
+
+        Handles generic sequences with type arguments and nested unions. For example,
+        returns True for list[int], Union[list, str], or Optional[tuple], but False
+        for str or bytes (which are sequences but explicitly excluded).
+    """
     origin = get_origin(annotation)
     if origin is Union or origin is UnionType:
         for arg in get_args(annotation):
@@ -76,6 +111,14 @@
 
 
 def value_is_sequence(value: Any) -> bool:
+    """Check if a value is a sequence type but not a string or bytes.
+
+    Args:
+        value (Any): The value to check.
+
+    Returns:
+        bool: True if the value is a sequence (list, tuple, set, etc.) but not an instance of str or bytes, False otherwise.
+    """
     return isinstance(value, sequence_types) and not isinstance(value, (str, bytes))
