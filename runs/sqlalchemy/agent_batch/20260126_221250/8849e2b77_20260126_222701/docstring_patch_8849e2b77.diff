--- a/lib/sqlalchemy/engine/_result_cy.py
+++ b/lib/sqlalchemy/engine/_result_cy.py
@@ -108,30 +108,48 @@
     def _fetchiter_impl(
         self,
     ) -> Iterator[_InterimRowType[Row[Unpack[TupleAny]]]]:
+        """TODO: docstring"""
         raise NotImplementedError()
 
     def _fetchone_impl(
         self, hard_close: bool = False
     ) -> _InterimRowType[Row[Unpack[TupleAny]]] | None:
+        """TODO: docstring
+
+        Args:
+            hard_close:
+        """
         raise NotImplementedError()
 
     def _fetchmany_impl(
         self, size: int | None = None
     ) -> list[_InterimRowType[Row[Unpack[TupleAny]]]]:
+        """TODO: docstring
+
+        Args:
+            size:
+        """
         raise NotImplementedError()
 
     def _fetchall_impl(
         self,
     ) -> list[_InterimRowType[Row[Unpack[TupleAny]]]]:
+        """TODO: docstring"""
         raise NotImplementedError()
 
     def _soft_close(self, hard: bool = False) -> None:
+        """TODO: docstring
+
+        Args:
+            hard:
+        """
         raise NotImplementedError()
 
     @HasMemoized_ro_memoized_attribute
     def _row_getter(
         self,
     ) -> tuple[Callable[..., _R] | None, Callable[..., Sequence[_R]] | None]:
+        """TODO: docstring"""
         real_result = self if self._real_result is None else self._real_result
 
         metadata = self._metadata
@@ -173,6 +191,11 @@
             # just build the rows
 
             def single_row_simple(input_row: Sequence[Any], /) -> Row:
+                """TODO: docstring
+
+                Args:
+                    input_row:
+                """
                 return _Row(metadata, None, key_to_index, input_row)
 
             if cython.compiled:
@@ -192,6 +215,11 @@
             else:
 
                 def many_rows_simple(rows: Sequence[Any], /) -> list[Any]:
+                    """TODO: docstring
+
+                    Args:
+                        rows:
+                    """
                     return [
                         _Row(metadata, None, key_to_index, row) for row in rows
                     ]
@@ -201,6 +229,11 @@
         first_row: cython.bint = True
 
         def single_row(input_row: Sequence[Any], /) -> Row:
+            """TODO: docstring
+
+            Args:
+                input_row:
+            """
             nonlocal first_row
 
             if flag == _FLAG_SCALAR_TO_TUPLE:
@@ -236,12 +269,18 @@
         else:
 
             def many_rows(rows: Sequence[Any], /) -> list[Any]:
+                """TODO: docstring
+
+                Args:
+                    rows:
+                """
                 return [single_row(row) for row in rows]
 
         return single_row, many_rows  # type: ignore[return-value]
 
     @HasMemoized_ro_memoized_attribute
     def _iterator_getter(self) -> Callable[[], Iterator[_R]]:
+        """TODO: docstring"""
         make_row = self._row_getter[0]
 
         post_creational_filter = self._post_creational_filter
@@ -266,6 +305,7 @@
         else:
 
             def iterrows() -> Iterator[_R]:
+                """TODO: docstring"""
                 for raw_row in self._fetchiter_impl():
                     row = (
                         make_row(raw_row) if make_row is not None else raw_row
@@ -277,11 +317,13 @@
         return iterrows
 
     def _raw_all_rows(self) -> Sequence[_R]:
+        """TODO: docstring"""
         make_rows = self._row_getter[1]
         assert make_rows is not None
         return make_rows(self._fetchall_impl())
 
     def _allrows(self) -> Sequence[_R]:
+        """TODO: docstring"""
         post_creational_filter = self._post_creational_filter
 
         make_rows = self._row_getter[1]
@@ -314,6 +356,7 @@
     def _onerow_getter(
         self,
     ) -> Callable[[Self], Literal[_NoRow._NO_ROW] | _R]:
+        """TODO: docstring"""
         make_row = self._row_getter[0]
 
         post_creational_filter = self._post_creational_filter
@@ -342,6 +385,7 @@
         else:
 
             def onerow(self: Self) -> Literal[_NoRow._NO_ROW] | _R:
+                """TODO: docstring"""
                 row = self._fetchone_impl()
                 if row is None:
                     return _NO_ROW
@@ -357,6 +401,7 @@
 
     @HasMemoized_ro_memoized_attribute
     def _manyrow_getter(self) -> Callable[[Self, int | None], Sequence[_R]]:
+        """TODO: docstring"""
         make_rows = self._row_getter[1]
         real_result = self if self._real_result is None else self._real_result
         yield_per = real_result._yield_per
@@ -414,6 +459,11 @@
         else:
 
             def manyrows(self: Self, num: int | None, /) -> Sequence[_R]:
+                """TODO: docstring
+
+                Args:
+                    num:
+                """
                 if num is None:
                     num = yield_per
 
@@ -456,6 +506,13 @@
         raise_for_none: bool,
         scalar: bool,
     ) -> _R | None:
+        """TODO: docstring
+
+        Args:
+            raise_for_second_row:
+            raise_for_none:
+            scalar:
+        """
         onerow = self._fetchone_impl
 
         row = onerow(hard_close=True)
@@ -543,9 +600,11 @@
             return row  # type: ignore
 
     def _iter_impl(self) -> Iterator[_R]:
+        """TODO: docstring"""
         return self._iterator_getter()
 
     def _next_impl(self) -> _R:
+        """TODO: docstring"""
         row = self._onerow_getter(self)
         if row is _NO_ROW:
             raise StopIteration()
@@ -554,6 +613,7 @@
 
     @HasMemoized_ro_memoized_attribute
     def _unique_strategy(self) -> _UniqueFilterStateType:
+        """TODO: docstring"""
         assert self._unique_filter_state is not None
         uniques, strategy = self._unique_filter_state
 
@@ -607,6 +667,14 @@
         proc_valid: tuple[int, ...],
         data: Sequence[Any],
     ) -> tuple[Any, ...]:
+        """TODO: docstring
+
+        Args:
+            proc:
+            proc_size:
+            proc_valid:
+            data:
+        """
         res = list(data)
         for i in proc_valid:
             res[i] = proc[i](res[i])
@@ -621,6 +689,14 @@
     uniques: set[Any],
     strategy: Callable[[Any], Any] | None,
 ) -> list[Any]:
+    """TODO: docstring
+
+    Args:
+        rows:
+        destination:
+        uniques:
+        strategy:
+    """
     i: cython.Py_ssize_t
     has_strategy: cython.bint = strategy is not None
     for i in range(len(rows)):

--- a/lib/sqlalchemy/engine/cursor.py
+++ b/lib/sqlalchemy/engine/cursor.py
@@ -1646,6 +1646,13 @@
         cursor_strategy: ResultFetchStrategy,
         cursor_description: Optional[_DBAPICursorDescription],
     ):
+        """TODO: docstring
+
+        Args:
+            context:
+            cursor_strategy:
+            cursor_description:
+        """
         self.context = context
         self.dialect = context.dialect
         self.cursor = context.cursor
@@ -1679,6 +1686,12 @@
         context: DefaultExecutionContext,
         cursor_description: _DBAPICursorDescription,
     ) -> CursorResultMetaData:
+        """TODO: docstring
+
+        Args:
+            context:
+            cursor_description:
+        """
         driver_column_names = context.execution_options.get(
             "driver_column_names", False
         )

--- a/test/perf/compiled_extensions/base.py
+++ b/test/perf/compiled_extensions/base.py
@@ -38,6 +38,7 @@
 
     @classmethod
     def init_class(cls):
+        """TODO: docstring"""
         pass
 
     @classmethod
@@ -49,6 +50,7 @@
 
     @classmethod
     def import_impl(cls):
+        """TODO: docstring"""
         impl = []
         for name, fn in cls.IMPLEMENTATIONS.items():
             obj = cls._load(fn)
@@ -67,10 +69,21 @@
 
     @classmethod
     def update_results(cls, results):
+        """TODO: docstring
+
+        Args:
+            results:
+        """
         pass
 
     @classmethod
     def run_case(cls, factor, filter_):
+        """TODO: docstring
+
+        Args:
+            factor:
+            filter_:
+        """
         objects = cls.import_impl()
         cls.init_class()
         number = max(1, int(cls.NUMBER * factor))

--- a/test/perf/compiled_extensions/command.py
+++ b/test/perf/compiled_extensions/command.py
@@ -18,6 +18,12 @@
     impl_names: list[str],
     result_by_method: dict[str, dict[str, float]],
 ):
+    """TODO: docstring
+
+    Args:
+        impl_names:
+        result_by_method:
+    """
     if not result_by_method:
         return
     dim = max(len(n) for n in impl_names)
@@ -45,6 +51,7 @@
 
 
 def find_git_sha():
+    """TODO: docstring"""
     try:
         git_res = subprocess.run(
             ["git", "rev-parse", "--short", "HEAD"], stdout=subprocess.PIPE
@@ -55,6 +62,7 @@
 
 
 def main():
+    """TODO: docstring"""
     import argparse
 
     cases = Case._CASES

--- a/test/perf/compiled_extensions/result.py
+++ b/test/perf/compiled_extensions/result.py
@@ -21,6 +21,7 @@
 
     @staticmethod
     def _load_python_module():
+        """TODO: docstring"""
         from sqlalchemy.engine import _result_cy
 
         py_result = load_uncompiled_module(_result_cy)
@@ -36,6 +37,13 @@
         name: str, result_internal: type, base: type[result.Result]
     ) -> type[result.Result]:
         # Need to also create a python version of the scalar result
+        """TODO: docstring
+
+        Args:
+            name:
+            result_internal:
+            base:
+        """
         class PyScalarResult(result_internal, result.ScalarResult):
             _fetchiter_impl = result.ScalarResult._fetchiter_impl
             _fetchone_impl = result.ScalarResult._fetchone_impl
@@ -44,6 +52,11 @@
             _soft_close = result.ScalarResult._soft_close
 
         def scalars(self, index=0):
+            """TODO: docstring
+
+            Args:
+                index:
+            """
             return PyScalarResult(self, index)
 
         cls_dict = dict(
@@ -59,6 +72,11 @@
 
     @classmethod
     def update_results(cls, results):
+        """TODO: docstring
+
+        Args:
+            results:
+        """
         cls._divide_results(results, "cython", "python", "cy / py")
 
     @classmethod
@@ -219,6 +237,7 @@
 
     @staticmethod
     def python():
+        """TODO: docstring"""
         py_result = _CommonResult._load_python_module()
 
         PyIteratorResult = _CommonResult._make_subclass(
@@ -232,6 +251,7 @@
 
     @staticmethod
     def cython():
+        """TODO: docstring"""
         from sqlalchemy.engine import _result_cy
 
         assert _result_cy._is_compiled()
@@ -263,6 +283,7 @@
 
     @staticmethod
     def python():
+        """TODO: docstring"""
         py_result = _CommonResult._load_python_module()
 
         PyCursorResult = _CommonResult._make_subclass(
@@ -275,6 +296,7 @@
 
     @staticmethod
     def cython():
+        """TODO: docstring"""
         from sqlalchemy.engine import _result_cy
 
         assert _result_cy._is_compiled()

--- a/tools/cython_imports.py
+++ b/tools/cython_imports.py
@@ -35,6 +35,12 @@
 
 
 def run_file(cmd: code_writer_cmd, file: Path):
+    """TODO: docstring
+
+    Args:
+        cmd:
+        file:
+    """
     content = file.read_text("utf-8")
     count = 0
 
@@ -61,6 +67,11 @@
 
 
 def run(cmd: code_writer_cmd):
+    """TODO: docstring
+
+    Args:
+        cmd:
+    """
     i = 0
     for file in sa_path.glob("**/*_cy.py"):
         run_file(cmd, file)

--- a/lib/sqlalchemy/orm/bulk_persistence.py
+++ b/lib/sqlalchemy/orm/bulk_persistence.py
@@ -636,6 +636,16 @@
         bind_arguments,
         result,
     ):
+        """TODO: docstring
+
+        Args:
+            session:
+            statement:
+            params:
+            execution_options:
+            bind_arguments:
+            result:
+        """
         execution_context = result.context
         compile_state = execution_context.compiled.compile_state
 

--- a/lib/sqlalchemy/orm/context.py
+++ b/lib/sqlalchemy/orm/context.py
@@ -601,6 +601,16 @@
         bind_arguments,
         result,
     ):
+        """TODO: docstring
+
+        Args:
+            session:
+            statement:
+            params:
+            execution_options:
+            bind_arguments:
+            result:
+        """
         execution_context = result.context
         compile_state = execution_context.compiled.compile_state
