--- a/jwt/algorithms.py
+++ b/jwt/algorithms.py
@@ -289,9 +289,18 @@
         """
 
     def check_key_length(self, key: Any) -> str | None:
-        """
-        Return a warning message if the key is below the minimum
-        recommended length for this algorithm, or None if adequate.
+        """Check if the provided key meets the minimum length requirements for this algorithm.
+
+        Returns a warning message if the key is below the minimum recommended length, or None if the key length is adequate.
+
+        Args:
+            key: The cryptographic key to validate (type unspecified, algorithm-dependent)
+
+        Returns:
+            Optional[str]: Warning message if key length is insufficient, None otherwise
+
+        Changelog:
+            96ae356: Added new method to support key length validation framework. Currently implements stub behavior that always returns None, indicating no key length restrictions enforced in this version.
         """
         return None
 
@@ -360,6 +369,16 @@
 
     @staticmethod
     def to_jwk(key_obj: str | bytes, as_dict: bool = False) -> JWKDict | str:
+        """Convert a key object to a JSON Web Key (JWK) representation.
+
+        :param key_obj: The cryptographic key data to convert, as a string or bytes.
+        :param as_dict: If True, return the JWK as a Python dictionary; otherwise return as JSON string.
+        :returns: A JWK dictionary or JSON string containing the base64url-encoded key ("k") and key type ("oct").
+        :raises: None under normal operation, but upstream changes may affect key handling during JWT decoding.
+
+        Changelog:
+            96ae356: Upstream changes in JWT decoding logic may affect how JWK keys generated by this method are processed during token verification. Callers might observe different signature validation outcomes or claims processing behavior when using the returned JWKs with jwt.api_jwt.PyJWT.decode.
+        """
         jwk = {
             "k": base64url_encode(force_bytes(key_obj)).decode(),
             "kty": "oct",
@@ -388,6 +407,19 @@
         return base64url_decode(obj["k"])
 
     def check_key_length(self, key: bytes) -> str | None:
+        """Check if the HMAC key meets the minimum length requirement based on the hash algorithm's digest size.
+
+        Args:
+            key (bytes): The cryptographic key to validate.
+
+        Returns:
+            Optional[str]: Warning message if key length is insufficient, None otherwise.
+
+        Changelog:
+            96ae356: Added key length validation logic comparing against hash_alg().digest_size. 
+            Returns descriptive warning message when key length is below minimum recommended size, 
+            with reference to RFC 7518 Section 3.2. Adds security validation for HMAC key length.
+        """
         min_length = self.hash_alg().digest_size
         if len(key) < min_length:
             return (
@@ -424,6 +456,21 @@
             self.hash_alg = hash_alg
 
         def check_key_length(self, key: AllowedRSAKeys) -> str | None:
+            """Check if the RSA key length meets the minimum security requirements.
+
+            Args:
+                key: An RSA key object that provides a `key_size` attribute in bits.
+
+            Returns:
+                Optional[str]: Warning message if key length is below minimum allowed size, 
+                otherwise None.
+
+            Changelog:
+                96ae356: Add RSA key length validation function that enforces NIST SP 800-131A 
+                compliance. Introduces minimum key size check (default 2048 bits) and returns 
+                descriptive security warning when insufficient. This provides proactive key 
+                validation before cryptographic operations.
+            """
             if key.key_size < self._MIN_KEY_SIZE:
                 return (
                     f"The RSA key is {key.key_size} bits long, which is below "
@@ -472,6 +519,16 @@
 
         @staticmethod
         def to_jwk(key_obj: AllowedRSAKeys, as_dict: bool = False) -> JWKDict | str:
+            """Convert an RSA key to JWK (JSON Web Key) format.
+
+            :param key_obj: An RSA key object supporting either private_numbers() or public_numbers() methods.
+            :param as_dict: If True, return the JWK as a dictionary; otherwise return as a JSON string.
+            :returns: A JWK dictionary or JSON string representing the RSA key.
+            :raises InvalidKeyError: If the key_obj is neither a public nor private RSA key.
+
+            Changelog:
+                96ae356: Upstream changes in PyJWT.decode may affect JWK validation behavior. JWKs generated by this method might now trigger stricter key usage checks during token decoding (e.g., enforcement of key_ops fields for signature verification). Callers may observe different verification outcomes or error patterns when using returned JWKs for JWT operations.
+            """
             obj: dict[str, Any] | None = None
 
             if hasattr(key_obj, "private_numbers"):
@@ -686,6 +743,16 @@
 
         @staticmethod
         def to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:
+            """Convert an Elliptic Curve key to JSON Web Key (JWK) format.
+
+            :param key_obj: An EC private or public key object (EllipticCurvePrivateKey or EllipticCurvePublicKey)
+            :param as_dict: If True, return the JWK as a dictionary; otherwise return as JSON string
+            :returns: JWKDict (if as_dict=True) or JSON string containing the JWK representation
+            :raises InvalidKeyError: If key_obj is neither a valid EC private/public key nor supported curve
+
+            Changelog:
+                96ae356: Upstream changes in PyJWT.decode may affect how JWKs generated by this function are processed during JWT decoding. Callers may observe differences in signature verification outcomes or claims validation errors when using these JWKs for token decoding operations.
+            """
             if isinstance(key_obj, EllipticCurvePrivateKey):
                 public_numbers = key_obj.public_key().public_numbers()
             elif isinstance(key_obj, EllipticCurvePublicKey):
@@ -917,6 +984,21 @@
 
         @staticmethod
         def to_jwk(key: AllowedOKPKeys, as_dict: bool = False) -> JWKDict | str:
+            """Convert an OKP public or private key to a JSON Web Key (JWK) format.
+
+            Args:
+                key: An Ed25519 or Ed448 public/private key object.
+                as_dict: If True, return the JWK as a dictionary. If False, return as a JSON string.
+
+            Returns:
+                Union[JWKDict, str]: A dictionary or JSON string containing the JWK parameters (x, d for private keys, kty, and crv).
+
+            Raises:
+                InvalidKeyError: If the input key is neither a valid public nor private key.
+
+            Changelog:
+                96ae356: While this function's implementation remains unchanged, the upstream modification to jwt.api_jwt.PyJWT.decode may affect how JWKs generated by this function are processed during JWT decoding. Callers might observe differences in signature verification outcomes or claims validation strictness when using these keys with jwt.decode().
+            """
             if isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):
                 x = key.public_bytes(
                     encoding=Encoding.Raw,

--- a/jwt/api_jws.py
+++ b/jwt/api_jws.py
@@ -36,6 +36,22 @@
         algorithms: Sequence[str] | None = None,
         options: SigOptions | None = None,
     ) -> None:
+        """Initialize a PyJWS instance with specified algorithms and signature options.
+
+        :param algorithms: List of allowed algorithm names (e.g., ['HS256', 'RS256']). 
+            If None, uses all registered algorithms.
+        :param options: Signature verification options. If provided, merges with 
+            default options that now include 'enforce_minimum_key_length': False.
+
+        :returns: None
+
+        Changelog:
+            96ae356: Added 'enforce_minimum_key_length' option to default options with 
+            default value False. This affects JWT signature verification security 
+            behavior by controlling key length validation. Callers using default 
+            options now inherit this new security setting, which may require explicit 
+            enablement (True) for stricter validation.
+        """
         self._algorithms = get_default_algorithms()
         self._valid_algs = (
             set(algorithms) if algorithms is not None else set(self._algorithms)
@@ -52,6 +68,16 @@
 
     @staticmethod
     def _get_default_options() -> SigOptions:
+        """Return default options for signature verification.
+
+        Returns:
+            SigOptions: A dictionary containing default verification options with keys:
+                - "verify_signature": bool (default: True)
+                - "enforce_minimum_key_length": bool (default: False)
+
+        Changelog:
+            96ae356: Added "enforce_minimum_key_length" option with default value False to the returned SigOptions dictionary, expanding the default verification settings.
+        """
         return {"verify_signature": True, "enforce_minimum_key_length": False}
 
     def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:
@@ -125,6 +151,29 @@
         is_payload_detached: bool = False,
         sort_headers: bool = True,
     ) -> str:
+        """Encode a JWT into a JWS using the specified algorithm and key.
+
+        Args:
+            payload (bytes): The payload data to encode.
+            key (Union[AllowedPrivateKeys, PyJWK, str, bytes]): The cryptographic key to use for signing.
+            algorithm (Optional[str]): The signing algorithm to use (default: "HS256").
+            headers (Optional[Dict[str, Any]]): Additional headers to include in the JWS.
+            json_encoder (Optional[type[json.JSONEncoder]]): Custom JSON encoder class.
+            is_payload_detached (bool): Whether to detach the payload (default: False).
+            sort_headers (bool): Whether to sort headers lexicographically (default: True).
+
+        Returns:
+            str: The encoded JWS token as a string.
+
+        Raises:
+            InvalidKeyError: If key length is insufficient AND 'enforce_minimum_key_length' option is True.
+
+        Changelog:
+            96ae356: Added key length validation via alg_obj.check_key_length(). If key length is insufficient:
+                - Raises InvalidKeyError if options['enforce_minimum_key_length'] is True
+                - Otherwise issues InsecureKeyLengthWarning
+                Added security checks for cryptographic key length requirements
+        """
         segments: list[bytes] = []
 
         # declare a new var to narrow the type for type checkers
@@ -209,6 +258,19 @@
         detached_payload: bytes | None = None,
         **kwargs: dict[str, Any],
     ) -> dict[str, Any]:
+        """Decode a JWS token and return its components with full verification.
+
+        :param jwt: The JWS token to decode, as a string or bytes.
+        :param key: Key for signature verification. Can be a string, bytes, PyJWK, or allowed public key types.
+        :param algorithms: List of allowed signing algorithms. Required if verify_signature is True.
+        :param options: Signature verification options. If None, uses default options.
+        :param detached_payload: Bytes to use as payload when b64 header is False.
+        :returns: A dictionary containing 'payload', 'header', and 'signature' components.
+        :raises DecodeError: If signature verification fails, key length is insufficient, or required parameters are missing.
+
+        Changelog:
+            96ae356: Added cryptographic key length validation during signature verification. When verify_signature=True, keys that don't meet algorithm-specific minimum length requirements will now raise a DecodeError (if enforce_minimum_key_length=True) or generate a warning. This may cause existing code using weak keys to fail unexpectedly.
+        """
         if kwargs:
             warnings.warn(
                 "passing additional kwargs to decode_complete() is deprecated "
@@ -258,6 +320,20 @@
         detached_payload: bytes | None = None,
         **kwargs: dict[str, Any],
     ) -> Any:
+        """Decode a JSON Web Token (JWT) and return its payload.
+
+        :param jwt: The JWT to decode. Can be a string or bytes.
+        :param key: The key to use for verifying the signature. Can be a string, bytes, PyJWK, or allowed public key type.
+        :param algorithms: List of allowed signing algorithms. If None, all supported algorithms are allowed.
+        :param options: Signature verification options. If None, default options will be used.
+        :param detached_payload: Optional detached payload to use for verification.
+        :returns: The decoded payload as a Python object.
+        :raises DecodeError: If the JWT signature verification fails due to invalid key length (when enforce_minimum_key_length=True in verification context) or other validation issues.
+        :raises RemovedInPyjwt3Warning: If additional kwargs are passed (deprecated).
+
+        Changelog:
+            96ae356: Adds key length validation during signature verification inherited from decode_complete(). Callers may now encounter DecodeError exceptions when using cryptographic keys shorter than required by the algorithm's security standards, particularly affecting implementations that previously accepted weak keys.
+        """
         if kwargs:
             warnings.warn(
                 "passing additional kwargs to decode() is deprecated "
@@ -328,6 +404,32 @@
         key: AllowedPublicKeys | PyJWK | str | bytes = "",
         algorithms: Sequence[str] | None = None,
     ) -> None:
+        """Verify the signature of a JWS using the provided key and algorithm.
+
+        Args:
+            signing_input: The input data to verify.
+            header: The JWS header containing algorithm metadata.
+            signature: The signature to validate.
+            key: Key material for verification (PyJWK, public key, or raw bytes).
+            algorithms: Optional sequence of allowed algorithm names.
+
+        Returns:
+            None
+
+        Raises:
+            InvalidAlgorithmError: If algorithm is unspecified or not allowed.
+            InvalidKeyError: If key length is insufficient and enforcement is enabled.
+            InvalidSignatureError: If signature verification fails.
+
+        Warnings:
+            InsecureKeyLengthWarning: If key length is insufficient but enforcement is disabled.
+
+        Changelog:
+            96ae356: Added key length validation via alg_obj.check_key_length(). If key length is insufficient: 
+            - Raises InvalidKeyError when self.options['enforce_minimum_key_length'] is True
+            - Otherwise issues InsecureKeyLengthWarning
+            Added new key length security checks before signature verification.
+        """
         if algorithms is None and isinstance(key, PyJWK):
             algorithms = [key.algorithm_name]
         try:

--- a/jwt/api_jwt.py
+++ b/jwt/api_jwt.py
@@ -47,6 +47,21 @@
 
 class PyJWT:
     def __init__(self, options: Options | None = None) -> None:
+        """Initialize a PyJWT instance with configuration options.
+
+        Args:
+            options: Optional dictionary of configuration options to merge with defaults.
+
+        Attributes:
+            options: Merged configuration options.
+            _jws: Internal PyJWS instance for handling JWS operations.
+
+        Returns:
+            None
+
+        Changelog:
+            96ae356: Added internal _jws attribute initialized with PyJWS instance using signature options derived from _get_sig_options(). This enables delegated JWS signature operations while maintaining existing options handling logic.
+        """
         self.options: FullOptions
         self.options = self._get_default_options()
         if options is not None:
@@ -56,6 +71,27 @@
 
     @staticmethod
     def _get_default_options() -> FullOptions:
+        """Get the default verification options for JWT validation.
+
+        Returns:
+            FullOptions: A dictionary containing verification options with the following keys:
+            - verify_signature (bool): Require signature verification
+            - verify_exp (bool): Validate expiration time
+            - verify_nbf (bool): Validate not-before time
+            - verify_iat (bool): Validate issued-at time
+            - verify_aud (bool): Validate audience claim
+            - verify_iss (bool): Validate issuer claim
+            - verify_sub (bool): Validate subject claim
+            - verify_jti (bool): Validate JWT ID claim
+            - require (List[str]): List of required claims
+            - strict_aud (bool): Require exact audience match
+            - enforce_minimum_key_length (bool): Require cryptographic keys to meet minimum length requirements
+
+        Changelog:
+            96ae356: Added 'enforce_minimum_key_length' option with default value False to control
+            cryptographic key length validation in JWT verification. This adds a new security
+            check that can be enabled to prevent use of insufficiently strong keys.
+        """
         return {
             "verify_signature": True,
             "verify_exp": True,
@@ -71,6 +107,19 @@
         }
 
     def _get_sig_options(self) -> SigOptions:
+        """Retrieve signature verification options from the instance's configuration.
+
+        Returns:
+            SigOptions: A dictionary containing signature verification settings with keys:
+                - 'verify_signature' (bool): Whether to verify the signature
+                - 'enforce_minimum_key_length' (bool): Whether to enforce minimum key length requirements
+
+        Changelog:
+            96ae356: Added new internal method _get_sig_options to centralize signature option handling. 
+            Introduces 'enforce_minimum_key_length' option with default False value, using dict.get() 
+            for graceful fallback when option is not explicitly set. Returns both signature verification 
+            and key length enforcement settings in a SigOptions dictionary.
+        """
         return {
             "verify_signature": self.options["verify_signature"],
             "enforce_minimum_key_length": self.options.get(
@@ -125,6 +174,9 @@
         :returns: a JSON Web Token
 
         :raises TypeError: if ``payload`` is not a ``dict``
+
+        Changelog:
+            96ae356: Changed internal JWS encoding mechanism from global `api_jws.encode` to instance-specific `self._jws.encode`. This encapsulates JWS encoding within the PyJWT instance, improving modularity and testability without altering the function's interface or behavior.
         """
         # Check that we get a dict
         if not isinstance(payload, dict):
@@ -165,11 +217,38 @@
         headers: dict[str, Any] | None = None,
         json_encoder: type[json.JSONEncoder] | None = None,
     ) -> bytes:
-        """
-        Encode a given payload to the bytes to be signed.
-
-        This method is intended to be overridden by subclasses that need to
-        encode the payload in a different way, e.g. compress the payload.
+        """def _encode_payload(
+            self,
+            payload: dict[str, Any],
+            headers: dict[str, Any] | None = None,
+            json_encoder: type[json.JSONEncoder] | None = None,
+        ) -> bytes:
+            """
+            Encode a given payload to the bytes to be signed.
+
+            This method is intended to be overridden by subclasses that need to
+            encode the payload in a different way, e.g. compress the payload.
+
+            Args:
+                payload: A dictionary containing the claims to encode.
+                headers: Optional dictionary of JOSE headers. Not used in the default implementation.
+                json_encoder: Optional custom JSON encoder class for payload serialization.
+
+            Returns:
+                The encoded payload as bytes, using UTF-8 encoding with compact JSON formatting.
+
+            Raises:
+                TypeError: If the payload contains non-serializable objects.
+                ValueError: If encoding fails due to invalid data.
+            """
+            return json.dumps(
+                payload,
+                separators=(",", ":"),
+                cls=json_encoder,
+            ).encode("utf-8")
+
+        Changelog:
+            96ae356: Upstream change in PyJWS.encode now propagates headers to this method. While the default implementation ignores headers, subclasses overriding _encode_payload should validate header handling aligns with new upstream requirements. No impact on existing behavior for unmodified classes.
         """
         return json.dumps(
             payload,
@@ -196,15 +275,12 @@
         # kwargs
         **kwargs: Any,
     ) -> dict[str, Any]:
-        """Identical to ``jwt.decode`` except for return value which is a dictionary containing the token header (JOSE Header),
-        the token payload (JWT Payload), and token signature (JWT Signature) on the keys "header", "payload",
-        and "signature" respectively.
+        """Identical to ``jwt.decode`` except for return value which is a dictionary containing the token header (JOSE Header), the token payload (JWT Payload), and token signature (JWT Signature) on the keys "header", "payload", and "signature" respectively.
 
         :param jwt: the token to be decoded
         :type jwt: str or bytes
         :param key: the key suitable for the allowed algorithm
         :type key: str or bytes or PyJWK or :py:class:`jwt.algorithms.AllowedPublicKeys`
-
         :param algorithms: allowed algorithms, e.g. ``["ES256"]``
 
             .. warning::
@@ -220,10 +296,8 @@
                algorithms that interpret the ``key`` in different ways
                (e.g. HS\\* and RS\\*).
         :type algorithms: typing.Sequence[str] or None
-
         :param jwt.types.Options options: extended decoding and validation options
             Refer to :py:class:`jwt.types.Options` for more information.
-
         :param audience: optional, the value for ``verify_aud`` check
         :type audience: str or typing.Iterable[str] or None
         :param issuer: optional, the value for ``verify_iss`` check
@@ -233,6 +307,10 @@
         :rtype: dict[str, typing.Any]
         :returns: Decoded JWT with the JOSE Header on the key ``header``, the JWS
          Payload on the key ``payload``, and the JWS Signature on the key ``signature``.
+
+        Changelog:
+            96ae356: Changed internal JWS implementation from direct api_jws import to instance attribute access (self._jws).
+            This encapsulates JWS operations within the class structure while maintaining identical external behavior.
         """
         if kwargs:
             warnings.warn(
