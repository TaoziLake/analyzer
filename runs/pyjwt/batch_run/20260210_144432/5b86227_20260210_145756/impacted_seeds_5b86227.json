{
  "commit": "5b86227",
  "parent": "04947d75dc45ba1a4a66eaa2b24fbb0eb512ceab",
  "repo": "D:\\locbench\\pyjwt",
  "num_files_in_diff": 3,
  "num_py_files_in_diff": 3,
  "num_seeds": 22,
  "seeds": [
    {
      "path": "jwt/algorithms.py",
      "version": "new",
      "line": 174,
      "kind": "function",
      "qualname": "jwt.algorithms.get_default_algorithms",
      "span": [
        157,
        188
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "def get_default_algorithms() -> dict[str, Algorithm]:\n    \"\"\"\n    Returns the algorithms that are implemented by the library.\n    \"\"\"\n    default_algorithms: dict[str, Algorithm] = {\n        \"none\": NoneAlgorithm(),\n        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),\n        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),\n        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),\n    }\n\n    if has_crypto:\n        default_algorithms.update(\n            {\n                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),\n                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),\n                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),\n                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256, SECP256R1),\n                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256, SECP256K1),\n                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384, SECP384R1),\n                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512, SECP521R1),\n                \"ES512\": ECAlgorithm(\n                    ECAlgorithm.SHA512, SECP521R1\n                ),  # Backward compat for #219 fix\n                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),\n                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),\n                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),\n                \"EdDSA\": OKPAlgorithm(),\n            }\n        )\n\n    return default_algorithms",
      "old_code": "def get_default_algorithms() -> dict[str, Algorithm]:\n    \"\"\"\n    Returns the algorithms that are implemented by the library.\n    \"\"\"\n    default_algorithms: dict[str, Algorithm] = {\n        \"none\": NoneAlgorithm(),\n        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),\n        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),\n        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),\n    }\n\n    if has_crypto:\n        default_algorithms.update(\n            {\n                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),\n                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),\n                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),\n                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384),\n                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512),\n                \"ES512\": ECAlgorithm(\n                    ECAlgorithm.SHA512\n                ),  # Backward compat for #219 fix\n                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),\n                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),\n                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),\n                \"EdDSA\": OKPAlgorithm(),\n            }\n        )\n\n    return default_algorithms"
    },
    {
      "path": "jwt/algorithms.py",
      "version": "new",
      "line": 579,
      "kind": "function",
      "qualname": "jwt.algorithms.ECAlgorithm.__init__",
      "span": [
        579,
        585
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "        def __init__(\n            self,\n            hash_alg: type[hashes.HashAlgorithm],\n            expected_curve: type[EllipticCurve] | None = None,\n        ) -> None:\n            self.hash_alg = hash_alg\n            self.expected_curve = expected_curve",
      "old_code": "        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg"
    },
    {
      "path": "jwt/algorithms.py",
      "version": "new",
      "line": 586,
      "kind": "class",
      "qualname": "jwt.algorithms.ECAlgorithm",
      "span": [
        567,
        775
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    class ECAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        ECDSA and the specified hash function\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        _crypto_key_types = ALLOWED_EC_KEY_TYPES\n\n        def __init__(\n            self,\n            hash_alg: type[hashes.HashAlgorithm],\n            expected_curve: type[EllipticCurve] | None = None,\n        ) -> None:\n            self.hash_alg = hash_alg\n            self.expected_curve = expected_curve\n\n        def _validate_curve(self, key: AllowedECKeys) -> None:\n            \"\"\"Validate that the key's curve matches the expected curve.\"\"\"\n            if self.expected_curve is None:\n                return\n\n            if not isinstance(key.curve, self.expected_curve):\n                raise InvalidKeyError(\n                    f\"The key's curve '{key.curve.name}' does not match the expected \"\n                    f\"curve '{self.expected_curve.name}' for this algorithm\"\n                )\n\n        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, self._crypto_key_types):\n                self._validate_curve(key)\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    public_key: PublicKeyTypes = load_ssh_public_key(key_bytes)\n                else:\n                    public_key = load_pem_public_key(key_bytes)\n\n                # Explicit check the key to prevent confusing errors from cryptography\n                self.check_crypto_key_type(public_key)\n                ec_public_key = cast(EllipticCurvePublicKey, public_key)\n                self._validate_curve(ec_public_key)\n                return ec_public_key\n            except ValueError:\n                private_key = load_pem_private_key(key_bytes, password=None)\n                self.check_crypto_key_type(private_key)\n                ec_private_key = cast(EllipticCurvePrivateKey, private_key)\n                self._validate_curve(ec_private_key)\n                return ec_private_key\n\n        def sign(self, msg: bytes, key: EllipticCurvePrivateKey) -> bytes:\n            der_sig = key.sign(msg, ECDSA(self.hash_alg()))\n\n            return der_to_raw_signature(der_sig, key.curve)\n\n        def verify(self, msg: bytes, key: AllowedECKeys, sig: bytes) -> bool:\n            try:\n                der_sig = raw_to_der_signature(sig, key.curve)\n            except ValueError:\n                return False\n\n            try:\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, EllipticCurvePrivateKey)\n                    else key\n                )\n                public_key.verify(der_sig, msg, ECDSA(self.hash_alg()))\n                return True\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: Literal[True]) -> JWKDict: ...\n\n        @overload\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: Literal[False] = False) -> str: ...\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                public_numbers = key_obj.public_key().public_numbers()\n            elif isinstance(key_obj, EllipticCurvePublicKey):\n                public_numbers = key_obj.public_numbers()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if isinstance(key_obj.curve, SECP256R1):\n                crv = \"P-256\"\n            elif isinstance(key_obj.curve, SECP384R1):\n                crv = \"P-384\"\n            elif isinstance(key_obj.curve, SECP521R1):\n                crv = \"P-521\"\n            elif isinstance(key_obj.curve, SECP256K1):\n                crv = \"secp256k1\"\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {key_obj.curve}\")\n\n            obj: dict[str, Any] = {\n                \"kty\": \"EC\",\n                \"crv\": crv,\n                \"x\": to_base64url_uint(\n                    public_numbers.x,\n                    bit_length=key_obj.curve.key_size,\n                ).decode(),\n                \"y\": to_base64url_uint(\n                    public_numbers.y,\n                    bit_length=key_obj.curve.key_size,\n                ).decode(),\n            }\n\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                obj[\"d\"] = to_base64url_uint(\n                    key_obj.private_numbers().private_value,\n                    bit_length=key_obj.curve.key_size,\n                ).decode()\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedECKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\") from None\n\n            if obj.get(\"kty\") != \"EC\":\n                raise InvalidKeyError(\"Not an Elliptic curve key\") from None\n\n            if \"x\" not in obj or \"y\" not in obj:\n                raise InvalidKeyError(\"Not an Elliptic curve key\") from None\n\n            x = base64url_decode(obj.get(\"x\"))\n            y = base64url_decode(obj.get(\"y\"))\n\n            curve = obj.get(\"crv\")\n            curve_obj: EllipticCurve\n\n            if curve == \"P-256\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve P-256\"\n                    ) from None\n            elif curve == \"P-384\":\n                if len(x) == len(y) == 48:\n                    curve_obj = SECP384R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 48 bytes for curve P-384\"\n                    ) from None\n            elif curve == \"P-521\":\n                if len(x) == len(y) == 66:\n                    curve_obj = SECP521R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 66 bytes for curve P-521\"\n                    ) from None\n            elif curve == \"secp256k1\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256K1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve secp256k1\"\n                    )\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            public_numbers = EllipticCurvePublicNumbers(\n                x=int.from_bytes(x, byteorder=\"big\"),\n                y=int.from_bytes(y, byteorder=\"big\"),\n                curve=curve_obj,\n            )\n\n            if \"d\" not in obj:\n                return public_numbers.public_key()\n\n            d = base64url_decode(obj.get(\"d\"))\n            if len(d) != len(x):\n                raise InvalidKeyError(\n                    \"D should be {} bytes for curve {}\", len(x), curve\n                )\n\n            return EllipticCurvePrivateNumbers(\n                int.from_bytes(d, byteorder=\"big\"), public_numbers\n            ).private_key()",
      "old_code": "    class ECAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        ECDSA and the specified hash function\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        _crypto_key_types = ALLOWED_EC_KEY_TYPES\n\n        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg\n\n        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, self._crypto_key_types):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    public_key: PublicKeyTypes = load_ssh_public_key(key_bytes)\n                else:\n                    public_key = load_pem_public_key(key_bytes)\n\n                # Explicit check the key to prevent confusing errors from cryptography\n                self.check_crypto_key_type(public_key)\n                return cast(EllipticCurvePublicKey, public_key)\n            except ValueError:\n                private_key = load_pem_private_key(key_bytes, password=None)\n                self.check_crypto_key_type(private_key)\n                return cast(EllipticCurvePrivateKey, private_key)\n\n        def sign(self, msg: bytes, key: EllipticCurvePrivateKey) -> bytes:\n            der_sig = key.sign(msg, ECDSA(self.hash_alg()))\n\n            return der_to_raw_signature(der_sig, key.curve)\n\n        def verify(self, msg: bytes, key: AllowedECKeys, sig: bytes) -> bool:\n            try:\n                der_sig = raw_to_der_signature(sig, key.curve)\n            except ValueError:\n                return False\n\n            try:\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, EllipticCurvePrivateKey)\n                    else key\n                )\n                public_key.verify(der_sig, msg, ECDSA(self.hash_alg()))\n                return True\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: Literal[True]) -> JWKDict: ...\n\n        @overload\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: Literal[False] = False) -> str: ...\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                public_numbers = key_obj.public_key().public_numbers()\n            elif isinstance(key_obj, EllipticCurvePublicKey):\n                public_numbers = key_obj.public_numbers()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if isinstance(key_obj.curve, SECP256R1):\n                crv = \"P-256\"\n            elif isinstance(key_obj.curve, SECP384R1):\n                crv = \"P-384\"\n            elif isinstance(key_obj.curve, SECP521R1):\n                crv = \"P-521\"\n            elif isinstance(key_obj.curve, SECP256K1):\n                crv = \"secp256k1\"\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {key_obj.curve}\")\n\n            obj: dict[str, Any] = {\n                \"kty\": \"EC\",\n                \"crv\": crv,\n                \"x\": to_base64url_uint(\n                    public_numbers.x,\n                    bit_length=key_obj.curve.key_size,\n                ).decode(),\n                \"y\": to_base64url_uint(\n                    public_numbers.y,\n                    bit_length=key_obj.curve.key_size,\n                ).decode(),\n            }\n\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                obj[\"d\"] = to_base64url_uint(\n                    key_obj.private_numbers().private_value,\n                    bit_length=key_obj.curve.key_size,\n                ).decode()\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedECKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\") from None\n\n            if obj.get(\"kty\") != \"EC\":\n                raise InvalidKeyError(\"Not an Elliptic curve key\") from None\n\n            if \"x\" not in obj or \"y\" not in obj:\n                raise InvalidKeyError(\"Not an Elliptic curve key\") from None\n\n            x = base64url_decode(obj.get(\"x\"))\n            y = base64url_decode(obj.get(\"y\"))\n\n            curve = obj.get(\"crv\")\n            curve_obj: EllipticCurve\n\n            if curve == \"P-256\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve P-256\"\n                    ) from None\n            elif curve == \"P-384\":\n                if len(x) == len(y) == 48:\n                    curve_obj = SECP384R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 48 bytes for curve P-384\"\n                    ) from None\n            elif curve == \"P-521\":\n                if len(x) == len(y) == 66:\n                    curve_obj = SECP521R1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 66 bytes for curve P-521\"\n                    ) from None\n            elif curve == \"secp256k1\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256K1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve secp256k1\"\n                    )\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            public_numbers = EllipticCurvePublicNumbers(\n                x=int.from_bytes(x, byteorder=\"big\"),\n                y=int.from_bytes(y, byteorder=\"big\"),\n                curve=curve_obj,\n            )\n\n            if \"d\" not in obj:\n                return public_numbers.public_key()\n\n            d = base64url_decode(obj.get(\"d\"))\n            if len(d) != len(x):\n                raise InvalidKeyError(\n                    \"D should be {} bytes for curve {}\", len(x), curve\n                )\n\n            return EllipticCurvePrivateNumbers(\n                int.from_bytes(d, byteorder=\"big\"), public_numbers\n            ).private_key()"
    },
    {
      "path": "jwt/algorithms.py",
      "version": "new",
      "line": 587,
      "kind": "function",
      "qualname": "jwt.algorithms.ECAlgorithm._validate_curve",
      "span": [
        587,
        596
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "        def _validate_curve(self, key: AllowedECKeys) -> None:\n            \"\"\"Validate that the key's curve matches the expected curve.\"\"\"\n            if self.expected_curve is None:\n                return\n\n            if not isinstance(key.curve, self.expected_curve):\n                raise InvalidKeyError(\n                    f\"The key's curve '{key.curve.name}' does not match the expected \"\n                    f\"curve '{self.expected_curve.name}' for this algorithm\"\n                )",
      "old_code": null
    },
    {
      "path": "jwt/algorithms.py",
      "version": "new",
      "line": 600,
      "kind": "function",
      "qualname": "jwt.algorithms.ECAlgorithm.prepare_key",
      "span": [
        598,
        627
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, self._crypto_key_types):\n                self._validate_curve(key)\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    public_key: PublicKeyTypes = load_ssh_public_key(key_bytes)\n                else:\n                    public_key = load_pem_public_key(key_bytes)\n\n                # Explicit check the key to prevent confusing errors from cryptography\n                self.check_crypto_key_type(public_key)\n                ec_public_key = cast(EllipticCurvePublicKey, public_key)\n                self._validate_curve(ec_public_key)\n                return ec_public_key\n            except ValueError:\n                private_key = load_pem_private_key(key_bytes, password=None)\n                self.check_crypto_key_type(private_key)\n                ec_private_key = cast(EllipticCurvePrivateKey, private_key)\n                self._validate_curve(ec_private_key)\n                return ec_private_key",
      "old_code": "        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, self._crypto_key_types):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    public_key: PublicKeyTypes = load_ssh_public_key(key_bytes)\n                else:\n                    public_key = load_pem_public_key(key_bytes)\n\n                # Explicit check the key to prevent confusing errors from cryptography\n                self.check_crypto_key_type(public_key)\n                return cast(EllipticCurvePublicKey, public_key)\n            except ValueError:\n                private_key = load_pem_private_key(key_bytes, password=None)\n                self.check_crypto_key_type(private_key)\n                return cast(EllipticCurvePrivateKey, private_key)"
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1165,
      "kind": "module",
      "qualname": "tests.test_algorithms",
      "span": null,
      "reason": "diff_new_line_outside_defs",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": null,
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1168,
      "kind": "class",
      "qualname": "tests.test_algorithms.TestECCurveValidation",
      "span": [
        1168,
        1389
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "class TestECCurveValidation:\n    \"\"\"Tests for ECDSA curve validation per RFC 7518 Section 3.4.\"\"\"\n\n    def test_ec_curve_validation_rejects_wrong_curve_for_es256(self):\n        \"\"\"ES256 should reject keys that are not P-256.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        # P-384 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p384_key)\n        assert \"secp384r1\" in str(excinfo.value)\n        assert \"secp256r1\" in str(excinfo.value)\n\n    def test_ec_curve_validation_rejects_wrong_curve_for_es384(self):\n        \"\"\"ES384 should reject keys that are not P-384.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP384R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA384, SECP384R1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp384r1\" in str(excinfo.value)\n\n    def test_ec_curve_validation_rejects_wrong_curve_for_es512(self):\n        \"\"\"ES512 should reject keys that are not P-521.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP521R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA512, SECP521R1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp521r1\" in str(excinfo.value)\n\n    def test_ec_curve_validation_rejects_wrong_curve_for_es256k(self):\n        \"\"\"ES256K should reject keys that are not secp256k1.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256K1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256K1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp256k1\" in str(excinfo.value)\n\n    def test_ec_curve_validation_accepts_correct_curve_for_es256(self):\n        \"\"\"ES256 should accept P-256 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key\n\n    def test_ec_curve_validation_accepts_correct_curve_for_es384(self):\n        \"\"\"ES384 should accept P-384 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP384R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA384, SECP384R1)\n\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key\n\n    def test_ec_curve_validation_accepts_correct_curve_for_es512(self):\n        \"\"\"ES512 should accept P-521 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP521R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA512, SECP521R1)\n\n        with open(key_path(\"jwk_ec_key_P-521.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key\n\n    def test_ec_curve_validation_accepts_correct_curve_for_es256k(self):\n        \"\"\"ES256K should accept secp256k1 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256K1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256K1)\n\n        with open(key_path(\"jwk_ec_key_secp256k1.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key\n\n    def test_ec_curve_validation_rejects_p192_for_es256(self):\n        \"\"\"ES256 should reject P-192 keys (weaker than P-256).\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        with open(key_path(\"testkey_ec_secp192r1.priv\")) as keyfile:\n            with pytest.raises(InvalidKeyError) as excinfo:\n                algo.prepare_key(keyfile.read())\n            assert \"secp192r1\" in str(excinfo.value)\n            assert \"secp256r1\" in str(excinfo.value)\n\n    def test_ec_algorithm_without_expected_curve_accepts_any_curve(self):\n        \"\"\"ECAlgorithm without expected_curve should accept any curve (backwards compat).\"\"\"\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        # Should accept P-256\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p256_key)\n\n        # Should accept P-384\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p384_key)\n\n        # Should accept P-521\n        with open(key_path(\"jwk_ec_key_P-521.json\")) as keyfile:\n            p521_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p521_key)\n\n        # Should accept secp256k1\n        with open(key_path(\"jwk_ec_key_secp256k1.json\")) as keyfile:\n            secp256k1_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(secp256k1_key)\n\n    def test_default_algorithms_have_correct_expected_curve(self):\n        \"\"\"Default algorithms returned by get_default_algorithms should have expected_curve set.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import (\n            SECP256K1,\n            SECP256R1,\n            SECP384R1,\n            SECP521R1,\n        )\n\n        from jwt.algorithms import get_default_algorithms\n\n        algorithms = get_default_algorithms()\n\n        es256 = algorithms[\"ES256\"]\n        assert isinstance(es256, ECAlgorithm)\n        assert es256.expected_curve == SECP256R1\n\n        es256k = algorithms[\"ES256K\"]\n        assert isinstance(es256k, ECAlgorithm)\n        assert es256k.expected_curve == SECP256K1\n\n        es384 = algorithms[\"ES384\"]\n        assert isinstance(es384, ECAlgorithm)\n        assert es384.expected_curve == SECP384R1\n\n        es521 = algorithms[\"ES521\"]\n        assert isinstance(es521, ECAlgorithm)\n        assert es521.expected_curve == SECP521R1\n\n        es512 = algorithms[\"ES512\"]\n        assert isinstance(es512, ECAlgorithm)\n        assert es512.expected_curve == SECP521R1\n\n    def test_ec_curve_validation_with_pem_key(self):\n        \"\"\"Curve validation should work with PEM-formatted keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        # P-256 PEM key should be accepted\n        with open(key_path(\"testkey_ec.priv\")) as keyfile:\n            algo.prepare_key(keyfile.read())\n\n        # P-192 PEM key should be rejected\n        with open(key_path(\"testkey_ec_secp192r1.priv\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                algo.prepare_key(keyfile.read())\n\n    def test_jwt_encode_decode_rejects_wrong_curve(self):\n        \"\"\"Integration test: jwt.encode/decode should reject wrong curve keys.\"\"\"\n        import jwt\n\n        # Use P-384 key with ES256 algorithm (expects P-256)\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        # Encoding should fail\n        with pytest.raises(InvalidKeyError):\n            jwt.encode({\"hello\": \"world\"}, p384_key, algorithm=\"ES256\")\n\n        # Create a valid token with P-256 key\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        token = jwt.encode({\"hello\": \"world\"}, p256_key, algorithm=\"ES256\")\n\n        # Decoding with wrong curve key should fail\n        with open(key_path(\"jwk_ec_pub_P-384.json\")) as keyfile:\n            p384_pub_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError):\n            jwt.decode(token, p384_pub_key, algorithms=[\"ES256\"])\n\n        # Decoding with correct curve key should succeed\n        with open(key_path(\"jwk_ec_pub_P-256.json\")) as keyfile:\n            p256_pub_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        decoded = jwt.decode(token, p256_pub_key, algorithms=[\"ES256\"])\n        assert decoded == {\"hello\": \"world\"}",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1171,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_rejects_wrong_curve_for_es256",
      "span": [
        1171,
        1184
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_rejects_wrong_curve_for_es256(self):\n        \"\"\"ES256 should reject keys that are not P-256.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        # P-384 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p384_key)\n        assert \"secp384r1\" in str(excinfo.value)\n        assert \"secp256r1\" in str(excinfo.value)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1186,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_rejects_wrong_curve_for_es384",
      "span": [
        1186,
        1199
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_rejects_wrong_curve_for_es384(self):\n        \"\"\"ES384 should reject keys that are not P-384.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP384R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA384, SECP384R1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp384r1\" in str(excinfo.value)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1201,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_rejects_wrong_curve_for_es512",
      "span": [
        1201,
        1214
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_rejects_wrong_curve_for_es512(self):\n        \"\"\"ES512 should reject keys that are not P-521.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP521R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA512, SECP521R1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp521r1\" in str(excinfo.value)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1216,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_rejects_wrong_curve_for_es256k",
      "span": [
        1216,
        1229
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_rejects_wrong_curve_for_es256k(self):\n        \"\"\"ES256K should reject keys that are not secp256k1.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256K1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256K1)\n\n        # P-256 key should be rejected\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(p256_key)\n        assert \"secp256r1\" in str(excinfo.value)\n        assert \"secp256k1\" in str(excinfo.value)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1231,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_accepts_correct_curve_for_es256",
      "span": [
        1231,
        1240
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_accepts_correct_curve_for_es256(self):\n        \"\"\"ES256 should accept P-256 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1242,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_accepts_correct_curve_for_es384",
      "span": [
        1242,
        1251
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_accepts_correct_curve_for_es384(self):\n        \"\"\"ES384 should accept P-384 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP384R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA384, SECP384R1)\n\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1253,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_accepts_correct_curve_for_es512",
      "span": [
        1253,
        1262
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_accepts_correct_curve_for_es512(self):\n        \"\"\"ES512 should accept P-521 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP521R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA512, SECP521R1)\n\n        with open(key_path(\"jwk_ec_key_P-521.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1264,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_accepts_correct_curve_for_es256k",
      "span": [
        1264,
        1273
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_accepts_correct_curve_for_es256k(self):\n        \"\"\"ES256K should accept secp256k1 keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256K1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256K1)\n\n        with open(key_path(\"jwk_ec_key_secp256k1.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n            prepared = algo.prepare_key(key)\n            assert prepared is key",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1275,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_rejects_p192_for_es256",
      "span": [
        1275,
        1285
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_rejects_p192_for_es256(self):\n        \"\"\"ES256 should reject P-192 keys (weaker than P-256).\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        with open(key_path(\"testkey_ec_secp192r1.priv\")) as keyfile:\n            with pytest.raises(InvalidKeyError) as excinfo:\n                algo.prepare_key(keyfile.read())\n            assert \"secp192r1\" in str(excinfo.value)\n            assert \"secp256r1\" in str(excinfo.value)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1287,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_algorithm_without_expected_curve_accepts_any_curve",
      "span": [
        1287,
        1309
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_algorithm_without_expected_curve_accepts_any_curve(self):\n        \"\"\"ECAlgorithm without expected_curve should accept any curve (backwards compat).\"\"\"\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        # Should accept P-256\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p256_key)\n\n        # Should accept P-384\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p384_key)\n\n        # Should accept P-521\n        with open(key_path(\"jwk_ec_key_P-521.json\")) as keyfile:\n            p521_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(p521_key)\n\n        # Should accept secp256k1\n        with open(key_path(\"jwk_ec_key_secp256k1.json\")) as keyfile:\n            secp256k1_key = algo.from_jwk(keyfile.read())\n            algo.prepare_key(secp256k1_key)",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1311,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_default_algorithms_have_correct_expected_curve",
      "span": [
        1311,
        1342
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_default_algorithms_have_correct_expected_curve(self):\n        \"\"\"Default algorithms returned by get_default_algorithms should have expected_curve set.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import (\n            SECP256K1,\n            SECP256R1,\n            SECP384R1,\n            SECP521R1,\n        )\n\n        from jwt.algorithms import get_default_algorithms\n\n        algorithms = get_default_algorithms()\n\n        es256 = algorithms[\"ES256\"]\n        assert isinstance(es256, ECAlgorithm)\n        assert es256.expected_curve == SECP256R1\n\n        es256k = algorithms[\"ES256K\"]\n        assert isinstance(es256k, ECAlgorithm)\n        assert es256k.expected_curve == SECP256K1\n\n        es384 = algorithms[\"ES384\"]\n        assert isinstance(es384, ECAlgorithm)\n        assert es384.expected_curve == SECP384R1\n\n        es521 = algorithms[\"ES521\"]\n        assert isinstance(es521, ECAlgorithm)\n        assert es521.expected_curve == SECP521R1\n\n        es512 = algorithms[\"ES512\"]\n        assert isinstance(es512, ECAlgorithm)\n        assert es512.expected_curve == SECP521R1",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1344,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_ec_curve_validation_with_pem_key",
      "span": [
        1344,
        1357
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_ec_curve_validation_with_pem_key(self):\n        \"\"\"Curve validation should work with PEM-formatted keys.\"\"\"\n        from cryptography.hazmat.primitives.asymmetric.ec import SECP256R1\n\n        algo = ECAlgorithm(ECAlgorithm.SHA256, SECP256R1)\n\n        # P-256 PEM key should be accepted\n        with open(key_path(\"testkey_ec.priv\")) as keyfile:\n            algo.prepare_key(keyfile.read())\n\n        # P-192 PEM key should be rejected\n        with open(key_path(\"testkey_ec_secp192r1.priv\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                algo.prepare_key(keyfile.read())",
      "old_code": null
    },
    {
      "path": "tests/test_algorithms.py",
      "version": "new",
      "line": 1359,
      "kind": "function",
      "qualname": "tests.test_algorithms.TestECCurveValidation.test_jwt_encode_decode_rejects_wrong_curve",
      "span": [
        1359,
        1389
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_jwt_encode_decode_rejects_wrong_curve(self):\n        \"\"\"Integration test: jwt.encode/decode should reject wrong curve keys.\"\"\"\n        import jwt\n\n        # Use P-384 key with ES256 algorithm (expects P-256)\n        with open(key_path(\"jwk_ec_key_P-384.json\")) as keyfile:\n            p384_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        # Encoding should fail\n        with pytest.raises(InvalidKeyError):\n            jwt.encode({\"hello\": \"world\"}, p384_key, algorithm=\"ES256\")\n\n        # Create a valid token with P-256 key\n        with open(key_path(\"jwk_ec_key_P-256.json\")) as keyfile:\n            p256_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        token = jwt.encode({\"hello\": \"world\"}, p256_key, algorithm=\"ES256\")\n\n        # Decoding with wrong curve key should fail\n        with open(key_path(\"jwk_ec_pub_P-384.json\")) as keyfile:\n            p384_pub_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        with pytest.raises(InvalidKeyError):\n            jwt.decode(token, p384_pub_key, algorithms=[\"ES256\"])\n\n        # Decoding with correct curve key should succeed\n        with open(key_path(\"jwk_ec_pub_P-256.json\")) as keyfile:\n            p256_pub_key = ECAlgorithm.from_jwk(keyfile.read())\n\n        decoded = jwt.decode(token, p256_pub_key, algorithms=[\"ES256\"])\n        assert decoded == {\"hello\": \"world\"}",
      "old_code": null
    },
    {
      "path": "tests/test_api_jws.py",
      "version": "new",
      "line": 649,
      "kind": "class",
      "qualname": "tests.test_api_jws.TestJWS",
      "span": [
        41,
        891
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "class TestJWS:\n    def test_register_algo_does_not_allow_duplicate_registration(self, jws):\n        jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n        with pytest.raises(ValueError):\n            jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n    def test_register_algo_rejects_non_algorithm_obj(self, jws):\n        with pytest.raises(TypeError):\n            jws.register_algorithm(\"AAA123\", {})\n\n    def test_unregister_algo_removes_algorithm(self, jws):\n        supported = jws.get_algorithms()\n        assert \"none\" in supported\n        assert \"HS256\" in supported\n\n        jws.unregister_algorithm(\"HS256\")\n\n        supported = jws.get_algorithms()\n        assert \"HS256\" not in supported\n\n    def test_unregister_algo_throws_error_if_not_registered(self, jws):\n        with pytest.raises(KeyError):\n            jws.unregister_algorithm(\"AAA\")\n\n    def test_algo_parameter_removes_alg_from_algorithms_list(self, jws):\n        assert \"none\" in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n        jws = PyJWS(algorithms=[\"HS256\"])\n        assert \"none\" not in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n    def test_override_options(self):\n        jws = PyJWS(options={\"verify_signature\": False})\n\n        assert not jws.options[\"verify_signature\"]\n\n    def test_non_object_options_dont_persist(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n        assert jws.options[\"verify_signature\"]\n\n    def test_options_must_be_dict(self):\n        pytest.raises(TypeError, PyJWS, options=object())\n        pytest.raises((TypeError, ValueError), PyJWS, options=(\"something\"))\n\n    def test_encode_decode(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(payload, secret, algorithm=\"HS256\")\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decode_fails_when_alg_is_not_on_method_algorithms_param(\n        self, jws, payload\n    ):\n        secret = \"secret\"\n        jws_token = jws.encode(payload, secret, algorithm=\"HS256\")\n        jws.decode(jws_token, secret, algorithms=[\"HS256\"])\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(jws_token, secret, algorithms=[\"HS384\"])\n\n    def test_decode_works_with_unicode_token(self, jws):\n        secret = \"secret\"\n        unicode_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        jws.decode(unicode_jws, secret, algorithms=[\"HS256\"])\n\n    def test_decode_missing_segments_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9\"  # Missing segment\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Not enough segments\"\n\n    def test_decode_invalid_token_type_is_none(self, jws):\n        example_jws = None\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_invalid_token_type_is_int(self, jws):\n        example_jws = 123\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_with_non_mapping_header_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = (\n            \"MQ\"  # == 1\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Invalid header string: must be a json object\"\n\n    def test_encode_default_algorithm(self, jws, payload):\n        msg = jws.encode(payload, \"secret\")\n        decoded = jws.decode_complete(msg, \"secret\", algorithms=[\"HS256\"])\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"H\\x8a\\xf4\\xdf3:\\xe1\\xac\\x16E\\xd3\\xeb\\x00\\xcf\\xfa\\xd5\\x05\\xac\"\n                b\"e\\xc8@\\xb6\\x00\\xd5\\xde\\x9aa|s\\xcfZB\"\n            ),\n        }\n\n    def test_encode_algorithm_param_should_be_case_sensitive(self, jws, payload):\n        jws.encode(payload, \"secret\", algorithm=\"HS256\")\n\n        with pytest.raises(NotImplementedError) as context:\n            jws.encode(payload, None, algorithm=\"hs256\")\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_encode_with_headers_alg_none(self, jws, payload):\n        msg = jws.encode(payload, key=None, headers={\"alg\": \"none\"})\n        with pytest.raises(DecodeError) as context:\n            jws.decode(msg, algorithms=[\"none\"])\n        assert str(context.value) == \"Signature verification failed\"\n\n    @crypto_required\n    def test_encode_with_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    @crypto_required\n    def test_encode_with_alg_hs256_and_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, algorithm=\"HS256\", headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    def test_encode_with_jwk(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        msg = jws.encode(payload, key=jwk)\n        decoded = jws.decode_complete(msg, key=jwk, algorithms=[\"HS256\"])\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"H\\x8a\\xf4\\xdf3:\\xe1\\xac\\x16E\\xd3\\xeb\\x00\\xcf\\xfa\\xd5\\x05\\xac\"\n                b\"e\\xc8@\\xb6\\x00\\xd5\\xde\\x9aa|s\\xcfZB\"\n            ),\n        }\n\n    def test_decode_algorithm_param_should_be_case_sensitive(self, jws):\n        example_jws = (\n            \"eyJhbGciOiJoczI1NiIsInR5cCI6IkpXVCJ9\"  # alg = hs256\n            \".eyJoZWxsbyI6IndvcmxkIn0\"\n            \".5R_FEPE7SW2dT9GgIxPgZATjFGXfUDOSwo7TtO_Kd_g\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError) as context:\n            jws.decode(example_jws, \"secret\", algorithms=[\"hs256\"])\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_bad_secret(self, jws, payload):\n        right_secret = \"foo\"\n        bad_secret = \"bar\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as excinfo:\n            # Backward compat for ticket #315\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n        with pytest.raises(InvalidSignatureError) as excinfo:\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n    def test_decodes_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_complete_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded = jws.decode_complete(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"\\x80E\\xb4\\xa5\\xd58\\x93\\x13\\xed\\x86;^\\x85\\x87a\\xc4\"\n                b\"\\x1ff0\\xe1\\x9a\\x8e\\xddq\\x08\\xa9F\\x19p\\xc9\\xf0\\xf3\"\n            ),\n        }\n\n    def test_decodes_with_jwk(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_no_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk)\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_mismatched_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS512\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, jwk)\n\n    # 'Control' Elliptic Curve jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_es384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_ec.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"eyJoZWxsbyI6IndvcmxkIn0.TORyNQab_MoXM7DvNKaTwbrJr4UY\"\n            b\"d2SsX8hhlnWelQFmPFSf_JzC2EbLnar92t-bXsDovzxp25ExazrVHkfPkQ\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"ES256\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    # 'Control' RSA jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_rs384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_rsa.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9\"\n            b\".eyJoZWxsbyI6IndvcmxkIn0\"\n            b\".yNQ3nI9vEDs7lEh-Cp81McPuiQ4ZRv6FL4evTYYAh1X\"\n            b\"lRTTR3Cz8pPA9Stgso8Ra9xGB4X3rlra1c8Jz10nTUju\"\n            b\"O06OMm7oXdrnxp1KIiAJDerWHkQ7l3dlizIk1bmMA457\"\n            b\"W2fNzNfHViuED5ISM081dgf_a71qBwJ_yShMMrSOfxDx\"\n            b\"mX9c4DjRogRJG8SM5PvpLqI_Cm9iQPGMvmYK7gzcq2cJ\"\n            b\"urHRJDJHTqIdpLWXkY7zVikeen6FhuGyn060Dz9gYq9t\"\n            b\"uwmrtSWCBUjiN8sqJ00CDgycxKqHfUndZbEAOjcCAhBr\"\n            b\"qWW3mSVivUfubsYbwUdUG3fSRPjaUPcpe8A\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"RS384\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    def test_load_verify_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        decoded_payload = jws.decode(\n            example_jws, key=example_secret, algorithms=[\"HS256\"]\n        )\n        assert decoded_payload == payload\n\n    def test_allow_skip_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n        decoded_payload = jws.decode(jws_message, options={\"verify_signature\": False})\n\n        assert decoded_payload == payload\n\n    def test_decode_with_optional_algorithms(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, key=example_secret)\n\n        assert (\n            'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            in str(exc.value)\n        )\n\n    def test_decode_no_algorithms_verify_signature_false(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        jws.decode(\n            example_jws,\n            key=example_secret,\n            options={\"verify_signature\": False},\n        )\n\n    def test_load_no_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        decoded_payload = jws.decode(\n            jws_message,\n            key=None,\n            algorithms=[\"HS256\"],\n            options={\"verify_signature\": False},\n        )\n\n        assert decoded_payload == payload\n\n    def test_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n    def test_verify_signature_with_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n        assert \"Signature verification\" in str(exc.value)\n\n    def test_verify_signature_with_no_algo_header_throws_exception(self, jws, payload):\n        example_jws = b\"e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY\"\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, \"secret\", algorithms=[\"HS256\"])\n\n    def test_invalid_crypto_alg(self, jws, payload):\n        with pytest.raises(NotImplementedError):\n            jws.encode(payload, \"secret\", algorithm=\"HS1024\")\n\n    @no_crypto_required\n    def test_missing_crypto_library_better_error_messages(self, jws, payload):\n        with pytest.raises(NotImplementedError) as excinfo:\n            jws.encode(payload, \"secret\", algorithm=\"RS256\")\n            assert \"cryptography\" in str(excinfo.value)\n\n    def test_unicode_secret(self, jws, payload):\n        secret = \"\\xc2\"\n        jws_message = jws.encode(payload, secret)\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_nonascii_secret(self, jws, payload):\n        secret = \"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_bytes_secret(self, jws, payload):\n        secret = b\"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    @pytest.mark.parametrize(\"sort_headers\", (False, True))\n    def test_sorting_of_headers(self, jws, payload, sort_headers):\n        jws_message = jws.encode(\n            payload,\n            key=\"\\xc2\",\n            headers={\"b\": \"1\", \"a\": \"2\"},\n            sort_headers=sort_headers,\n        )\n        header_json = base64url_decode(jws_message.split(\".\")[0])\n        assert sort_headers == (header_json.index(b'\"a\"') < header_json.index(b'\"b\"'))\n\n    def test_decode_invalid_header_padding(self, jws):\n        example_jws = (\n            \"aeyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"header padding\" in str(exc.value)\n\n    def test_decode_invalid_header_string(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTbpIiwgInR5cCI6ICJKV1QifQ==\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid header\" in str(exc.value)\n\n    def test_decode_invalid_payload_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".aeyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid payload padding\" in str(exc.value)\n\n    def test_decode_invalid_crypto_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".aatvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid crypto padding\" in str(exc.value)\n\n    def test_decode_with_algo_none_should_fail(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=\"none\")\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"none\"])\n\n    def test_decode_with_algo_none_and_verify_false_should_pass(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=\"none\")\n        jws.decode(jws_message, options={\"verify_signature\": False})\n\n    def test_get_unverified_header_returns_header_values(self, jws, payload):\n        jws_message = jws.encode(\n            payload,\n            key=\"secret\",\n            algorithm=\"HS256\",\n            headers={\"kid\": \"toomanysecrets\"},\n        )\n\n        header = jws.get_unverified_header(jws_message)\n\n        assert \"kid\" in header\n        assert header[\"kid\"] == \"toomanysecrets\"\n\n    def test_get_unverified_header_fails_on_bad_header_types(self, jws, payload):\n        # Contains a bad kid value (int 123 instead of string)\n        example_jws = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6MTIzfQ\"\n            \".eyJzdWIiOiIxMjM0NTY3ODkwIn0\"\n            \".vs2WY54jfpKP3JGC73Vq5YlMsqM5oTZ1ZydT77SiZSk\"\n        )\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.get_unverified_header(example_jws)\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    @pytest.mark.parametrize(\n        \"algo\",\n        [\n            \"RS256\",\n            \"RS384\",\n            \"RS512\",\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_rsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted RSA key\n        with open(key_path(\"testkey_rsa.priv\"), \"rb\") as rsa_priv_file:\n            priv_rsakey = load_pem_private_key(rsa_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\"), \"rb\") as rsa_pub_file:\n            pub_rsakey = load_ssh_public_key(rsa_pub_file.read())\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_rsa.priv\")) as rsa_priv_file:\n            priv_rsakey = rsa_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\")) as rsa_pub_file:\n            pub_rsakey = rsa_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n    def test_rsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"RS256\" in jws_algorithms\n            assert \"RS384\" in jws_algorithms\n            assert \"RS512\" in jws_algorithms\n            assert \"PS256\" in jws_algorithms\n            assert \"PS384\" in jws_algorithms\n            assert \"PS512\" in jws_algorithms\n\n        else:\n            assert \"RS256\" not in jws_algorithms\n            assert \"RS384\" not in jws_algorithms\n            assert \"RS512\" not in jws_algorithms\n            assert \"PS256\" not in jws_algorithms\n            assert \"PS384\" not in jws_algorithms\n            assert \"PS512\" not in jws_algorithms\n\n    @pytest.mark.parametrize(\n        \"algo,priv_key_file,pub_key_file\",\n        [\n            (\"ES256\", \"jwk_ec_key_P-256.json\", \"jwk_ec_pub_P-256.json\"),\n            (\"ES256K\", \"jwk_ec_key_secp256k1.json\", \"jwk_ec_pub_secp256k1.json\"),\n            (\"ES384\", \"jwk_ec_key_P-384.json\", \"jwk_ec_pub_P-384.json\"),\n            (\"ES512\", \"jwk_ec_key_P-521.json\", \"jwk_ec_pub_P-521.json\"),\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_ecdsa_related_algorithms(\n        self, jws, payload, algo, priv_key_file, pub_key_file\n    ):\n        from jwt.algorithms import ECAlgorithm\n\n        # Load keys from JWK files (each algorithm requires its specific curve)\n        with open(key_path(priv_key_file)) as priv_file:\n            priv_eckey = ECAlgorithm.from_jwk(priv_file.read())\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(pub_key_file)) as pub_file:\n            pub_eckey = ECAlgorithm.from_jwk(pub_file.read())\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n    def test_ecdsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"ES256\" in jws_algorithms\n            assert \"ES256K\" in jws_algorithms\n            assert \"ES384\" in jws_algorithms\n            assert \"ES512\" in jws_algorithms\n        else:\n            assert \"ES256\" not in jws_algorithms\n            assert \"ES256K\" not in jws_algorithms\n            assert \"ES384\" not in jws_algorithms\n            assert \"ES512\" not in jws_algorithms\n\n    def test_skip_check_signature(self, jws):\n        token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJzb21lIjoicGF5bG9hZCJ9\"\n            \".4twFt5NiznN84AWoo1d7KO1T_yoc0Z6XOpOVswacPZA\"\n        )\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n    def test_decode_options_must_be_dict(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        with pytest.raises(TypeError):\n            jws.decode(token, \"secret\", options=object())\n\n        with pytest.raises((TypeError, ValueError)):\n            jws.decode(token, \"secret\", options=\"something\")\n\n    def test_custom_json_encoder(self, jws, payload):\n        class CustomJSONEncoder(json.JSONEncoder):\n            def default(self, o):\n                assert isinstance(o, Decimal)\n                return \"it worked\"\n\n        data = {\"some_decimal\": Decimal(\"2.2\")}\n\n        with pytest.raises(TypeError):\n            jws.encode(payload, \"secret\", headers=data)\n\n        token = jws.encode(\n            payload, \"secret\", headers=data, json_encoder=CustomJSONEncoder\n        )\n\n        header, *_ = token.split(\".\")\n        header = json.loads(base64url_decode(header))\n\n        assert \"some_decimal\" in header\n        assert header[\"some_decimal\"] == \"it worked\"\n\n    def test_encode_headers_parameter_adds_headers(self, jws, payload):\n        headers = {\"testheader\": True}\n        token = jws.encode(payload, \"secret\", headers=headers)\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header = header.decode()\n\n        header_obj = json.loads(header)\n\n        assert \"testheader\" in header_obj\n        assert header_obj[\"testheader\"] == headers[\"testheader\"]\n\n    def test_encode_with_typ(self, jws):\n        payload = \"\"\"\n        {\n          \"iss\": \"https://scim.example.com\",\n          \"iat\": 1458496404,\n          \"jti\": \"4d3559ec67504aaba65d40b0363faad8\",\n          \"aud\": [\n            \"https://scim.example.com/Feeds/98d52461fa5bbc879593b7754\",\n            \"https://scim.example.com/Feeds/5d7604516b1d08641d7676ee7\"\n          ],\n          \"events\": {\n            \"urn:ietf:params:scim:event:create\": {\n              \"ref\":\n                  \"https://scim.example.com/Users/44f6142df96bd6ab61e7521d9\",\n              \"attributes\": [\"id\", \"name\", \"userName\", \"password\", \"emails\"]\n            }\n          }\n        }\n        \"\"\"\n        token = jws.encode(\n            payload.encode(\"utf-8\"), \"secret\", headers={\"typ\": \"secevent+jwt\"}\n        )\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" in header_obj\n        assert header_obj[\"typ\"] == \"secevent+jwt\"\n\n    def test_encode_with_typ_empty_string(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": \"\"})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_none(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": None})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_without_keywords(self, jws, payload):\n        headers = {\"foo\": \"bar\"}\n        token = jws.encode(payload, \"secret\", \"HS256\", headers, None)\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"foo\" in header_obj\n        assert header_obj[\"foo\"] == \"bar\"\n\n    def test_encode_fails_on_invalid_kid_types(self, jws, payload):\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": 123})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": None})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    def test_encode_decode_with_detached_content(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        jws.decode(jws_message, secret, algorithms=[\"HS256\"], detached_payload=payload)\n\n    def test_encode_detached_content_with_b64_header(self, jws, payload):\n        secret = \"secret\"\n\n        # Check that detached content is automatically detected when b64 is false\n        headers = {\"b64\": False}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" in msg_header_obj\n        assert msg_header_obj[\"b64\"] is False\n        # Check that the payload is not inside the token\n        assert not msg_payload\n\n        # Check that content is not detached and b64 header removed when b64 is true\n        headers = {\"b64\": True}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" not in msg_header_obj\n        assert msg_payload\n\n    def test_decode_detached_content_without_proper_argument(self, jws):\n        example_jws = (\n            \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2V9\"\n            \".\"\n            \".65yNkX_ZH4A_6pHaTL_eI84OXOHtfl4K0k5UnlXZ8f4\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert (\n            'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'\n            in str(exc.value)\n        )\n\n    def test_decode_warns_on_unsupported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n\n    def test_decode_complete_warns_on_unuspported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode_complete(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)",
      "old_code": "class TestJWS:\n    def test_register_algo_does_not_allow_duplicate_registration(self, jws):\n        jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n        with pytest.raises(ValueError):\n            jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n    def test_register_algo_rejects_non_algorithm_obj(self, jws):\n        with pytest.raises(TypeError):\n            jws.register_algorithm(\"AAA123\", {})\n\n    def test_unregister_algo_removes_algorithm(self, jws):\n        supported = jws.get_algorithms()\n        assert \"none\" in supported\n        assert \"HS256\" in supported\n\n        jws.unregister_algorithm(\"HS256\")\n\n        supported = jws.get_algorithms()\n        assert \"HS256\" not in supported\n\n    def test_unregister_algo_throws_error_if_not_registered(self, jws):\n        with pytest.raises(KeyError):\n            jws.unregister_algorithm(\"AAA\")\n\n    def test_algo_parameter_removes_alg_from_algorithms_list(self, jws):\n        assert \"none\" in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n        jws = PyJWS(algorithms=[\"HS256\"])\n        assert \"none\" not in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n    def test_override_options(self):\n        jws = PyJWS(options={\"verify_signature\": False})\n\n        assert not jws.options[\"verify_signature\"]\n\n    def test_non_object_options_dont_persist(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n        assert jws.options[\"verify_signature\"]\n\n    def test_options_must_be_dict(self):\n        pytest.raises(TypeError, PyJWS, options=object())\n        pytest.raises((TypeError, ValueError), PyJWS, options=(\"something\"))\n\n    def test_encode_decode(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(payload, secret, algorithm=\"HS256\")\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decode_fails_when_alg_is_not_on_method_algorithms_param(\n        self, jws, payload\n    ):\n        secret = \"secret\"\n        jws_token = jws.encode(payload, secret, algorithm=\"HS256\")\n        jws.decode(jws_token, secret, algorithms=[\"HS256\"])\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(jws_token, secret, algorithms=[\"HS384\"])\n\n    def test_decode_works_with_unicode_token(self, jws):\n        secret = \"secret\"\n        unicode_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        jws.decode(unicode_jws, secret, algorithms=[\"HS256\"])\n\n    def test_decode_missing_segments_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9\"  # Missing segment\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Not enough segments\"\n\n    def test_decode_invalid_token_type_is_none(self, jws):\n        example_jws = None\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_invalid_token_type_is_int(self, jws):\n        example_jws = 123\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_with_non_mapping_header_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = (\n            \"MQ\"  # == 1\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Invalid header string: must be a json object\"\n\n    def test_encode_default_algorithm(self, jws, payload):\n        msg = jws.encode(payload, \"secret\")\n        decoded = jws.decode_complete(msg, \"secret\", algorithms=[\"HS256\"])\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"H\\x8a\\xf4\\xdf3:\\xe1\\xac\\x16E\\xd3\\xeb\\x00\\xcf\\xfa\\xd5\\x05\\xac\"\n                b\"e\\xc8@\\xb6\\x00\\xd5\\xde\\x9aa|s\\xcfZB\"\n            ),\n        }\n\n    def test_encode_algorithm_param_should_be_case_sensitive(self, jws, payload):\n        jws.encode(payload, \"secret\", algorithm=\"HS256\")\n\n        with pytest.raises(NotImplementedError) as context:\n            jws.encode(payload, None, algorithm=\"hs256\")\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_encode_with_headers_alg_none(self, jws, payload):\n        msg = jws.encode(payload, key=None, headers={\"alg\": \"none\"})\n        with pytest.raises(DecodeError) as context:\n            jws.decode(msg, algorithms=[\"none\"])\n        assert str(context.value) == \"Signature verification failed\"\n\n    @crypto_required\n    def test_encode_with_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    @crypto_required\n    def test_encode_with_alg_hs256_and_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, algorithm=\"HS256\", headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    def test_encode_with_jwk(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        msg = jws.encode(payload, key=jwk)\n        decoded = jws.decode_complete(msg, key=jwk, algorithms=[\"HS256\"])\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"H\\x8a\\xf4\\xdf3:\\xe1\\xac\\x16E\\xd3\\xeb\\x00\\xcf\\xfa\\xd5\\x05\\xac\"\n                b\"e\\xc8@\\xb6\\x00\\xd5\\xde\\x9aa|s\\xcfZB\"\n            ),\n        }\n\n    def test_decode_algorithm_param_should_be_case_sensitive(self, jws):\n        example_jws = (\n            \"eyJhbGciOiJoczI1NiIsInR5cCI6IkpXVCJ9\"  # alg = hs256\n            \".eyJoZWxsbyI6IndvcmxkIn0\"\n            \".5R_FEPE7SW2dT9GgIxPgZATjFGXfUDOSwo7TtO_Kd_g\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError) as context:\n            jws.decode(example_jws, \"secret\", algorithms=[\"hs256\"])\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_bad_secret(self, jws, payload):\n        right_secret = \"foo\"\n        bad_secret = \"bar\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as excinfo:\n            # Backward compat for ticket #315\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n        with pytest.raises(InvalidSignatureError) as excinfo:\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n    def test_decodes_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_complete_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded = jws.decode_complete(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"\\x80E\\xb4\\xa5\\xd58\\x93\\x13\\xed\\x86;^\\x85\\x87a\\xc4\"\n                b\"\\x1ff0\\xe1\\x9a\\x8e\\xddq\\x08\\xa9F\\x19p\\xc9\\xf0\\xf3\"\n            ),\n        }\n\n    def test_decodes_with_jwk(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_no_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk)\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_mismatched_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS512\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, jwk)\n\n    # 'Control' Elliptic Curve jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_es384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_ec.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"eyJoZWxsbyI6IndvcmxkIn0.TORyNQab_MoXM7DvNKaTwbrJr4UY\"\n            b\"d2SsX8hhlnWelQFmPFSf_JzC2EbLnar92t-bXsDovzxp25ExazrVHkfPkQ\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"ES256\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    # 'Control' RSA jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_rs384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_rsa.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9\"\n            b\".eyJoZWxsbyI6IndvcmxkIn0\"\n            b\".yNQ3nI9vEDs7lEh-Cp81McPuiQ4ZRv6FL4evTYYAh1X\"\n            b\"lRTTR3Cz8pPA9Stgso8Ra9xGB4X3rlra1c8Jz10nTUju\"\n            b\"O06OMm7oXdrnxp1KIiAJDerWHkQ7l3dlizIk1bmMA457\"\n            b\"W2fNzNfHViuED5ISM081dgf_a71qBwJ_yShMMrSOfxDx\"\n            b\"mX9c4DjRogRJG8SM5PvpLqI_Cm9iQPGMvmYK7gzcq2cJ\"\n            b\"urHRJDJHTqIdpLWXkY7zVikeen6FhuGyn060Dz9gYq9t\"\n            b\"uwmrtSWCBUjiN8sqJ00CDgycxKqHfUndZbEAOjcCAhBr\"\n            b\"qWW3mSVivUfubsYbwUdUG3fSRPjaUPcpe8A\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"RS384\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    def test_load_verify_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        decoded_payload = jws.decode(\n            example_jws, key=example_secret, algorithms=[\"HS256\"]\n        )\n        assert decoded_payload == payload\n\n    def test_allow_skip_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n        decoded_payload = jws.decode(jws_message, options={\"verify_signature\": False})\n\n        assert decoded_payload == payload\n\n    def test_decode_with_optional_algorithms(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, key=example_secret)\n\n        assert (\n            'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            in str(exc.value)\n        )\n\n    def test_decode_no_algorithms_verify_signature_false(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        jws.decode(\n            example_jws,\n            key=example_secret,\n            options={\"verify_signature\": False},\n        )\n\n    def test_load_no_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        decoded_payload = jws.decode(\n            jws_message,\n            key=None,\n            algorithms=[\"HS256\"],\n            options={\"verify_signature\": False},\n        )\n\n        assert decoded_payload == payload\n\n    def test_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n    def test_verify_signature_with_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n        assert \"Signature verification\" in str(exc.value)\n\n    def test_verify_signature_with_no_algo_header_throws_exception(self, jws, payload):\n        example_jws = b\"e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY\"\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, \"secret\", algorithms=[\"HS256\"])\n\n    def test_invalid_crypto_alg(self, jws, payload):\n        with pytest.raises(NotImplementedError):\n            jws.encode(payload, \"secret\", algorithm=\"HS1024\")\n\n    @no_crypto_required\n    def test_missing_crypto_library_better_error_messages(self, jws, payload):\n        with pytest.raises(NotImplementedError) as excinfo:\n            jws.encode(payload, \"secret\", algorithm=\"RS256\")\n            assert \"cryptography\" in str(excinfo.value)\n\n    def test_unicode_secret(self, jws, payload):\n        secret = \"\\xc2\"\n        jws_message = jws.encode(payload, secret)\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_nonascii_secret(self, jws, payload):\n        secret = \"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_bytes_secret(self, jws, payload):\n        secret = b\"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    @pytest.mark.parametrize(\"sort_headers\", (False, True))\n    def test_sorting_of_headers(self, jws, payload, sort_headers):\n        jws_message = jws.encode(\n            payload,\n            key=\"\\xc2\",\n            headers={\"b\": \"1\", \"a\": \"2\"},\n            sort_headers=sort_headers,\n        )\n        header_json = base64url_decode(jws_message.split(\".\")[0])\n        assert sort_headers == (header_json.index(b'\"a\"') < header_json.index(b'\"b\"'))\n\n    def test_decode_invalid_header_padding(self, jws):\n        example_jws = (\n            \"aeyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"header padding\" in str(exc.value)\n\n    def test_decode_invalid_header_string(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTbpIiwgInR5cCI6ICJKV1QifQ==\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid header\" in str(exc.value)\n\n    def test_decode_invalid_payload_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".aeyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid payload padding\" in str(exc.value)\n\n    def test_decode_invalid_crypto_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".aatvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid crypto padding\" in str(exc.value)\n\n    def test_decode_with_algo_none_should_fail(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=\"none\")\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"none\"])\n\n    def test_decode_with_algo_none_and_verify_false_should_pass(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=\"none\")\n        jws.decode(jws_message, options={\"verify_signature\": False})\n\n    def test_get_unverified_header_returns_header_values(self, jws, payload):\n        jws_message = jws.encode(\n            payload,\n            key=\"secret\",\n            algorithm=\"HS256\",\n            headers={\"kid\": \"toomanysecrets\"},\n        )\n\n        header = jws.get_unverified_header(jws_message)\n\n        assert \"kid\" in header\n        assert header[\"kid\"] == \"toomanysecrets\"\n\n    def test_get_unverified_header_fails_on_bad_header_types(self, jws, payload):\n        # Contains a bad kid value (int 123 instead of string)\n        example_jws = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6MTIzfQ\"\n            \".eyJzdWIiOiIxMjM0NTY3ODkwIn0\"\n            \".vs2WY54jfpKP3JGC73Vq5YlMsqM5oTZ1ZydT77SiZSk\"\n        )\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.get_unverified_header(example_jws)\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    @pytest.mark.parametrize(\n        \"algo\",\n        [\n            \"RS256\",\n            \"RS384\",\n            \"RS512\",\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_rsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted RSA key\n        with open(key_path(\"testkey_rsa.priv\"), \"rb\") as rsa_priv_file:\n            priv_rsakey = load_pem_private_key(rsa_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\"), \"rb\") as rsa_pub_file:\n            pub_rsakey = load_ssh_public_key(rsa_pub_file.read())\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_rsa.priv\")) as rsa_priv_file:\n            priv_rsakey = rsa_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\")) as rsa_pub_file:\n            pub_rsakey = rsa_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n    def test_rsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"RS256\" in jws_algorithms\n            assert \"RS384\" in jws_algorithms\n            assert \"RS512\" in jws_algorithms\n            assert \"PS256\" in jws_algorithms\n            assert \"PS384\" in jws_algorithms\n            assert \"PS512\" in jws_algorithms\n\n        else:\n            assert \"RS256\" not in jws_algorithms\n            assert \"RS384\" not in jws_algorithms\n            assert \"RS512\" not in jws_algorithms\n            assert \"PS256\" not in jws_algorithms\n            assert \"PS384\" not in jws_algorithms\n            assert \"PS512\" not in jws_algorithms\n\n    @pytest.mark.parametrize(\n        \"algo\",\n        [\n            \"ES256\",\n            \"ES256K\",\n            \"ES384\",\n            \"ES512\",\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_ecdsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted EC key\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_eckey = load_pem_private_key(ec_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_eckey = load_pem_public_key(ec_pub_file.read())\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_ec.priv\")) as ec_priv_file:\n            priv_eckey = ec_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\")) as ec_pub_file:\n            pub_eckey = ec_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n    def test_ecdsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"ES256\" in jws_algorithms\n            assert \"ES256K\" in jws_algorithms\n            assert \"ES384\" in jws_algorithms\n            assert \"ES512\" in jws_algorithms\n        else:\n            assert \"ES256\" not in jws_algorithms\n            assert \"ES256K\" not in jws_algorithms\n            assert \"ES384\" not in jws_algorithms\n            assert \"ES512\" not in jws_algorithms\n\n    def test_skip_check_signature(self, jws):\n        token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJzb21lIjoicGF5bG9hZCJ9\"\n            \".4twFt5NiznN84AWoo1d7KO1T_yoc0Z6XOpOVswacPZA\"\n        )\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n    def test_decode_options_must_be_dict(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        with pytest.raises(TypeError):\n            jws.decode(token, \"secret\", options=object())\n\n        with pytest.raises((TypeError, ValueError)):\n            jws.decode(token, \"secret\", options=\"something\")\n\n    def test_custom_json_encoder(self, jws, payload):\n        class CustomJSONEncoder(json.JSONEncoder):\n            def default(self, o):\n                assert isinstance(o, Decimal)\n                return \"it worked\"\n\n        data = {\"some_decimal\": Decimal(\"2.2\")}\n\n        with pytest.raises(TypeError):\n            jws.encode(payload, \"secret\", headers=data)\n\n        token = jws.encode(\n            payload, \"secret\", headers=data, json_encoder=CustomJSONEncoder\n        )\n\n        header, *_ = token.split(\".\")\n        header = json.loads(base64url_decode(header))\n\n        assert \"some_decimal\" in header\n        assert header[\"some_decimal\"] == \"it worked\"\n\n    def test_encode_headers_parameter_adds_headers(self, jws, payload):\n        headers = {\"testheader\": True}\n        token = jws.encode(payload, \"secret\", headers=headers)\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header = header.decode()\n\n        header_obj = json.loads(header)\n\n        assert \"testheader\" in header_obj\n        assert header_obj[\"testheader\"] == headers[\"testheader\"]\n\n    def test_encode_with_typ(self, jws):\n        payload = \"\"\"\n        {\n          \"iss\": \"https://scim.example.com\",\n          \"iat\": 1458496404,\n          \"jti\": \"4d3559ec67504aaba65d40b0363faad8\",\n          \"aud\": [\n            \"https://scim.example.com/Feeds/98d52461fa5bbc879593b7754\",\n            \"https://scim.example.com/Feeds/5d7604516b1d08641d7676ee7\"\n          ],\n          \"events\": {\n            \"urn:ietf:params:scim:event:create\": {\n              \"ref\":\n                  \"https://scim.example.com/Users/44f6142df96bd6ab61e7521d9\",\n              \"attributes\": [\"id\", \"name\", \"userName\", \"password\", \"emails\"]\n            }\n          }\n        }\n        \"\"\"\n        token = jws.encode(\n            payload.encode(\"utf-8\"), \"secret\", headers={\"typ\": \"secevent+jwt\"}\n        )\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" in header_obj\n        assert header_obj[\"typ\"] == \"secevent+jwt\"\n\n    def test_encode_with_typ_empty_string(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": \"\"})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_none(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": None})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_without_keywords(self, jws, payload):\n        headers = {\"foo\": \"bar\"}\n        token = jws.encode(payload, \"secret\", \"HS256\", headers, None)\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"foo\" in header_obj\n        assert header_obj[\"foo\"] == \"bar\"\n\n    def test_encode_fails_on_invalid_kid_types(self, jws, payload):\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": 123})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": None})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    def test_encode_decode_with_detached_content(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        jws.decode(jws_message, secret, algorithms=[\"HS256\"], detached_payload=payload)\n\n    def test_encode_detached_content_with_b64_header(self, jws, payload):\n        secret = \"secret\"\n\n        # Check that detached content is automatically detected when b64 is false\n        headers = {\"b64\": False}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" in msg_header_obj\n        assert msg_header_obj[\"b64\"] is False\n        # Check that the payload is not inside the token\n        assert not msg_payload\n\n        # Check that content is not detached and b64 header removed when b64 is true\n        headers = {\"b64\": True}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" not in msg_header_obj\n        assert msg_payload\n\n    def test_decode_detached_content_without_proper_argument(self, jws):\n        example_jws = (\n            \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2V9\"\n            \".\"\n            \".65yNkX_ZH4A_6pHaTL_eI84OXOHtfl4K0k5UnlXZ8f4\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert (\n            'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'\n            in str(exc.value)\n        )\n\n    def test_decode_warns_on_unsupported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n\n    def test_decode_complete_warns_on_unuspported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode_complete(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)"
    },
    {
      "path": "tests/test_api_jws.py",
      "version": "new",
      "line": 658,
      "kind": "function",
      "qualname": "tests.test_api_jws.TestJWS.test_encode_decode_ecdsa_related_algorithms",
      "span": [
        658,
        670
      ],
      "reason": "diff_new_line_in_def",
      "is_test": true,
      "seed_type": "test_change",
      "new_code": "    def test_encode_decode_ecdsa_related_algorithms(\n        self, jws, payload, algo, priv_key_file, pub_key_file\n    ):\n        from jwt.algorithms import ECAlgorithm\n\n        # Load keys from JWK files (each algorithm requires its specific curve)\n        with open(key_path(priv_key_file)) as priv_file:\n            priv_eckey = ECAlgorithm.from_jwk(priv_file.read())\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(pub_key_file)) as pub_file:\n            pub_eckey = ECAlgorithm.from_jwk(pub_file.read())\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])",
      "old_code": "    def test_encode_decode_ecdsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted EC key\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_eckey = load_pem_private_key(ec_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_eckey = load_pem_public_key(ec_pub_file.read())\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_ec.priv\")) as ec_priv_file:\n            priv_eckey = ec_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\")) as ec_pub_file:\n            pub_eckey = ec_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])"
    }
  ],
  "generated_at": "2026-02-10T14:57:57"
}