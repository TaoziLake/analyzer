{
  "commit": "08b5dfb",
  "parent": "171d2a34f394022d7d426106e414e9a7b3eb78cb",
  "repo": "D:\\locbench\\pyjwt",
  "num_files_in_diff": 1,
  "num_py_files_in_diff": 1,
  "num_seeds": 6,
  "seeds": [
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 96,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.fetch_data",
      "span": [
        95,
        120
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def fetch_data(self) -> Any:\n        \"\"\"Fetch the JWK Set from the JWKS endpoint.\n\n        Makes an HTTP request to the configured ``uri`` and returns the\n        parsed JSON response. If the JWK Set cache is enabled, the\n        response is stored in the cache.\n\n        :returns: The parsed JWK Set as a dictionary.\n        :raises PyJWKClientConnectionError: If the HTTP request fails.\n        \"\"\"\n        jwk_set: Any = None\n        try:\n            r = urllib.request.Request(url=self.uri, headers=self.headers)\n            with urllib.request.urlopen(\n                r, timeout=self.timeout, context=self.ssl_context\n            ) as response:\n                jwk_set = json.load(response)\n        except (URLError, TimeoutError) as e:\n            raise PyJWKClientConnectionError(\n                f'Fail to fetch data from the url, err: \"{e}\"'\n            ) from e\n        else:\n            return jwk_set\n        finally:\n            if self.jwk_set_cache is not None:\n                self.jwk_set_cache.put(jwk_set)",
      "old_code": "    def fetch_data(self) -> Any:\n        jwk_set: Any = None\n        try:\n            r = urllib.request.Request(url=self.uri, headers=self.headers)\n            with urllib.request.urlopen(\n                r, timeout=self.timeout, context=self.ssl_context\n            ) as response:\n                jwk_set = json.load(response)\n        except (URLError, TimeoutError) as e:\n            raise PyJWKClientConnectionError(\n                f'Fail to fetch data from the url, err: \"{e}\"'\n            ) from e\n        else:\n            return jwk_set\n        finally:\n            if self.jwk_set_cache is not None:\n                self.jwk_set_cache.put(jwk_set)"
    },
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 123,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.get_jwk_set",
      "span": [
        122,
        143
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def get_jwk_set(self, refresh: bool = False) -> PyJWKSet:\n        \"\"\"Return the JWK Set, using the cache when available.\n\n        :param refresh: Force a fresh fetch from the endpoint, bypassing\n            the cache.\n        :type refresh: bool\n        :returns: The JWK Set.\n        :rtype: PyJWKSet\n        :raises PyJWKClientError: If the endpoint does not return a JSON\n            object.\n        \"\"\"\n        data = None\n        if self.jwk_set_cache is not None and not refresh:\n            data = self.jwk_set_cache.get()\n\n        if data is None:\n            data = self.fetch_data()\n\n        if not isinstance(data, dict):\n            raise PyJWKClientError(\"The JWKS endpoint did not return a JSON object\")\n\n        return PyJWKSet.from_dict(data)",
      "old_code": "    def get_jwk_set(self, refresh: bool = False) -> PyJWKSet:\n        data = None\n        if self.jwk_set_cache is not None and not refresh:\n            data = self.jwk_set_cache.get()\n\n        if data is None:\n            data = self.fetch_data()\n\n        if not isinstance(data, dict):\n            raise PyJWKClientError(\"The JWKS endpoint did not return a JSON object\")\n\n        return PyJWKSet.from_dict(data)"
    },
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 146,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.get_signing_keys",
      "span": [
        145,
        168
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def get_signing_keys(self, refresh: bool = False) -> list[PyJWK]:\n        \"\"\"Return all signing keys from the JWK Set.\n\n        Filters the JWK Set to keys whose ``use`` is ``\"sig\"`` (or\n        unspecified) and that have a ``kid``.\n\n        :param refresh: Force a fresh fetch from the endpoint, bypassing\n            the cache.\n        :type refresh: bool\n        :returns: A list of signing keys.\n        :rtype: list[PyJWK]\n        :raises PyJWKClientError: If no signing keys are found.\n        \"\"\"\n        jwk_set = self.get_jwk_set(refresh)\n        signing_keys = [\n            jwk_set_key\n            for jwk_set_key in jwk_set.keys\n            if jwk_set_key.public_key_use in [\"sig\", None] and jwk_set_key.key_id\n        ]\n\n        if not signing_keys:\n            raise PyJWKClientError(\"The JWKS endpoint did not contain any signing keys\")\n\n        return signing_keys",
      "old_code": "    def get_signing_keys(self, refresh: bool = False) -> list[PyJWK]:\n        jwk_set = self.get_jwk_set(refresh)\n        signing_keys = [\n            jwk_set_key\n            for jwk_set_key in jwk_set.keys\n            if jwk_set_key.public_key_use in [\"sig\", None] and jwk_set_key.key_id\n        ]\n\n        if not signing_keys:\n            raise PyJWKClientError(\"The JWKS endpoint did not contain any signing keys\")\n\n        return signing_keys"
    },
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 171,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.get_signing_key",
      "span": [
        170,
        196
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def get_signing_key(self, kid: str) -> PyJWK:\n        \"\"\"Return the signing key matching the given ``kid``.\n\n        If no match is found in the current JWK Set, the set is\n        refreshed from the endpoint and the lookup is retried once.\n\n        :param kid: The key ID to look up.\n        :type kid: str\n        :returns: The matching signing key.\n        :rtype: PyJWK\n        :raises PyJWKClientError: If no matching key is found after\n            refreshing.\n        \"\"\"\n        signing_keys = self.get_signing_keys()\n        signing_key = self.match_kid(signing_keys, kid)\n\n        if not signing_key:\n            # If no matching signing key from the jwk set, refresh the jwk set and try again.\n            signing_keys = self.get_signing_keys(refresh=True)\n            signing_key = self.match_kid(signing_keys, kid)\n\n            if not signing_key:\n                raise PyJWKClientError(\n                    f'Unable to find a signing key that matches: \"{kid}\"'\n                )\n\n        return signing_key",
      "old_code": "    def get_signing_key(self, kid: str) -> PyJWK:\n        signing_keys = self.get_signing_keys()\n        signing_key = self.match_kid(signing_keys, kid)\n\n        if not signing_key:\n            # If no matching signing key from the jwk set, refresh the jwk set and try again.\n            signing_keys = self.get_signing_keys(refresh=True)\n            signing_key = self.match_kid(signing_keys, kid)\n\n            if not signing_key:\n                raise PyJWKClientError(\n                    f'Unable to find a signing key that matches: \"{kid}\"'\n                )\n\n        return signing_key"
    },
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 199,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.get_signing_key_from_jwt",
      "span": [
        198,
        211
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def get_signing_key_from_jwt(self, token: str | bytes) -> PyJWK:\n        \"\"\"Return the signing key for a JWT by reading its ``kid`` header.\n\n        Extracts the ``kid`` from the token's unverified header and\n        delegates to :meth:`get_signing_key`.\n\n        :param token: The encoded JWT.\n        :type token: str or bytes\n        :returns: The matching signing key.\n        :rtype: PyJWK\n        \"\"\"\n        unverified = decode_token(token, options={\"verify_signature\": False})\n        header = unverified[\"header\"]\n        return self.get_signing_key(header.get(\"kid\"))",
      "old_code": "    def get_signing_key_from_jwt(self, token: str | bytes) -> PyJWK:\n        unverified = decode_token(token, options={\"verify_signature\": False})\n        header = unverified[\"header\"]\n        return self.get_signing_key(header.get(\"kid\"))"
    },
    {
      "path": "jwt/jwks_client.py",
      "version": "new",
      "line": 215,
      "kind": "function",
      "qualname": "jwt.jwks_client.PyJWKClient.match_kid",
      "span": [
        214,
        231
      ],
      "reason": "diff_new_line_in_def",
      "is_test": false,
      "seed_type": "code_change",
      "new_code": "    def match_kid(signing_keys: list[PyJWK], kid: str) -> PyJWK | None:\n        \"\"\"Find a key in *signing_keys* that matches *kid*.\n\n        :param signing_keys: The list of keys to search.\n        :type signing_keys: list[PyJWK]\n        :param kid: The key ID to match.\n        :type kid: str\n        :returns: The matching key, or ``None`` if not found.\n        :rtype: PyJWK or None\n        \"\"\"\n        signing_key = None\n\n        for key in signing_keys:\n            if key.key_id == kid:\n                signing_key = key\n                break\n\n        return signing_key",
      "old_code": "    def match_kid(signing_keys: list[PyJWK], kid: str) -> PyJWK | None:\n        signing_key = None\n\n        for key in signing_keys:\n            if key.key_id == kid:\n                signing_key = key\n                break\n\n        return signing_key"
    }
  ],
  "generated_at": "2026-02-10T14:44:36"
}